<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>오늘 뭐 먹지? 룰렛 (DB 연동)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=9ddcc83d3b7ed7f48495e2de9a0a4460&libraries=services"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .roulette-container {
            position: relative;
            width: 90vw;
            height: 90vw;
            max-width: 450px;
            max-height: 450px;
        }
        canvas {
            width: 100%;
            height: 100%;
            transition: transform 5s cubic-bezier(0.25, 1, 0.5, 1);
        }
        .pointer {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 30px solid #ef4444; /* red-500 */
            z-index: 10;
        }
        .blinking {
            animation: blinker 1s linear infinite;
        }
        @keyframes blinker {
            50% {
                opacity: 0.3;
            }
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        .mode-button {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .mode-button:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 35px -15px rgba(30, 64, 175, 0.35);
        }
        .mode-button-active {
            background-color: #111827 !important;
            color: #f8fafc !important;
            box-shadow: 0 25px 50px -12px rgba(30, 64, 175, 0.45);
        }
        .mode-button-badge {
            font-size: 0.75rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #94a3b8;
            font-weight: 600;
        }
        .mode-button-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #0f172a;
        }
        .mode-button-subtitle {
            font-size: 0.95rem;
            color: #4b5563;
        }
        .mode-tab-label {
            font-weight: 600;
            color: #1f2937;
        }
        .mode-button-arrow {
            font-size: 1.75rem;
            color: #cbd5f5;
        }
        .mode-button-active .mode-button-badge,
        .mode-button-active .mode-button-title,
        .mode-button-active .mode-button-subtitle,
        .mode-button-active .mode-tab-label,
        .mode-button-active .mode-button-arrow {
            color: #f8fafc !important;
        }
        .mode-hidden {
            display: none !important;
        }
        .race-track {
            position: relative;
            height: 2.75rem;
            border-radius: 9999px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.95), rgba(241, 245, 249, 0.95));
            border: 1px solid #e2e8f0;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.75);
            overflow: hidden;
        }
        .race-track-inner {
            position: absolute;
            inset: 6px;
            border-radius: 9999px;
            background: rgba(148, 163, 184, 0.18);
            overflow: hidden;
        }
        .race-track-fill {
            height: 100%;
            width: 0%;
            border-radius: inherit;
            background: linear-gradient(90deg, #fcd34d, #f97316);
            transition: width 0.15s ease-out;
            box-shadow: inset 0 0 12px rgba(251, 191, 36, 0.35);
        }
        .race-track-icon {
            position: absolute;
            top: 50%;
            left: 0%;
            transform: translate(-50%, -50%);
            font-size: 1.75rem;
            transition: left 0.15s ease-out;
            filter: drop-shadow(0 6px 8px rgba(15, 23, 42, 0.18));
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="min-h-screen flex flex-col">
        <section id="landing-screen" class="flex-1 flex flex-col items-center justify-center px-4 py-12 text-center">
            <div class="max-w-2xl mx-auto space-y-10">
                <div class="space-y-3">
                    <h1 class="text-4xl sm:text-5xl font-bold text-gray-900">오늘 뭐 먹지?</h1>
                    <p class="text-gray-600 text-base sm:text-lg">네 가지 방식으로 점심 고민을 단번에 해결해 보세요.</p>
                </div>
                <div class="grid sm:grid-cols-2 gap-3" data-race-summary>
                    <div class="p-4 bg-white border border-slate-200 rounded-2xl shadow-sm">
                        <p class="text-xs font-semibold text-amber-600 uppercase tracking-wide">커피 내기 경마 통계</p>
                        <p class="mt-2 text-sm text-slate-600">레이스를 시작하면 여기에서 우승 기록을 확인할 수 있어요.</p>
                    </div>
                </div>
                <div class="grid gap-4">
                    <button class="mode-button flex items-center justify-between w-full h-28 px-6 rounded-2xl border border-transparent bg-white text-left shadow-sm" data-mode-target="location">
                        <div class="space-y-2">
                            <span class="mode-button-badge">MODE 01</span>
                            <p class="mode-button-title">📍 위치기반 모드</p>
                            <p class="mode-button-subtitle">현재 위치 정보를 바탕으로 후보를 자동으로 채워요.</p>
                        </div>
                        <span class="mode-button-arrow">➜</span>
                    </button>
                    <button class="mode-button flex items-center justify-between w-full h-28 px-6 rounded-2xl border border-transparent bg-white text-left shadow-sm" data-mode-target="team">
                        <div class="space-y-2">
                            <span class="mode-button-badge">MODE 02</span>
                            <p class="mode-button-title">🤝 팀플레이 모드</p>
                            <p class="mode-button-subtitle">같은 엑세스 코드로 접속해 팀원과 함께 룰렛을 채워요.</p>
                        </div>
                        <span class="mode-button-arrow">➜</span>
                    </button>
                    <button class="mode-button flex items-center justify-between w-full h-28 px-6 rounded-2xl border border-transparent bg-white text-left shadow-sm" data-mode-target="custom">
                        <div class="space-y-2">
                            <span class="mode-button-badge">MODE 03</span>
                            <p class="mode-button-title">🎨 커스텀 모드</p>
                            <p class="mode-button-subtitle">나만의 룰렛을 직접 만들고 자랑해 보세요.</p>
                        </div>
                        <span class="mode-button-arrow">➜</span>
                    </button>
                    <button class="mode-button flex items-center justify-between w-full h-28 px-6 rounded-2xl border border-transparent bg-white text-left shadow-sm" data-mode-target="race">
                        <div class="space-y-2">
                            <span class="mode-button-badge">MODE 04</span>
                            <p class="mode-button-title">🏇 커피 내기 경마</p>
                            <p class="mode-button-subtitle">즐겨 찾는 말들을 선택하고 레이스로 커피 내기 우승자를 정해요.</p>
                        </div>
                        <span class="mode-button-arrow">➜</span>
                    </button>
                </div>
            </div>
            
        </section>

        <section id="app-shell" class="hidden flex-1 px-4 py-10">
            <div class="w-full max-w-7xl mx-auto space-y-8">
                <div class="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
                    <div class="space-y-2">
                        <h2 class="text-3xl font-bold text-gray-900">모드를 바꿔가며 다양한 점심 아이디어를 만나보세요</h2>
                        <p id="mode-description" class="text-sm text-gray-500">현재 위치를 기반으로 주변 식당 후보를 자동으로 채워 드립니다.</p>
                    </div>
                    <div class="grid grid-cols-2 sm:grid-cols-4 gap-3 w-full sm:w-auto">
                        <button id="home-btn" class="mode-button mode-tab flex items-center justify-center h-10 px-4 rounded-full border border-transparent bg-white shadow-sm text-sm font-semibold text-gray-600">
                            Home
                        </button>
                        <button class="mode-button mode-tab flex items-center justify-center h-14 px-5 rounded-full border border-transparent bg-white shadow-sm" data-mode-target="location">
                            <span class="mode-tab-label">📍 위치기반</span>
                        </button>
                        <button class="mode-button mode-tab flex items-center justify-center h-14 px-5 rounded-full border border-transparent bg-white shadow-sm" data-mode-target="team">
                            <span class="mode-tab-label">🤝 팀플레이</span>
                        </button>
                        <button class="mode-button mode-tab flex items-center justify-center h-14 px-5 rounded-full border border-transparent bg-white shadow-sm" data-mode-target="custom">
                            <span class="mode-tab-label">🎨 커스텀</span>
                        </button>
                        <button class="mode-button mode-tab flex items-center justify-center h-14 px-5 rounded-full border border-transparent bg-white shadow-sm" data-mode-target="race">
                            <span class="mode-tab-label">🏇 경마</span>
                        </button>
                    </div>
                </div>
                <div class="flex flex-col xl:flex-row gap-6">
                    <aside class="w-full xl:w-72 space-y-6">
                        <div id="restaurant-list-container" data-mode-visible="location" class="bg-white p-5 rounded-2xl shadow-lg mode-hidden">
                            <div class="flex items-center justify-between mb-3">
                                <h3 class="text-xl font-bold text-gray-900">오늘의 후보</h3>
                                <span class="text-xs font-semibold text-amber-600 bg-amber-100 px-2 py-0.5 rounded-full">자동 추천</span>
                            </div>
                            <div id="candidate-lists-wrapper" class="space-y-4"></div>
                        </div>

                        <div id="team-card" data-mode-visible="team" class="bg-white rounded-2xl shadow-lg p-5 space-y-4 mode-hidden">
                            <div class="text-center space-y-1">
                                <h3 class="text-xl font-bold text-gray-900">🤝 팀플레이</h3>
                                <p class="text-xs text-gray-500">같은 엑세스 코드로 접속하면 하나의 룰렛을 함께 채울 수 있어요.</p>
                            </div>
                            <div class="flex flex-col sm:flex-row gap-2">
                                <input id="team-access-input" type="text" placeholder="엑세스 코드 (영문/숫자)" class="border rounded px-3 py-2 text-sm flex-1">
                                <button id="team-join-btn" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded-md">참여하기</button>
                                <button id="team-leave-btn" class="hidden bg-slate-500 hover:bg-slate-600 text-white font-bold py-2 px-4 rounded-md">나가기</button>
                            </div>
                            <p id="team-status" class="text-xs text-center text-slate-500">엑세스 코드를 입력하면 팀이 생성되거나 입장됩니다.</p>
                            <div class="flex flex-col items-center gap-1 text-xs text-slate-500">
                                <label for="team-slot-count" class="font-semibold text-gray-600">룰렛 칸 수</label>
                                <input id="team-slot-count" type="number" min="2" max="9" value="9" disabled class="w-20 border rounded px-2 py-1 text-sm text-center opacity-60 cursor-not-allowed">
                                <p class="text-[11px] text-slate-400">최소 2칸 · 최대 9칸</p>
                            </div>
                            <div id="team-slots-container" class="space-y-2 hidden"></div>
                        </div>

                        <div id="race-summary-card" data-mode-visible="race" class="bg-white rounded-2xl shadow-lg p-5 space-y-4 mode-hidden">
                            <div class="text-center space-y-1">
                                <h3 class="text-xl font-bold text-gray-900">🏆 우승 기록</h3>
                                <p class="text-xs text-gray-500">가장 많이 우승한 말들을 확인하세요.</p>
                            </div>
                            <div class="space-y-3" data-race-summary>
                                <p class="text-sm text-slate-500">아직 경마 기록이 없습니다.</p>
                            </div>
                        </div>
                    </aside>

                    <section class="flex-1 space-y-6">
                        <div class="bg-white rounded-2xl shadow-xl p-6 sm:p-8 space-y-6" data-mode-visible="location,team,custom">
                            <div class="space-y-4 text-center">
                                <span id="active-mode-badge" class="inline-flex items-center justify-center gap-2 px-4 py-1 rounded-full bg-slate-100 text-sm font-semibold text-slate-600">📍 위치기반 모드</span>
                                <h3 class="text-3xl font-bold text-gray-900">오늘 뭐 먹지?</h3>
                                <p id="status-message" class="text-gray-600 min-h-[1.5rem]">모드를 선택해 주세요.</p>
                                <div id="location-fallback" data-mode-visible="location" class="hidden mode-hidden mt-2 flex flex-wrap items-center justify-center gap-2 text-sm">
                                    <span class="text-gray-500">위치 접근이 어렵다면?</span>
                                    <label class="flex items-center gap-2">
                                        <span class="text-gray-600">동네 선택</span>
                                        <select id="manual-location-select" class="border rounded px-2 py-1 text-sm">
                                            <option value="">동네를 골라주세요</option>
                                            <option value="37.4979,127.0276">서울 강남역</option>
                                            <option value="37.5575,126.9249">서울 홍대입구</option>
                                            <option value="37.4021,127.1089">경기 판교</option>
                                            <option value="35.1576,129.0591">부산 서면</option>
                                            <option value="35.8714,128.6014">대구 동성로</option>
                                            <option value="35.1796,129.0756">부산 남포동</option>
                                        </select>
                                    </label>
                                    <button id="apply-manual-location" class="bg-amber-500 hover:bg-amber-600 text-white font-semibold px-3 py-1 rounded-md">이 동네로 보기</button>
                                </div>
                            </div>

                            <div class="flex justify-center">
                                <div class="roulette-container">
                                    <div class="pointer"></div>
                                    <canvas id="rouletteCanvas"></canvas>
                                </div>
                            </div>

                            <div id="winner-card" class="hidden w-full max-w-xl mx-auto bg-slate-50 border border-slate-100 rounded-xl shadow-inner p-5 space-y-3">
                                <div class="flex items-start justify-between">
                                    <div>
                                        <p class="text-sm font-semibold text-green-600">오늘의 당첨!</p>
                                        <h4 id="winner-name" class="text-2xl font-bold text-gray-800"></h4>
                                    </div>
                                    <span id="winner-tag" class="text-xs bg-green-100 text-green-700 px-2 py-1 rounded-full">행운 가득</span>
                                </div>
                                <div class="space-y-2 text-sm text-gray-600">
                                    <p id="winner-address" class="flex items-center gap-2"></p>
                                    <p id="winner-phone" class="flex items-center gap-2"></p>
                                    <p id="winner-tip" class="flex items-center gap-2 text-xs text-gray-500"></p>
                                </div>
                                <div class="flex flex-wrap gap-2">
                                    <a id="winner-map-btn" class="flex-1 text-center bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 rounded-md" target="_blank" rel="noopener">길찾기</a>
                                    <a id="winner-call-btn" class="flex-1 text-center bg-emerald-500 hover:bg-emerald-600 text-white font-semibold py-2 rounded-md" target="_blank" rel="noopener">전화하기</a>
                                </div>
                                <button id="winner-reroll" class="w-full bg-gray-900 hover:bg-gray-700 text-white font-bold py-2 rounded-md">다시 돌리기</button>
                            </div>

                            <div class="space-y-4">
                                <div data-mode-visible="location" class="mode-hidden">
                                    <div class="bg-slate-50 border border-slate-200 rounded-xl p-4 space-y-4 text-left">
                                        <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                                            <label for="mode-select" class="font-semibold text-gray-700 flex items-center gap-2">
                                                룰렛 모드
                                                <span class="text-xs bg-slate-100 text-slate-500 px-2 py-0.5 rounded-full">평점/리뷰 기반 추천은 준비 중</span>
                                            </label>
                                            <select id="mode-select" class="rounded-md border-gray-300 shadow-sm">
                                                <option value="mix" selected>🍱 추천 믹스</option>
                                                <option value="distance">🚶‍♂️ 가까운 순 9곳</option>
                                                <option value="random">🎲 랜덤 9</option>
                                            </select>
                                        </div>
                                        <div id="reset-default-slot">
                                            <div id="reset-btn-wrapper">
                                                <button id="resetBtn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 rounded-full shadow-lg">다시 불러오기</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div id="start-default-slot">
                                    <div id="start-btn-wrapper" class="flex flex-wrap justify-center gap-3">
                                        <button id="startBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-10 rounded-full shadow-lg" disabled>START</button>
                                    </div>
                                </div>

                                <div id="save-container" class="hidden">
                                    <div class="bg-slate-50 border border-slate-200 rounded-xl p-4">
                                        <div class="flex flex-col sm:flex-row sm:items-center sm:space-x-2 gap-2">
                                            <input type="text" id="roulette-name-input" placeholder="룰렛 이름 입력" class="border rounded px-3 py-2 flex-grow">
                                            <button id="saveBtn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-md">저장</button>
                                        </div>
                                        <p class="text-xs text-gray-500 mt-3 text-center">마음에 드는 룰렛이 나오면 소장해두고 계속 사용해보세요!</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="race-panel" data-mode-visible="race" class="bg-white rounded-2xl shadow-xl p-6 sm:p-8 space-y-6 mode-hidden">
                            <div class="space-y-2 text-center">
                                <span class="inline-flex items-center justify-center gap-2 px-4 py-1 rounded-full bg-amber-100 text-sm font-semibold text-amber-600">🏇 MODE 04</span>
                                <h3 class="text-3xl font-bold text-gray-900">커피 내기 경마 트랙</h3>
                                <p id="race-status-label" class="text-gray-600 min-h-[1.5rem]">출전할 말을 선택해 주세요.</p>
                            </div>

                            <div class="grid gap-6 lg:grid-cols-2">
                                <div class="space-y-5">
                                    <div class="space-y-3">
                                        <label class="flex items-center justify-between text-sm font-semibold text-slate-700">
                                            출전 말 수
                                            <span class="text-xs text-slate-400">최소 2두 · 최대 10두</span>
                                        </label>
                                        <div class="flex items-center gap-3">
                                            <input id="race-horse-count-input" type="number" min="2" max="10" value="5" class="w-20 border rounded-md px-3 py-2 text-sm">
                                            <input id="race-horse-count-range" type="range" min="2" max="10" value="5" class="flex-1">
                                        </div>
                                    </div>

                                    <div class="space-y-3">
                                        <div class="flex items-center justify-between">
                                            <h4 class="font-semibold text-gray-800">말 선택</h4>
                                            <span id="race-selected-counter" class="text-xs text-slate-500">0 / 10</span>
                                        </div>
                                        <p class="text-xs text-slate-500">즐겨 찾는 말 10두 가운데에서 레이스에 내보낼 말을 골라 주세요.</p>
                                        <div id="race-horse-list" class="grid grid-cols-2 gap-2"></div>
                                    </div>
                                </div>

                                <div class="space-y-5">
                                    <div class="bg-slate-50 border border-slate-200 rounded-xl p-4 space-y-4">
                                        <div class="flex items-center justify-between">
                                            <span class="text-sm font-semibold text-slate-600">레이스 진행 상황</span>
                                            <span id="race-timer" class="text-xs text-slate-500">00:00</span>
                                        </div>
                                        <div id="race-track" class="space-y-3"></div>
                                        <div id="race-controls-container" class="space-y-3">
                                            <div class="text-xs text-slate-500">START를 누르면 모든 말이 출발해요. 경기가 끝날 때까지 UI가 잠깁니다.</div>
                                            <div id="race-controls-slot" class="flex flex-wrap justify-center gap-3"></div>
                                        </div>
                                    </div>

                                    <div id="race-results" class="hidden bg-slate-900 text-white rounded-xl p-5 space-y-3">
                                        <div class="flex items-center justify-between">
                                            <h4 class="text-lg font-semibold">결과 발표</h4>
                                            <span class="text-xs uppercase tracking-widest text-amber-300">Finish</span>
                                        </div>
                                        <ol id="race-results-list" class="space-y-2 text-sm"></ol>
                                        <button id="race-again-btn" class="hidden w-full bg-amber-500 hover:bg-amber-600 text-white font-semibold py-2 rounded-full">다시 달리기</button>
                                        <p class="text-xs text-amber-200 text-center">우승 기록은 저장되어 다음 레이스에도 반영돼요.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <aside id="custom-panels" data-mode-visible="custom" class="w-full xl:w-96 space-y-6 mode-hidden">
                        <div class="bg-white rounded-2xl shadow-lg p-5">
                            <h3 class="text-xl font-bold text-center mb-2">나의 룰렛 목록</h3>
                            <div id="saved-roulettes-list" class="h-48 overflow-y-auto custom-scrollbar"></div>
                        </div>
                        <div class="bg-white rounded-2xl shadow-lg p-5 space-y-4">
                            <div class="text-center space-y-1">
                                <h3 class="text-xl font-bold text-gray-900">📝 직접 차트 만들기</h3>
                                <p class="text-xs text-gray-500">원하는 칸 수(최소 2칸 ~ 최대 9칸)로 자유롭게 채워보세요. 비어 있는 칸은 자동으로 ‘다시 한 번’으로 채워집니다.</p>
                            </div>
                            <div class="space-y-2">
                                <div class="flex items-center justify-between text-sm font-semibold text-slate-700">
                                    <span>룰렛 칸 수</span>
                                    <div class="flex items-center gap-2">
                                        <input id="custom-slot-count" type="range" min="2" max="9" value="9" class="w-32">
                                        <span id="custom-slot-count-display" class="text-xs text-slate-500">9칸</span>
                                    </div>
                                </div>
                                <p class="text-[11px] text-slate-400 text-right">슬라이더를 움직여 칸 수를 조절하세요.</p>
                            </div>
                            <div class="grid grid-cols-2 gap-2">
                                <button class="sample-template-btn bg-slate-200 hover:bg-slate-300 text-gray-700 text-sm font-semibold py-2 rounded" data-template="korean">한식 샘플</button>
                                <button class="sample-template-btn bg-slate-200 hover:bg-slate-300 text-gray-700 text-sm font-semibold py-2 rounded" data-template="noodle">면 요리 샘플</button>
                                <button class="sample-template-btn bg-slate-200 hover:bg-slate-300 text-gray-700 text-sm font-semibold py-2 rounded" data-template="office">직장인 빠른 점심</button>
                                <button class="sample-template-btn bg-slate-200 hover:bg-slate-300 text-gray-700 text-sm font-semibold py-2 rounded" data-template="snack">분식 인기 메뉴</button>
                            </div>
                            <div id="custom-chart-inputs" class="grid grid-cols-2 sm:grid-cols-3 gap-2"></div>
                            <button id="apply-custom-btn" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 rounded-md">적용하기</button>
                        </div>
                        <div class="bg-white rounded-2xl shadow-lg p-5 space-y-3">
                            <div class="text-center space-y-1">
                                <h3 class="text-xl font-bold text-gray-900">👑 룰렛 자랑하기</h3>
                                <p class="text-xs text-gray-500">좋아요가 많은 순서대로 보여드려요. 싫어요가 많은 글은 운영자가 확인 후 숨깁니다.</p>
                            </div>
                            <input type="search" id="search-shared" placeholder="예: (역삼) 족발" class="w-full p-2 border rounded-md">
                            <div id="shared-roulettes-list" class="h-[430px] overflow-y-auto custom-scrollbar"></div>
                        </div>
                    </aside>
                </div>
            </div>
        </section>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, doc, getDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, updateDoc, increment, arrayUnion, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- UI 요소 ---
        const canvas = document.getElementById('rouletteCanvas');
        const ctx = canvas.getContext('2d');
        const resetBtn = document.getElementById('resetBtn');
        const startBtn = document.getElementById('startBtn');
        const saveBtn = document.getElementById('saveBtn');
        const statusMessage = document.getElementById('status-message');
        const saveContainer = document.getElementById('save-container');
        const rouletteNameInput = document.getElementById('roulette-name-input');
        const savedRoulettesList = document.getElementById('saved-roulettes-list');
        const restaurantListContainer = document.getElementById('restaurant-list-container');
        const candidateListsWrapper = document.getElementById('candidate-lists-wrapper');
        const modeSelect = document.getElementById('mode-select');
        const sharedRoulettesList = document.getElementById('shared-roulettes-list');
        const searchSharedInput = document.getElementById('search-shared');
        const applyCustomBtn = document.getElementById('apply-custom-btn');
        const locationFallback = document.getElementById('location-fallback');
        const manualLocationSelect = document.getElementById('manual-location-select');
        const applyManualLocationBtn = document.getElementById('apply-manual-location');
        const winnerCard = document.getElementById('winner-card');
        const winnerName = document.getElementById('winner-name');
        const winnerAddress = document.getElementById('winner-address');
        const winnerPhone = document.getElementById('winner-phone');
        const winnerTip = document.getElementById('winner-tip');
        const winnerMapBtn = document.getElementById('winner-map-btn');
        const winnerCallBtn = document.getElementById('winner-call-btn');
        const winnerRerollBtn = document.getElementById('winner-reroll');
        const winnerTag = document.getElementById('winner-tag');
        const teamAccessInput = document.getElementById('team-access-input');
        const teamJoinBtn = document.getElementById('team-join-btn');
        const teamLeaveBtn = document.getElementById('team-leave-btn');
        const teamStatus = document.getElementById('team-status');
        const teamSlotsContainer = document.getElementById('team-slots-container');
        const landingScreen = document.getElementById('landing-screen');
        const appShell = document.getElementById('app-shell');
        const activeModeBadge = document.getElementById('active-mode-badge');
        const modeDescription = document.getElementById('mode-description');
        const modeButtons = document.querySelectorAll('[data-mode-target]');
        const modeScopedElements = document.querySelectorAll('[data-mode-visible]');
        const homeBtn = document.getElementById('home-btn');
        const racePanel = document.getElementById('race-panel');
        const raceHorseCountInput = document.getElementById('race-horse-count-input');
        const raceHorseCountRange = document.getElementById('race-horse-count-range');
        const raceHorseList = document.getElementById('race-horse-list');
        const raceSelectedCounter = document.getElementById('race-selected-counter');
        const raceTrack = document.getElementById('race-track');
        const raceStatusLabel = document.getElementById('race-status-label');
        const raceTimer = document.getElementById('race-timer');
        const raceResults = document.getElementById('race-results');
        const raceResultsList = document.getElementById('race-results-list');
        const raceAgainBtn = document.getElementById('race-again-btn');
        const raceControlsSlot = document.getElementById('race-controls-slot');
        const raceControlsContainer = document.getElementById('race-controls-container');
        const startDefaultSlot = document.getElementById('start-default-slot');
        const resetDefaultSlot = document.getElementById('reset-default-slot');
        const startBtnWrapper = document.getElementById('start-btn-wrapper');
        const resetBtnWrapper = document.getElementById('reset-btn-wrapper');
        const raceSummaryNodes = document.querySelectorAll('[data-race-summary]');
        const teamSlotCountInput = document.getElementById('team-slot-count');
        const customSlotCountInput = document.getElementById('custom-slot-count');
        const customSlotCountDisplay = document.getElementById('custom-slot-count-display');
        const customChartInputs = document.getElementById('custom-chart-inputs');

        // --- 전역 변수 ---
        const MIN_SEGMENT_COUNT = 2;
        const MAX_SEGMENT_COUNT = 9;
        const DEFAULT_SEGMENT_COUNT = 9;
        let segmentCount = DEFAULT_SEGMENT_COUNT;
        const colors = ['#fde68a', '#dcfce7', '#dbeafe', '#f3e8ff', '#fee2e2', '#fef3c7', '#e0f2fe', '#fce7f3', '#e5e7eb'];
        let restaurants = [];
        let isSpinning = false;
        let winnerIndex = -1;
        let blinkAnimationId;
        let db, auth, userId;
        let lastKnownCoords = null;
        let allSharedRoulettes = [];
        let teamMode = false;
        let teamCode = '';
        let teamDocRef = null;
        let teamUnsubscribe = null;
        let teamSlots = Array.from({ length: segmentCount }, () => '');
        let lastTeamSpinTrigger = '';
        let teamSnapshotInitialized = false;
        let customSegmentCount = DEFAULT_SEGMENT_COUNT;
        const startBtnDefaultLabel = startBtn ? startBtn.textContent.trim() : 'START';
        const resetBtnDefaultLabel = resetBtn ? resetBtn.textContent.trim() : 'RESET';

        const RACE_MIN_DURATION = 10000;
        const RACE_MAX_EXTRA_DURATION = 6000;
        const RACE_HORSE_LIMIT = 10;
        let allHorses = [
            { id: 'horse-01', name: '번개', icon: '⚡' },
            { id: 'horse-02', name: '질주', icon: '💨' },
            { id: 'horse-03', name: '새벽별', icon: '🌟' },
            { id: 'horse-04', name: '커피콩', icon: '☕' },
            { id: 'horse-05', name: '모래바람', icon: '🌬️' },
            { id: 'horse-06', name: '달빛', icon: '🌙' },
            { id: 'horse-07', name: '토네이도', icon: '🌪️' },
            { id: 'horse-08', name: '파도', icon: '🌊' },
            { id: 'horse-09', name: '봄바람', icon: '🌸' },
            { id: 'horse-10', name: '폭죽', icon: '🎆' }
        ];
        let selectedHorseIds = new Set();
        let raceQueue = [];
        let horseWinRecord = {};
        let raceParticipantCount = 5;
        let raceState = createEmptyRaceState();
        let raceStatsLoaded = false;

        const Mode = {
            LOCATION: 'location',
            TEAM: 'team',
            CUSTOM: 'custom',
            RACE: 'race'
        };

        const modeMeta = {
            [Mode.LOCATION]: {
                badge: '📍 위치기반 모드',
                description: '현재 위치를 기반으로 주변 식당 후보를 자동으로 채워 드립니다.'
            },
            [Mode.TEAM]: {
                badge: '🤝 팀플레이 모드',
                description: '엑세스 코드를 공유해 팀원과 함께 룰렛을 채우고 동시에 돌려보세요.'
            },
            [Mode.CUSTOM]: {
                badge: '🎨 커스텀 모드',
                description: '나만의 후보를 직접 구성하고 저장하거나 자랑해 보세요.'
            },
            [Mode.RACE]: {
                badge: '🏇 커피 내기 경마',
                description: '말을 선택하고 최소 10초 이상 펼쳐지는 레이스로 커피 내기 우승자를 결정하세요.'
            }
        };

        let currentMode = null;

        function clampSegmentCount(value) {
            const numeric = Number(value);
            if (!Number.isFinite(numeric)) {
                return DEFAULT_SEGMENT_COUNT;
            }
            return Math.max(MIN_SEGMENT_COUNT, Math.min(MAX_SEGMENT_COUNT, Math.round(numeric)));
        }

        function syncTeamSlotCountInput(value) {
            if (teamSlotCountInput) {
                teamSlotCountInput.value = value;
            }
        }

        function syncCustomSlotCountDisplay(value) {
            if (customSlotCountDisplay) {
                customSlotCountDisplay.textContent = `${value}칸`;
            }
        }

        function renderCustomInputs(existingValues = []) {
            if (!customChartInputs) return;
            customChartInputs.innerHTML = '';
            for (let i = 0; i < customSegmentCount; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'custom-input border rounded px-2 py-1 text-sm';
                input.placeholder = `항목 ${i + 1}`;
                input.value = existingValues[i] || '';
                customChartInputs.appendChild(input);
            }
        }

        syncCustomSlotCountDisplay(customSegmentCount);
        renderCustomInputs();
        syncTeamSlotCountInput(segmentCount);

        // --- 초기화 ---
        window.onload = () => {
            const size = Math.min(window.innerWidth * 0.9, 450);
            canvas.width = size;
            canvas.height = size;
            drawWheel();
            initializeRaceModule();
            initializeFirebase();
        };

        function attemptAutoDiscovery() {
            if (currentMode !== Mode.LOCATION) return;
            statusMessage.textContent = '주변 맛집을 모으는 중이에요...';
            candidateListsWrapper.innerHTML = '<p class="text-sm text-gray-400 text-center">주변 후보를 불러오는 중이에요...</p>';
            handleReset({ silent: true });
        }

        // --- 경마 모드 헬퍼 ---
        function createEmptyRaceState() {
            return {
                status: 'idle',
                startTimestamp: null,
                racers: [],
                results: [],
                animationId: null,
                progressElements: new Map(),
                speedLabels: new Map(),
                durationMap: new Map()
            };
        }

        function initializeRaceModule() {
            if (!racePanel) return;
            selectedHorseIds = new Set(allHorses.slice(0, raceParticipantCount).map(horse => horse.id));
            loadHorseWinRecordFromStorage();
            renderHorseWinSummary();
            renderRaceHorseList();
            updateRaceSelectionUI();
            updateRaceTrackParticipants();
        }

        function loadHorseWinRecordFromStorage() {
            try {
                const raw = localStorage.getItem('lunch-race-wins');
                if (raw) {
                    const parsed = JSON.parse(raw);
                    if (parsed && typeof parsed === 'object') {
                        horseWinRecord = { ...horseWinRecord, ...parsed };
                    }
                }
            } catch (error) {
                console.warn('경마 기록 로드 실패:', error);
            }
            allHorses.forEach(horse => {
                if (typeof horseWinRecord[horse.id] !== 'number' || Number.isNaN(horseWinRecord[horse.id])) {
                    horseWinRecord[horse.id] = 0;
                }
            });
        }

        async function loadHorseWinRecordFromRemote() {
            if (!db || raceStatsLoaded) return;
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const statsSnapshot = await getDocs(collection(db, 'artifacts', appId, 'raceStats'));
                statsSnapshot.forEach(docSnap => {
                    const data = docSnap.data() || {};
                    const wins = typeof data.wins === 'number' && !Number.isNaN(data.wins) ? data.wins : 0;
                    horseWinRecord[docSnap.id] = wins;
                    const horseMeta = allHorses.find(horse => horse.id === docSnap.id);
                    if (horseMeta && typeof data.name === 'string' && data.name.trim() !== '') {
                        horseMeta.name = data.name;
                    }
                });
                raceStatsLoaded = true;
                renderHorseWinSummary();
                renderRaceHorseList();
                updateRaceSelectionUI();
            } catch (error) {
                console.error('경마 승수 불러오기 실패:', error);
            }
        }

        function renderHorseWinSummary() {
            if (!raceSummaryNodes || raceSummaryNodes.length === 0) return;
            const summary = allHorses.map(horse => ({
                ...horse,
                wins: horseWinRecord[horse.id] || 0
            })).sort((a, b) => {
                if (b.wins === a.wins) {
                    return a.name.localeCompare(b.name, 'ko');
                }
                return b.wins - a.wins;
            });

            raceSummaryNodes.forEach(node => {
                if (!node) return;
                const hasWinner = summary.some(item => item.wins > 0);
                if (!hasWinner) {
                    node.innerHTML = '<div class="p-4 bg-white border border-slate-200 rounded-2xl shadow-sm text-sm text-slate-500">아직 경마 기록이 없습니다.</div>';
                    return;
                }
                const topThree = summary.slice(0, 3);
                node.innerHTML = `
                    <div class="space-y-2">
                        ${topThree.map((horse, index) => `
                            <div class="flex items-center justify-between bg-white border border-slate-200 rounded-2xl px-3 py-2 shadow-sm">
                                <div class="flex items-center gap-2">
                                    <span class="text-sm font-bold text-amber-600">${index + 1}</span>
                                    <span class="text-sm font-semibold text-slate-700">${horse.icon || '🐎'} ${safeText(horse.name)}</span>
                                </div>
                                <span class="text-xs font-semibold text-slate-500">${horse.wins} 승</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            });
        }

        function renderRaceHorseList() {
            if (!raceHorseList) return;
            raceHorseList.innerHTML = '';
            allHorses.forEach(horse => {
                const label = document.createElement('label');
                label.className = 'flex items-center gap-3 bg-white border border-slate-200 rounded-xl px-3 py-2 shadow-sm';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'accent-amber-500';
                checkbox.value = horse.id;
                checkbox.checked = selectedHorseIds.has(horse.id);
                checkbox.addEventListener('change', () => handleRaceHorseToggle(horse.id, checkbox.checked));

                const infoWrap = document.createElement('div');
                infoWrap.className = 'flex-1 flex items-center justify-between gap-2';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'text-sm font-semibold text-slate-700';
                nameSpan.textContent = `${horse.icon || '🐎'} ${horse.name}`;

                const winBadge = document.createElement('span');
                winBadge.className = 'text-xs font-semibold text-amber-600 bg-amber-100 px-2 py-0.5 rounded-full';
                winBadge.textContent = `${horseWinRecord[horse.id] || 0} 승`;

                infoWrap.appendChild(nameSpan);
                infoWrap.appendChild(winBadge);

                label.appendChild(checkbox);
                label.appendChild(infoWrap);

                raceHorseList.appendChild(label);
            });
        }

        function setRaceStatus(message) {
            if (raceStatusLabel) {
                raceStatusLabel.textContent = message;
            }
        }

        function updateRaceParticipantInputs() {
            const selectedCount = selectedHorseIds.size;
            const maxParticipants = Math.max(2, Math.min(RACE_HORSE_LIMIT, selectedCount || RACE_HORSE_LIMIT));
            raceParticipantCount = Math.min(raceParticipantCount, maxParticipants);
            const currentValue = Math.max(2, Math.min(raceParticipantCount, maxParticipants));
            if (raceHorseCountInput) {
                raceHorseCountInput.max = maxParticipants;
                raceHorseCountInput.value = currentValue;
            }
            if (raceHorseCountRange) {
                raceHorseCountRange.max = maxParticipants;
                raceHorseCountRange.value = currentValue;
            }
            raceParticipantCount = currentValue;
        }

        function updateRaceSelectionUI() {
            if (!racePanel) return;
            const selectedCount = selectedHorseIds.size;
            if (raceSelectedCounter) {
                raceSelectedCounter.textContent = `${selectedCount} / ${RACE_HORSE_LIMIT}`;
            }
            updateRaceParticipantInputs();
            if (raceState.status === 'idle') {
                if (selectedCount < 2) {
                    setRaceStatus('말을 두 마리 이상 선택해 주세요.');
                } else if (selectedCount < raceParticipantCount) {
                    setRaceStatus('출전 말 수보다 적게 선택했어요. 체크박스를 더 선택해 주세요.');
                } else {
                    setRaceStatus('모든 준비가 끝났어요! START를 눌러 레이스를 시작하세요.');
                }
            }
            updateRaceTrackParticipants();
            updateStartButtonState();
        }

        function handleRaceHorseToggle(horseId, checked) {
            if (checked) {
                selectedHorseIds.add(horseId);
            } else {
                selectedHorseIds.delete(horseId);
            }
            updateRaceSelectionUI();
            updateStartButtonState();
        }

        function setRaceParticipantCount(count) {
            const parsed = Math.max(2, Math.min(RACE_HORSE_LIMIT, Number(count) || 0));
            raceParticipantCount = parsed;
            updateRaceParticipantInputs();
            updateRaceTrackParticipants();
            updateStartButtonState();
            if (raceState.status === 'idle' && selectedHorseIds.size >= raceParticipantCount) {
                setRaceStatus('모든 준비가 끝났어요! START를 눌러 레이스를 시작하세요.');
            }
        }

        function updateRaceTrackParticipants() {
            if (!raceTrack) return;
            raceState.progressElements = new Map();
            raceState.speedLabels = new Map();
            const selected = Array.from(selectedHorseIds);
            const participants = selected.slice(0, Math.min(raceParticipantCount, selected.length));
            if (participants.length < 2) {
                raceTrack.innerHTML = '<p class="text-sm text-slate-500">말을 두 마리 이상 선택하면 트랙이 준비됩니다.</p>';
                return;
            }
            raceTrack.innerHTML = '';
            participants.forEach((horseId, index) => {
                const horse = allHorses.find(item => item.id === horseId) || { id: horseId, name: horseId, icon: '🐎' };
                const lane = document.createElement('div');
                lane.className = 'space-y-1';

                const header = document.createElement('div');
                header.className = 'flex items-center justify-between text-sm font-semibold text-slate-700';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = `${horse.icon || '🐎'} ${horse.name}`;

                const speedSpan = document.createElement('span');
                speedSpan.className = 'text-xs text-slate-400';
                speedSpan.textContent = '0%';

                header.appendChild(nameSpan);
                header.appendChild(speedSpan);

                const trackOuter = document.createElement('div');
                trackOuter.className = 'race-track';

                const trackInner = document.createElement('div');
                trackInner.className = 'race-track-inner';

                const progressFill = document.createElement('div');
                progressFill.className = 'race-track-fill';
                progressFill.style.width = '0%';

                trackInner.appendChild(progressFill);
                trackOuter.appendChild(trackInner);

                const horseIcon = document.createElement('div');
                horseIcon.className = 'race-track-icon';
                horseIcon.textContent = horse.icon || '🐎';
                horseIcon.style.left = '0%';

                trackOuter.appendChild(horseIcon);

                lane.appendChild(header);
                lane.appendChild(trackOuter);
                raceTrack.appendChild(lane);

                raceState.progressElements.set(horseId, {
                    fill: progressFill,
                    icon: horseIcon
                });
                raceState.speedLabels.set(horseId, speedSpan);
            });
        }

        function setRaceInputsDisabled(disabled) {
            if (raceHorseCountInput) raceHorseCountInput.disabled = disabled;
            if (raceHorseCountRange) raceHorseCountRange.disabled = disabled;
            if (raceHorseList) {
                raceHorseList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.disabled = disabled;
                });
            }
            if (disabled) {
                raceControlsContainer?.classList.add('pointer-events-none', 'opacity-60');
            } else {
                raceControlsContainer?.classList.remove('pointer-events-none', 'opacity-60');
            }
        }

        function mountRaceControls() {
            if (!raceControlsSlot) return;
            if (startBtnWrapper && !raceControlsSlot.contains(startBtnWrapper)) {
                raceControlsSlot.appendChild(startBtnWrapper);
            }
            if (resetBtnWrapper && !raceControlsSlot.contains(resetBtnWrapper)) {
                raceControlsSlot.appendChild(resetBtnWrapper);
            }
            if (startBtn) startBtn.textContent = startBtnDefaultLabel;
            if (resetBtn) resetBtn.textContent = 'RESET';
        }

        function unmountRaceControls() {
            if (startDefaultSlot && startBtnWrapper && !startDefaultSlot.contains(startBtnWrapper)) {
                startDefaultSlot.appendChild(startBtnWrapper);
            }
            if (resetDefaultSlot && resetBtnWrapper && !resetDefaultSlot.contains(resetBtnWrapper)) {
                resetDefaultSlot.appendChild(resetBtnWrapper);
            }
            if (startBtn) startBtn.textContent = startBtnDefaultLabel;
            if (resetBtn) resetBtn.textContent = resetBtnDefaultLabel;
        }

        function initRaceMode() {
            mountRaceControls();
            stopRaceAnimation();
            raceQueue = [];
            raceState = createEmptyRaceState();
            raceParticipantCount = Math.min(5, RACE_HORSE_LIMIT);
            selectedHorseIds = new Set(allHorses.slice(0, raceParticipantCount).map(horse => horse.id));
            renderRaceHorseList();
            updateRaceSelectionUI();
            setRaceInputsDisabled(false);
            raceTimer.textContent = '00:00';
            raceResults.classList.add('hidden');
            raceAgainBtn.classList.add('hidden');
            setRaceStatus('출전할 말을 선택해 주세요.');
            updateStartButtonState();
        }

        function resetRaceMode(options = {}) {
            const { keepSelection = false } = options;
            stopRaceAnimation();
            raceState = createEmptyRaceState();
            raceResults.classList.add('hidden');
            raceAgainBtn.classList.add('hidden');
            raceTimer.textContent = '00:00';
            if (!keepSelection) {
                raceParticipantCount = Math.min(5, RACE_HORSE_LIMIT);
                selectedHorseIds = new Set(allHorses.slice(0, raceParticipantCount).map(horse => horse.id));
                renderRaceHorseList();
            }
            updateRaceSelectionUI();
            setRaceInputsDisabled(false);
            if (keepSelection && selectedHorseIds.size >= Math.max(2, raceParticipantCount)) {
                setRaceStatus('같은 구성으로 다시 달릴 준비가 되었어요. START를 눌러주세요!');
            } else {
                setRaceStatus('출전할 말을 선택해 주세요.');
            }
            updateStartButtonState();
        }

        function stopRaceAnimation() {
            if (raceState && raceState.animationId) {
                cancelAnimationFrame(raceState.animationId);
            }
            raceState.animationId = null;
        }

        function teardownRaceMode() {
            stopRaceAnimation();
            setRaceInputsDisabled(false);
            raceState = createEmptyRaceState();
            raceResults?.classList.add('hidden');
            raceAgainBtn?.classList.add('hidden');
            raceTimer.textContent = '00:00';
            unmountRaceControls();
        }

        function formatRaceTime(ms) {
            const totalMs = Math.max(0, Math.floor(ms));
            const seconds = Math.floor(totalMs / 1000);
            const centi = Math.floor((totalMs % 1000) / 10);
            return `${String(seconds).padStart(2, '0')}:${String(centi).padStart(2, '0')}`;
        }

        function buildRaceParticipants() {
            const selected = Array.from(selectedHorseIds);
            const participants = selected.slice(0, Math.min(raceParticipantCount, selected.length));
            return participants.map((horseId, index) => {
                const horse = allHorses.find(item => item.id === horseId) || { id: horseId, name: horseId, icon: '🐎' };
                return {
                    horse,
                    progress: 0,
                    duration: RACE_MIN_DURATION + Math.random() * RACE_MAX_EXTRA_DURATION,
                    randomPhase: Math.random() * Math.PI * 2,
                    finishTime: null
                };
            });
        }

        function handleRaceStart() {
            if (raceState.status === 'running') return;
            const participants = buildRaceParticipants();
            if (participants.length < 2) {
                setRaceStatus('말을 두 마리 이상 선택해 주세요.');
                updateStartButtonState();
                return;
            }
            if (participants.length < raceParticipantCount) {
                setRaceStatus('출전 말 수보다 적게 선택했어요. 체크박스를 더 선택해 주세요.');
                updateStartButtonState();
                return;
            }

            const trackElements = raceState.progressElements;
            const speedElements = raceState.speedLabels;
            const nextState = createEmptyRaceState();
            nextState.progressElements = trackElements;
            nextState.speedLabels = speedElements;
            raceState = nextState;
            raceState.racers = participants;
            raceState.durationMap = new Map(participants.map(item => [item.horse.id, item.duration]));
            raceState.results = [];
            raceState.status = 'running';
            raceState.startTimestamp = performance.now();
            setRaceInputsDisabled(true);
            raceResults.classList.add('hidden');
            raceAgainBtn.classList.add('hidden');
            setRaceStatus('레이스가 진행 중입니다! ☕');
            updateStartButtonState();
            raceState.animationId = requestAnimationFrame(updateRaceFrame);
        }

        function updateRaceFrame(timestamp) {
            if (raceState.status !== 'running') return;
            if (typeof raceState.startTimestamp !== 'number') {
                raceState.startTimestamp = timestamp;
            }
            const elapsed = timestamp - raceState.startTimestamp;
            raceTimer.textContent = formatRaceTime(elapsed);

            raceState.racers.forEach(racer => {
                if (racer.finishTime) return;
                const baseProgress = Math.min(1, elapsed / racer.duration);
                const sway = Math.sin((elapsed / 200) + racer.randomPhase) * 0.02;
                const drift = (Math.random() - 0.5) * 0.01;
                let nextProgress = Math.min(1, Math.max(racer.progress, baseProgress + sway + drift));
                if (elapsed < RACE_MIN_DURATION) {
                    nextProgress = Math.min(nextProgress, 0.99);
                }
                racer.progress = nextProgress;
                const trackElements = raceState.progressElements.get(racer.horse.id);
                const progressValue = `${(nextProgress * 100).toFixed(1)}%`;
                if (trackElements?.fill) {
                    trackElements.fill.style.width = progressValue;
                }
                if (trackElements?.icon) {
                    trackElements.icon.style.left = progressValue;
                }
                const speedLabel = raceState.speedLabels.get(racer.horse.id);
                if (speedLabel) {
                    speedLabel.textContent = `${Math.round(nextProgress * 100)}%`;
                }
                if (elapsed >= RACE_MIN_DURATION && nextProgress >= 1 && !racer.finishTime) {
                    racer.finishTime = timestamp;
                    raceState.results.push({
                        horse: racer.horse,
                        finishTime: timestamp,
                        duration: timestamp - raceState.startTimestamp
                    });
                }
            });

            if (raceState.results.length === raceState.racers.length) {
                finalizeRace(timestamp);
                return;
            }

            raceState.animationId = requestAnimationFrame(updateRaceFrame);
        }

        function finalizeRace(timestamp) {
            stopRaceAnimation();
            raceState.status = 'finished';
            const finalElapsed = timestamp - raceState.startTimestamp;
            raceTimer.textContent = formatRaceTime(finalElapsed);
            setRaceInputsDisabled(false);
            raceAgainBtn.classList.remove('hidden');

            raceResultsList.innerHTML = '';
            raceState.results.sort((a, b) => a.duration - b.duration);
            raceState.results.forEach((result, index) => {
                const li = document.createElement('li');
                li.className = 'flex items-center justify-between bg-slate-800/60 rounded-lg px-3 py-2';
                li.innerHTML = `<span class="font-semibold">#${index + 1} ${result.horse.icon || '🐎'} ${safeText(result.horse.name)}</span><span class="text-xs text-slate-300">${formatRaceTime(result.duration)}</span>`;
                raceResultsList.appendChild(li);
            });
            raceResults.classList.remove('hidden');

            if (raceState.results.length > 0) {
                const winner = raceState.results[0].horse;
                horseWinRecord[winner.id] = (horseWinRecord[winner.id] || 0) + 1;
                raceQueue.unshift({
                    timestamp: Date.now(),
                    results: raceState.results.map((entry, index) => ({
                        rank: index + 1,
                        horseId: entry.horse.id,
                        name: entry.horse.name,
                        duration: entry.duration
                    }))
                });
                if (raceQueue.length > 10) {
                    raceQueue = raceQueue.slice(0, 10);
                }
                persistHorseWinRecord(winner);
            }

            renderHorseWinSummary();
            renderRaceHorseList();
            setRaceStatus('레이스가 종료되었습니다! 다시 달리기를 누르면 같은 구성으로 재도전할 수 있어요.');
            updateStartButtonState();
        }

        function persistHorseWinRecord(winnerHorse) {
            try {
                localStorage.setItem('lunch-race-wins', JSON.stringify(horseWinRecord));
            } catch (error) {
                console.warn('경마 기록 저장 실패:', error);
            }
            if (!db) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const docRef = doc(db, 'artifacts', appId, 'raceStats', winnerHorse.id);
            setDoc(docRef, {
                name: winnerHorse.name,
                wins: horseWinRecord[winnerHorse.id] || 0,
                updatedAt: serverTimestamp()
            }, { merge: true }).catch(error => console.error('경마 승수 저장 실패:', error));
        }

        function updateModeButtons(activeMode) {
            modeButtons.forEach(button => {
                const target = button.dataset.modeTarget;
                const isActive = target === activeMode;
                button.classList.toggle('mode-button-active', isActive);
            });
        }

        function updateModeScopedElements(activeMode) {
            modeScopedElements.forEach(element => {
                const availableModes = (element.dataset.modeVisible || '')
                    .split(',')
                    .map(mode => mode.trim())
                    .filter(Boolean);
                const shouldShow = availableModes.includes(activeMode);
                element.classList.toggle('mode-hidden', !shouldShow);
            });
        }

        function setMode(mode) {
            if (!modeMeta[mode]) return;
            const previousMode = currentMode;
            const isSameMode = previousMode === mode;
            currentMode = mode;

            if (previousMode === Mode.RACE && mode !== Mode.RACE) {
                teardownRaceMode();
            }

            landingScreen.classList.add('hidden');
            appShell.classList.remove('hidden');

            updateModeButtons(mode);
            updateModeScopedElements(mode);

            const meta = modeMeta[mode];
            activeModeBadge.textContent = meta.badge;
            modeDescription.textContent = meta.description;

            if (mode === Mode.CUSTOM) {
                segmentCount = customSegmentCount;
                if (customSlotCountInput) {
                    customSlotCountInput.value = customSegmentCount;
                }
                syncCustomSlotCountDisplay(customSegmentCount);
                drawWheel();
            } else if (mode === Mode.LOCATION || mode === Mode.RACE || (mode === Mode.TEAM && !teamMode)) {
                segmentCount = DEFAULT_SEGMENT_COUNT;
                drawWheel();
            }

            if (!teamMode || mode !== Mode.TEAM) {
                syncTeamSlotCountInput(segmentCount);
            }

            if (isSameMode) {
                if (mode === Mode.LOCATION) {
                    attemptAutoDiscovery();
                }
                if (mode === Mode.RACE) {
                    updateRaceSelectionUI();
                }
                return;
            }

            if (mode === Mode.LOCATION) {
                if (teamMode) {
                    leaveTeamMode({ silent: true });
                }
                attemptAutoDiscovery();
            } else if (mode === Mode.TEAM) {
                if (!teamMode) {
                    resetState(true);
                    statusMessage.textContent = '엑세스 코드를 입력하면 팀이 생성되거나 입장됩니다.';
                }
            } else if (mode === Mode.CUSTOM) {
                if (teamMode) {
                    leaveTeamMode({ silent: true });
                }
                if (previousMode !== Mode.CUSTOM) {
                    resetState(true);
                    if (!restaurants.length) {
                        statusMessage.textContent = '나만의 룰렛을 만들어 보세요.';
                    }
                }
            } else if (mode === Mode.RACE) {
                if (teamMode) {
                    leaveTeamMode({ silent: true });
                }
                initRaceMode();
            }

            if (mode !== Mode.LOCATION) {
                locationFallback.classList.add('hidden');
            }

            updateStartButtonState();
        }

        function returnToLanding() {
            if (teamMode) {
                leaveTeamMode({ silent: true });
            } else {
                resetState(true);
            }

            if (currentMode === Mode.RACE) {
                teardownRaceMode();
            }

            currentMode = null;
            landingScreen.classList.remove('hidden');
            appShell.classList.add('hidden');
            modeButtons.forEach(button => button.classList.remove('mode-button-active'));
            modeScopedElements.forEach(element => element.classList.add('mode-hidden'));
            statusMessage.textContent = '모드를 선택해 주세요.';
            modeDescription.textContent = '네 가지 방식으로 점심 고민을 단번에 해결해 보세요.';
            activeModeBadge.textContent = '모드를 선택해 주세요';
            locationFallback.classList.add('hidden');
        }  
        
        const textEscapes = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
        function safeText(text = '') {
            return String(text).replace(/[&<>"']/g, char => textEscapes[char] || char);
        }

        function updateStartButtonState() {
            if (currentMode === Mode.RACE) {
                const selectedCount = selectedHorseIds.size;
                const participantsNeeded = Math.max(2, raceParticipantCount);
                const ready = selectedCount >= participantsNeeded;
                startBtn.disabled = raceState.status === 'running' || !ready;
                resetBtn.disabled = raceState.status === 'running';
                return;
            }
            if (teamMode) {
                const allFilled = teamSlots.every(slot => typeof slot === 'string' && slot.trim() !== '');
                startBtn.disabled = isSpinning || !allFilled;
                resetBtn.disabled = isSpinning;
            } else {
                startBtn.disabled = isSpinning || restaurants.length < segmentCount;
                resetBtn.disabled = isSpinning;
            }
        }

        function sanitizeAccessCode(raw = '') {
            return raw.replace(/[^a-zA-Z0-9]/g, '').toUpperCase().slice(0, 12);
        }

        async function initializeFirebase() {
            try {
                const firebaseConfig = {
                  apiKey: "AIzaSyCULXkDYqAfCtpN7PmQktYachfyB7P8dqk",
                  authDomain: "lunch-78f47.firebaseapp.com",
                  projectId: "lunch-78f47",
                  storageBucket: "lunch-78f47.appspot.com",
                  messagingSenderId: "612330931668",
                  appId: "1:612330931668:web:07ab3d8ac7bba96f5ac241"
                };

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        loadSavedRoulettes();
                        loadSharedRoulettes();
                        resetBtn.disabled = false;
                        loadHorseWinRecordFromRemote();
                    } else {
                        signInAnonymously(auth).catch(error => console.error("Anonymous sign-in failed:", error));
                    }
                });
            } catch (error) {
                console.error("Firebase 초기화 실패:", error);
                statusMessage.textContent = "앱 초기화에 실패했습니다.";
            }
        }

        function updateTeamUIState() {
            if (teamMode) {
                teamJoinBtn.classList.add('hidden');
                teamLeaveBtn.classList.remove('hidden');
                teamSlotsContainer.classList.remove('hidden');
                teamAccessInput.value = teamCode;
                syncTeamSlotCountInput(segmentCount);
            } else {
                teamJoinBtn.classList.remove('hidden');
                teamLeaveBtn.classList.add('hidden');
                teamSlotsContainer.classList.add('hidden');
                teamAccessInput.value = '';
                teamStatus.textContent = '엑세스 코드를 입력하면 팀이 생성되거나 입장됩니다.';
                segmentCount = currentMode === Mode.CUSTOM ? customSegmentCount : DEFAULT_SEGMENT_COUNT;
                syncTeamSlotCountInput(segmentCount);
                drawWheel();
                updateStartButtonState();
            }
            if (teamSlotCountInput) {
                const disabled = !teamMode;
                teamSlotCountInput.disabled = disabled;
                teamSlotCountInput.classList.toggle('opacity-60', disabled);
                teamSlotCountInput.classList.toggle('cursor-not-allowed', disabled);
            }
        }

        function createTeamEntry(index, text) {
            const raw = typeof text === 'string' ? text : '';
            const display = raw.trim() === '' ? `칸 ${index + 1}` : raw;
            return {
                id: `team-${index}`,
                place_name: display,
                rawText: raw,
                place_url: '#',
                address_name: '',
                road_address_name: '',
                phone: '',
                distance: 0,
                isTeamEntry: true
            };
        }

        function updateTeamSlotsUI(slots = []) {
            if (!teamMode) return;
            teamSlotsContainer.innerHTML = '';
            slots.forEach((slot, index) => {
                const row = document.createElement('div');
                row.className = 'flex items-center gap-2';

                const label = document.createElement('span');
                label.className = 'w-6 text-xs font-semibold text-slate-500 text-right';
                label.textContent = `${index + 1}.`;

                const input = document.createElement('input');
                input.className = 'team-slot-input border rounded px-2 py-1 text-sm flex-1';
                input.value = slot || '';
                input.setAttribute('data-index', index);

                const button = document.createElement('button');
                button.className = 'team-slot-save bg-indigo-500 hover:bg-indigo-600 text-white text-xs font-semibold px-3 py-1 rounded-md flex-shrink-0';
                button.textContent = '저장';

                button.addEventListener('click', () => saveTeamSlot(index, input.value));
                input.addEventListener('keyup', (event) => {
                    if (event.key === 'Enter') {
                        saveTeamSlot(index, input.value);
                    }
                });

                row.appendChild(label);
                row.appendChild(input);
                row.appendChild(button);
                teamSlotsContainer.appendChild(row);
            });
        }

        function applyTeamSlotsToRestaurants(slots = [], count = segmentCount) {
            if (!teamMode) return;
            const normalizedCount = clampSegmentCount(count);
            segmentCount = normalizedCount;
            const normalizedSlots = Array.from({ length: normalizedCount }, (_, idx) => (slots[idx] || ''));
            teamSlots = normalizedSlots;
            restaurants = teamSlots.map((slot, index) => createTeamEntry(index, slot));
            candidateListsWrapper.innerHTML = '';
            saveContainer.classList.add('hidden');
            drawWheel();
            updateTeamSlotsUI(teamSlots);

            const filledCount = teamSlots.filter(slot => slot.trim() !== '').length;
            syncTeamSlotCountInput(normalizedCount);
            if (filledCount === normalizedCount) {
                teamStatus.textContent = '모든 칸이 채워졌어요! 이제 START 버튼으로 함께 돌려보세요.';
                if (winnerIndex === -1 && !isSpinning) {
                    statusMessage.textContent = '팀 룰렛이 준비되었습니다! START 버튼을 누르면 모두가 동시에 볼 수 있어요.';
                }
            } else {
                teamStatus.textContent = `${filledCount}/${normalizedCount}칸 채워졌어요. 모두 채우면 START 버튼이 활성화됩니다.`;
                if (winnerIndex === -1 && !isSpinning) {
                    statusMessage.textContent = '팀 룰렛을 채우는 중이에요. 팀원들과 함께 각 칸을 작성해 주세요.';
                }
            }
            updateStartButtonState();
        }

        async function saveTeamSlot(index, value) {
            if (!teamMode || !teamDocRef) return;
            const trimmed = (value || '').trim();
            try {
                const snap = await getDoc(teamDocRef);
                const data = snap.exists() ? snap.data() : {};
                const slots = Array.from({ length: segmentCount }, (_, idx) => {
                    if (Array.isArray(data.slots)) {
                        return data.slots[idx] || '';
                    }
                    return '';
                });

                if (index >= slots.length) return;
                slots[index] = trimmed;

                await setDoc(
                    teamDocRef,
                    {
                        slots,
                        updatedAt: serverTimestamp(),
                        lastUpdatedBy: userId || null
                    },
                    { merge: true }
                );
            } catch (error) {
                console.error('팀 슬롯 업데이트 실패:', error);
                statusMessage.textContent = '슬롯을 저장하지 못했습니다. 잠시 후 다시 시도해 주세요.';
            }
        }

        function handleTeamSlotCountChange() {
            if (!teamSlotCountInput) return;
            const desiredCount = clampSegmentCount(teamSlotCountInput.value);
            syncTeamSlotCountInput(desiredCount);
            if (!teamMode || !teamDocRef) {
                segmentCount = desiredCount;
                drawWheel();
                updateStartButtonState();
                return;
            }
            updateTeamSegmentCount(desiredCount);
        }

        async function updateTeamSegmentCount(newCount) {
            if (!teamMode || !teamDocRef) return;
            const clamped = clampSegmentCount(newCount);
            const previousCount = segmentCount;
            const previousSlots = [...teamSlots];
            const normalizedSlots = Array.from({ length: clamped }, (_, idx) => teamSlots[idx] || '');
            applyTeamSlotsToRestaurants(normalizedSlots, clamped);

            let wasDisabled = false;
            if (teamSlotCountInput) {
                wasDisabled = teamSlotCountInput.disabled;
                teamSlotCountInput.disabled = true;
                teamSlotCountInput.classList.add('opacity-60');
                teamSlotCountInput.classList.add('cursor-not-allowed');
            }

            try {
                await setDoc(teamDocRef, {
                    segmentCount: clamped,
                    slots: normalizedSlots,
                    updatedAt: serverTimestamp(),
                    lastUpdatedBy: userId || null
                }, { merge: true });
            } catch (error) {
                console.error('팀 칸 수 변경 실패:', error);
                statusMessage.textContent = '팀 칸 수를 변경하지 못했습니다. 잠시 후 다시 시도해 주세요.';
                applyTeamSlotsToRestaurants(previousSlots, previousCount);
                syncTeamSlotCountInput(previousCount);
            } finally {
                if (teamSlotCountInput) {
                    const disabled = !teamMode || wasDisabled;
                    teamSlotCountInput.disabled = disabled;
                    teamSlotCountInput.classList.toggle('opacity-60', disabled);
                    teamSlotCountInput.classList.toggle('cursor-not-allowed', disabled);
                }
            }
        }

        async function clearTeamSlots() {
            if (!teamMode || !teamDocRef) return;
            try {
                await setDoc(teamDocRef, {
                    slots: Array.from({ length: segmentCount }, () => ''),
                    segmentCount
                }, { merge: true });
                winnerIndex = -1;
                canvas.classList.remove('blinking');
                drawWheel();
                statusMessage.textContent = '팀 룰렛을 초기화했습니다. 다시 내용을 채워주세요.';
            } catch (error) {
                console.error('팀 룰렛 초기화 실패:', error);
                statusMessage.textContent = '팀 룰렛 초기화에 실패했습니다.';
            }
        }

        async function joinTeamRoom() {
            if (!db) {
                statusMessage.textContent = '앱이 준비되는 중입니다. 잠시 후 다시 시도해 주세요.';
                return;
            }
            const sanitized = sanitizeAccessCode(teamAccessInput.value.trim());
            if (!sanitized) {
                teamStatus.textContent = '영문과 숫자로 이루어진 엑세스 코드를 입력해 주세요.';
                teamAccessInput.focus();
                return;
            }
            if (teamMode && sanitized === teamCode) {
                teamStatus.textContent = `이미 '${teamCode}' 팀에 참여 중입니다.`;
                return;
            }

            teamJoinBtn.disabled = true;
            teamJoinBtn.classList.add('opacity-60', 'cursor-not-allowed');
            try {
                await enterTeamMode(sanitized);
            } catch (error) {
                console.error('팀플레이 입장 실패:', error);
                statusMessage.textContent = '팀에 참여하지 못했습니다. 잠시 후 다시 시도해 주세요.';
            } finally {
                teamJoinBtn.disabled = false;
                teamJoinBtn.classList.remove('opacity-60', 'cursor-not-allowed');
            }
        }

        async function enterTeamMode(code) {
            if (!db) return;
            if (teamUnsubscribe) {
                teamUnsubscribe();
                teamUnsubscribe = null;
            }

            resetState(true);
            canvas.classList.remove('blinking');
            winnerIndex = -1;
            segmentCount = DEFAULT_SEGMENT_COUNT;
            syncTeamSlotCountInput(segmentCount);
            drawWheel();
            updateStartButtonState();
            
            teamMode = true;
            teamCode = code;
            teamAccessInput.value = code;
            updateTeamUIState();

            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

            try {
                const appDocRef = doc(db, "artifacts", appId);
                await setDoc(appDocRef, {
                    initializedAt: serverTimestamp()
                }, { merge: true });
            } catch (error) {
                console.error('팀 베이스 문서 준비 실패:', error);
                throw error;
            }

            teamDocRef = doc(db, "artifacts", appId, "team-rooms", code);

            try {
                const docSnap = await getDoc(teamDocRef);
                if (!docSnap.exists()) {
                    await setDoc(teamDocRef, {
                        slots: Array.from({ length: DEFAULT_SEGMENT_COUNT }, () => ''),
                        segmentCount: DEFAULT_SEGMENT_COUNT,
                        createdAt: serverTimestamp()
                    });
                }
            } catch (error) {
                console.error('팀 문서 준비 실패:', error);
                teamMode = false;
                teamDocRef = null;
                updateTeamUIState();
                throw error;
            }

            lastTeamSpinTrigger = '';
            teamSnapshotInitialized = false;
            teamUnsubscribe = onSnapshot(teamDocRef, handleTeamSnapshot);
            statusMessage.textContent = `팀 룰렛 '${code}'에 참여했어요. 각 칸을 채워주세요.`;
        }

        function handleTeamSnapshot(docSnap) {
            if (!docSnap.exists()) return;
            const data = docSnap.data() || {};
            const slots = Array.isArray(data.slots) ? data.slots : [];
            const sanitizedCount = clampSegmentCount(
                typeof data.segmentCount === 'undefined' ? DEFAULT_SEGMENT_COUNT : data.segmentCount
            );
            const normalizedSlots = Array.from({ length: sanitizedCount }, (_, idx) => slots[idx] || '');
            const rawNumber = Number(data.segmentCount);
            const requiresPatch = !Number.isFinite(rawNumber)
                || rawNumber < MIN_SEGMENT_COUNT
                || rawNumber > MAX_SEGMENT_COUNT
                || !Number.isInteger(rawNumber);

            if (requiresPatch && teamDocRef) {
                setDoc(teamDocRef, {
                    segmentCount: sanitizedCount,
                    slots: normalizedSlots
                }, { merge: true }).catch(error => console.error('팀 칸 수 보정 실패:', error));
            }

            applyTeamSlotsToRestaurants(normalizedSlots, sanitizedCount);

            if (data.spin && data.spin.triggerId) {
                if (!teamSnapshotInitialized) {
                    lastTeamSpinTrigger = data.spin.triggerId;
                } else if (data.spin.triggerId !== lastTeamSpinTrigger) {
                    lastTeamSpinTrigger = data.spin.triggerId;
                    triggerTeamSpinFromSnapshot(data.spin);
                }
            }
            teamSnapshotInitialized = true;
        }

        function triggerTeamSpinFromSnapshot(spinState = {}) {
            const rotation = Number(spinState.totalRotation) || 0;
            const targetIndex = typeof spinState.winnerIndex === 'number'
                ? spinState.winnerIndex
                : calculateWinnerIndex(rotation);
            animateSpin(rotation, targetIndex, { triggeredByTeam: true });
        }

        function leaveTeamMode(options = {}) {
            const { silent = false } = options;
            if (teamUnsubscribe) {
                teamUnsubscribe();
                teamUnsubscribe = null;
            }
            teamMode = false;
            teamCode = '';
            teamDocRef = null;
            segmentCount = currentMode === Mode.CUSTOM ? customSegmentCount : DEFAULT_SEGMENT_COUNT;
            teamSlots = Array.from({ length: segmentCount }, () => '');
            lastTeamSpinTrigger = '';
            teamSnapshotInitialized = false;
            winnerIndex = -1;
            canvas.classList.remove('blinking');
            syncTeamSlotCountInput(segmentCount);
            updateTeamUIState();
            resetState(true);
            if (!silent) {
                statusMessage.textContent = '팀에서 나왔어요. 새로운 엑세스 코드를 입력해 보세요.';
            }
            updateStartButtonState();
        }

        // --- 이벤트 리스너 ---
        modeButtons.forEach(button => {
            button.addEventListener('click', () => setMode(button.dataset.modeTarget));
        });
        homeBtn.addEventListener('click', returnToLanding);
        resetBtn.addEventListener('click', () => handleReset());
        startBtn.addEventListener('click', handleStart);
        saveBtn.addEventListener('click', handleSave);
        searchSharedInput.addEventListener('input', renderSharedRoulettes);
        applyCustomBtn.addEventListener('click', handleApplyCustomChart);
        raceHorseCountInput?.addEventListener('input', () => setRaceParticipantCount(raceHorseCountInput.value));
        raceHorseCountRange?.addEventListener('input', () => setRaceParticipantCount(raceHorseCountRange.value));
        raceAgainBtn?.addEventListener('click', () => resetRaceMode({ keepSelection: true }));
        teamJoinBtn.addEventListener('click', joinTeamRoom);
        teamLeaveBtn.addEventListener('click', () => leaveTeamMode());
        teamSlotCountInput?.addEventListener('change', handleTeamSlotCountChange);
        teamAccessInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter') {
                joinTeamRoom();
            }
        });
        customSlotCountInput?.addEventListener('input', handleCustomSlotCountChange);
        applyManualLocationBtn.addEventListener('click', () => {
            if (teamMode) {
                statusMessage.textContent = '팀플레이 모드에서는 주변 식당 불러오기를 사용할 수 없어요.';
                return;
            }
            if (currentMode !== Mode.LOCATION) {
                statusMessage.textContent = '위치기반 모드에서만 사용할 수 있는 기능이에요.';
                return;
            }
            const value = manualLocationSelect.value;
            if (!value) {
                statusMessage.textContent = '동네를 선택해 주세요.';
                return;
            }
            const [lat, lng] = value.split(',').map(Number);
            locationFallback.classList.add('hidden');
            fetchRestaurants(lat, lng, 'manual');
        });
        winnerRerollBtn.addEventListener('click', () => {
            if (!startBtn.disabled) {
                handleStart();
            }
        });

        document.querySelectorAll('.sample-template-btn').forEach(btn => {
            btn.addEventListener('click', () => applyTemplate(btn.dataset.template));
        });
        
        // --- 렌더링 함수 ---
        function drawWheel() {
            const radius = canvas.width / 2;
            const segmentAngle = (2 * Math.PI) / segmentCount;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(radius, radius);

            for (let i = 0; i < segmentCount; i++) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const startAngle = segmentAngle * i - segmentAngle / 2;
                const endAngle = segmentAngle * (i + 1) - segmentAngle / 2;
                ctx.arc(0, 0, radius - 5, startAngle, endAngle);
                ctx.closePath();
                
                if (winnerIndex === i && canvas.classList.contains('blinking')) {
                     ctx.fillStyle = i % 2 === 0 ? '#fca5a5' : '#f87171';
                } else {
                    ctx.fillStyle = colors[i % colors.length];
                }
                ctx.fill();
                
                ctx.save();
                ctx.rotate(startAngle + segmentAngle / 2);
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#1f2937';
                ctx.font = `bold ${radius * 0.08}px 'Noto Sans KR'`;
                
                const text = restaurants[i] ? restaurants[i].place_name : (restaurants.length > 0 ? '?' : '준비 중');
                const textRadius = radius * 0.9;
                
                let displayText = text;
                if (ctx.measureText(text).width > radius * 0.7) {
                    displayText = text.substring(0, 7) + '...';
                }

                ctx.fillText(displayText, textRadius, 0);
                ctx.restore();
            }
            ctx.restore();
        }

        // --- 상태 관리 함수 ---
        function handleReset(options = {}) {
            if (currentMode === Mode.RACE) {
                resetRaceMode();
                return;
            }
            if (isSpinning) return;
            if (teamMode) {
                resetBtn.disabled = true;
                clearTeamSlots().finally(() => updateStartButtonState());
                return;
            }
            if (currentMode !== Mode.LOCATION) {
                statusMessage.textContent = '위치기반 모드에서만 다시 불러올 수 있어요.';
                return;
            }
            const { silent = false } = options;
            resetState(silent);
            if (!silent) {
                statusMessage.textContent = '주변 식당을 다시 찾고 있어요...';
            }
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(onGeoSuccess, onGeoError, { enableHighAccuracy: false, timeout: 8000 });
            } else {
                statusMessage.textContent = '위치 정보를 사용할 수 없습니다. 동네를 직접 선택해 주세요.';
                resetBtn.disabled = false;
                locationFallback.classList.remove('hidden');
            }
        }

        function resetState(keepStatus = false) {
            isSpinning = false;
            startBtn.disabled = true;
            resetBtn.disabled = true;
            saveContainer.classList.add('hidden');
            candidateListsWrapper.innerHTML = '';
            restaurants = [];
            winnerIndex = -1;
            canvas.style.transition = 'none';
            canvas.style.transform = `rotate(0deg)`;
            canvas.classList.remove('blinking');
            if (blinkAnimationId) cancelAnimationFrame(blinkAnimationId);
            drawWheel();
            winnerCard.classList.add('hidden');
            if (!keepStatus) {
                statusMessage.textContent = '주변 맛집을 모으는 중이에요...';
            }
            updateStartButtonState();
        }

        function calculateWinnerIndex(totalRotation) {
            const normalized = ((totalRotation % 360) + 360) % 360;
            const segmentAngle = 360 / segmentCount;
            const winningAngle = (270 - normalized + 360) % 360;
            return Math.round(winningAngle / segmentAngle) % segmentCount;
        }

        function animateSpin(totalRotation, forcedIndex = null) {
            isSpinning = true;
            saveContainer.classList.add('hidden');
            canvas.classList.remove('blinking');
            if (blinkAnimationId) cancelAnimationFrame(blinkAnimationId);
            winnerCard.classList.add('hidden');
            updateStartButtonState();

            canvas.style.transition = 'transform 5s cubic-bezier(0.1, 0.7, 0.3, 1)';
            canvas.style.transform = `rotate(${totalRotation}deg)`;

            setTimeout(() => {
                isSpinning = false;
                const targetIndex = typeof forcedIndex === 'number' ? forcedIndex : calculateWinnerIndex(totalRotation);
                winnerIndex = targetIndex;
                const winner = restaurants[winnerIndex];
                updateStartButtonState();

                if (!winner || (winner.isTeamEntry && (winner.rawText || '').trim() === '')) {
                    statusMessage.textContent = '아직 비어 있는 칸에 멈췄어요. 내용을 채워볼까요?';
                    winnerCard.classList.add('hidden');
                    startBlinking();
                    return;
                }

                if (!teamMode && winner.id === 'reroll') {
                    statusMessage.innerHTML = `아쉽네요! <span class="font-bold text-red-600">다시 한 번!</span>`;
                    winnerCard.classList.add('hidden');
                    startBlinking();
                    return;
                }

                if (teamMode && winner.isTeamEntry) {
                    const displayName = safeText((winner.rawText || winner.place_name));
                    statusMessage.innerHTML = `팀 룰렛 결과는 <span class="font-bold text-emerald-600">${displayName}</span>!`;
                } else {
                    statusMessage.innerHTML = `오늘의 식사는 <a href="${winner.place_url || '#'}" target="_blank" class="font-bold text-blue-600 underline">${safeText(winner.place_name)}</a>!`;
                }

                populateWinnerCard(winner);
                winnerCard.classList.remove('hidden');         
                startBlinking();
            }, 5000);
        }

        async function handleStart() {
            if (currentMode === Mode.RACE) {
                handleRaceStart();
                return;
            }
            if (isSpinning) return;

            if (teamMode) {
                if (!teamDocRef) {
                    statusMessage.textContent = '팀 정보가 아직 준비되지 않았습니다. 잠시 후 다시 시도해 주세요.';
                    return;
                }
                const allFilled = teamSlots.every(slot => slot.trim() !== '');
                if (!allFilled) {
                    statusMessage.textContent = '모든 칸을 채워야 룰렛을 돌릴 수 있어요!';
                    return;
                }
                if (blinkAnimationId) cancelAnimationFrame(blinkAnimationId);
                canvas.classList.remove('blinking');
                winnerCard.classList.add('hidden');
                isSpinning = true;
                updateStartButtonState();
                const randomSpins = Math.floor(Math.random() * 5) + 5;
                const randomStopAngle = Math.random() * 360;
                const totalRotation = randomSpins * 360 + randomStopAngle;
                const winnerIdx = calculateWinnerIndex(totalRotation);
                const spinPayload = {
                    triggerId: `${userId || 'guest'}-${Date.now()}`,
                    totalRotation,
                    winnerIndex: winnerIdx,
                    initiatedAt: Date.now(),
                    initiator: userId || null
                };
                const previousTrigger = lastTeamSpinTrigger;
                lastTeamSpinTrigger = spinPayload.triggerId;
                try {
                    await updateDoc(teamDocRef, { spin: spinPayload });
                    animateSpin(totalRotation, winnerIdx);
                } catch (error) {
                    console.error('팀 룰렛 회전 정보 업데이트 실패:', error);
                    statusMessage.textContent = '룰렛을 돌리지 못했어요. 다시 시도해 주세요.';
                    isSpinning = false;
                    lastTeamSpinTrigger = previousTrigger;
                    updateStartButtonState();
                }
                return;
            }

            if (restaurants.length < segmentCount) return;

            const randomSpins = Math.floor(Math.random() * 5) + 5;
            const randomStopAngle = Math.random() * 360;
            const totalRotation = randomSpins * 360 + randomStopAngle;
            const winnerIdx = calculateWinnerIndex(totalRotation);
            animateSpin(totalRotation, winnerIdx);
        }   
        
        function startBlinking() {
            let lastTime = 0;
            let show = true;
            function blink(currentTime) {
                if (isSpinning) return;
                if (currentTime - lastTime > 500) {
                    lastTime = currentTime;
                    show = !show;
                    canvas.classList.toggle('blinking', show);
                    drawWheel();
                }
                blinkAnimationId = requestAnimationFrame(blink);
            }
            blinkAnimationId = requestAnimationFrame(blink);
        }

        // --- 데이터 처리 함수 ---
        function onGeoSuccess(position) {
            lastKnownCoords = { lat: position.coords.latitude, lng: position.coords.longitude };
            statusMessage.textContent = '주변 식당 정보를 가져오는 중...';
            locationFallback.classList.add('hidden');
            fetchRestaurants(lastKnownCoords.lat, lastKnownCoords.lng, 'geo');
        }

        function onGeoError(error) {
            console.error(error);
            statusMessage.textContent = '위치 정보를 확인할 수 없어요. 아래에서 동네를 직접 선택해 주세요.';
            resetBtn.disabled = false;
            locationFallback.classList.remove('hidden');
        }

        function fetchRestaurants(lat, lng, source = 'geo') {
            const places = new kakao.maps.services.Places();
            places.categorySearch('FD6', (result, status) => {
                if (status === kakao.maps.services.Status.OK) {
                    processRestaurantData(result, '', source);
                } else if (status === kakao.maps.services.Status.ZERO_RESULT) {
                    processRestaurantData([]);
                }
                else {
                    statusMessage.textContent = '주변 식당 정보를 가져오는데 실패했습니다.';
                    resetBtn.disabled = false;
                }
            }, { location: new kakao.maps.LatLng(lat, lng), radius: 1000, size: 15 });
        }

        function processRestaurantData(data, titlePrefix = '', source = 'geo') {
            if (teamMode) return;
            const mode = modeSelect.value;
            let placesForRoulette = [];
            let listHtml = '';
            
            const createListItem = (place) => {
                if (place.id === 'reroll') {
                    return `<li class="text-gray-500">- 다시 한 번</li>`;
                }
                const distanceMeters = Number(place.distance || 0);
                const distanceText = distanceMeters > 0 ? `${Math.round(distanceMeters / 10) * 10}m` : '거리 정보 없음';
                const category = place.category_name ? place.category_name.split('>').pop().trim() : '';
                const linkContent = place.place_url && place.place_url !== '#'
                    ? `<a href="${place.place_url}" target="_blank" class="hover:underline hover:text-blue-600">${safeText(place.place_name)}</a>`
                    : safeText(place.place_name);

                return `<li class="bg-slate-50 rounded-md px-3 py-2 shadow-sm" title="${safeText(place.place_name)}">
                            <div class="flex items-center justify-between text-sm font-semibold text-gray-700">
                                <span class="truncate">${linkContent}</span>
                                <span class="text-xs text-gray-500">${safeText(category)}</span>
                            </div>
                            <div class="mt-1 text-xs text-gray-500">${distanceText} · ${safeText(place.road_address_name || place.address_name || '')}</div>
                        </li>`;
            };

            if (titlePrefix) {
                placesForRoulette = data;
                listHtml = `<div>
                                <h3 class="text-lg font-semibold text-indigo-700 mb-2 border-b-2 border-indigo-200 pb-1">${safeText(titlePrefix)}</h3>
                                <ul class="space-y-2 text-gray-700">${placesForRoulette.map(p => createListItem(p)).join('')}</ul>
                            </div>`;
            } else {
                switch (mode) {
                    case 'distance': {
                        const distanceSorted = [...data].sort((a, b) => Number(a.distance || Infinity) - Number(b.distance || Infinity));
                        placesForRoulette = distanceSorted;
                        listHtml = `<div>
                                        <h3 class="text-lg font-semibold text-blue-700 mb-2 border-b-2 border-blue-200 pb-1">🚶‍♂️ 가까운 순 추천</h3>
                                        <ul class="space-y-2 text-gray-700">${placesForRoulette.map(p => createListItem(p)).join('')}</ul>
                                    </div>`;
                        break;
                    }
                    case 'random': {
                        const randomPlaces = [...data].sort(() => 0.5 - Math.random());
                        placesForRoulette = randomPlaces;
                        listHtml = `<div>
                                        <h3 class="text-lg font-semibold text-orange-700 mb-2 border-b-2 border-orange-200 pb-1">🎲 랜덤 추천</h3>
                                        <ul class="space-y-2 text-gray-700">${placesForRoulette.map(p => createListItem(p)).join('')}</ul>
                                    </div>`;
                        break;
                    }
                    default: {
                        const distanceSorted = [...data].sort((a, b) => Number(a.distance || Infinity) - Number(b.distance || Infinity));
                        const close = distanceSorted.slice(0, 3);
                        const remainingAfterClose = data.filter(place => !close.find(c => c.id === place.id));
                        const varietyMap = new Map();
                        const variety = [];
                        for (const place of remainingAfterClose) {
                            const category = (place.category_name || '').split('>').pop()?.trim() || '기타';
                            if (!varietyMap.has(category)) {
                                variety.push(place);
                                varietyMap.set(category, true);
                            }
                            if (variety.length >= 3) break;
                        }
                        const leftovers = data.filter(place => !close.includes(place) && !variety.includes(place));
                        const randomPick = [];
                        while (randomPick.length < 3 && leftovers.length > 0) {
                            const randomIndex = Math.floor(Math.random() * leftovers.length);
                            randomPick.push(leftovers.splice(randomIndex, 1)[0]);
                        }
                        placesForRoulette = [...close, ...variety, ...randomPick];
                        listHtml = `<div class="space-y-4">
                                        <div>
                                            <h3 class="text-lg font-semibold text-emerald-700 mb-2 border-b-2 border-emerald-200 pb-1">🍱 가까우면서 인기 있는 조합</h3>
                                            <ul class="space-y-2 text-gray-700">${close.map(p => createListItem(p)).join('')}</ul>
                                        </div>
                                        <div>
                                            <h3 class="text-lg font-semibold text-teal-700 mb-2 border-b-2 border-teal-200 pb-1">🍲 다양한 메뉴</h3>
                                            <ul class="space-y-2 text-gray-700">${variety.map(p => createListItem(p)).join('')}</ul>
                                        </div>
                                        <div>
                                            <h3 class="text-lg font-semibold text-orange-700 mb-2 border-b-2 border-orange-200 pb-1">🎲 깜짝 선택</h3>
                                            <ul class="space-y-2 text-gray-700">${randomPick.map(p => createListItem(p)).join('')}</ul>
                                        </div>
                                    </div>`;
                    }
                }
            }
            
            const rerollOption = { place_name: '다시 한 번', id: 'reroll', place_url: '#' };
            while (placesForRoulette.length < segmentCount) {
                placesForRoulette.push(rerollOption);
            }

            restaurants = placesForRoulette.slice(0, segmentCount);
            statusMessage.textContent = source === 'manual' ? '선택한 동네의 후보가 준비되었어요! START를 눌러주세요.' : '룰렛이 준비되었습니다! START 버튼을 누르세요.';
            updateStartButtonState();
            saveContainer.classList.remove('hidden');
            rouletteNameInput.value = '';
            drawWheel();
            candidateListsWrapper.innerHTML = listHtml;
            locationFallback.classList.add('hidden');
        }

        function handleCustomSlotCountChange() {
            if (!customSlotCountInput) return;
            const desiredCount = clampSegmentCount(customSlotCountInput.value);
            customSegmentCount = desiredCount;
            customSlotCountInput.value = desiredCount;
            syncCustomSlotCountDisplay(desiredCount);
            const existingValues = Array.from(document.querySelectorAll('.custom-input')).map(input => input.value);
            renderCustomInputs(existingValues);
            if (teamMode) return;
            segmentCount = desiredCount;
            restaurants = [];
            winnerIndex = -1;
            canvas.classList.remove('blinking');
            drawWheel();
            updateStartButtonState();
            winnerCard.classList.add('hidden');
            if (currentMode === Mode.CUSTOM) {
                statusMessage.textContent = '칸 수가 변경되었습니다. 새로운 구성을 적용해 보세요.';
            }
        }

        function handleApplyCustomChart() {
            if (teamMode) {
                statusMessage.textContent = '팀플레이 모드에서는 직접 만든 룰렛을 적용할 수 없어요. 먼저 팀에서 나가주세요.';
                return;
            }
            const inputs = document.querySelectorAll('.custom-input');
            const customNames = Array.from(inputs).map(input => input.value.trim()).filter(name => name !== '');

            if (customNames.length === 0) {
                statusMessage.textContent = "식당 이름을 하나 이상 입력해주세요.";
                return;
            }

            const customRestaurants = customNames.map((name, index) => ({
                place_name: safeText(name),
                id: `custom_${Date.now()}_${index}`,
                place_url: '#'
            }));
            
            resetState();
            processRestaurantData(customRestaurants, '직접 만든 룰렛');
            statusMessage.textContent = '직접 만든 룰렛을 적용했습니다!';
            updateStartButtonState();
        }

        function applyTemplate(type) {
            const templates = {
                korean: ['된장찌개', '김치찌개', '불고기 백반', '냉면', '제육볶음', '칼국수', '돈까스', '곰탕', '비빔밥'],
                noodle: ['짜장면', '짬뽕', '우동', '파스타', '라멘', '막국수', '쌀국수', '칼국수', '소바'],
                office: ['샐러드', '샌드위치', '포케', '김밥', '덮밥', '컵밥', '라이스버거', '파스타', '타코'],
                snack: ['떡볶이', '순대', '튀김 모둠', '김밥', '어묵', '라볶이', '찐만두', '핫도그', '튀김우동']
            };
            const selected = templates[type] || [];
            const inputs = document.querySelectorAll('.custom-input');
            inputs.forEach((input, index) => {
                input.value = selected[index] || '';
            });
        }

        // --- Firebase Firestore 함수 ---
        async function handleSave() {
            if (saveBtn.dataset.loading === 'true') return;
            saveBtn.dataset.loading = 'true';
            saveBtn.disabled = true;
            saveBtn.classList.add('opacity-60', 'cursor-not-allowed');
            const finishSave = () => {
                saveBtn.disabled = false;
                saveBtn.classList.remove('opacity-60', 'cursor-not-allowed');
                delete saveBtn.dataset.loading;
            };
            if (teamMode) {
                statusMessage.textContent = '팀플레이 룰렛은 저장할 수 없습니다.';
                finishSave();
                return;
            }
            const name = rouletteNameInput.value.trim();
            if (!name) {
                statusMessage.textContent = "룰렛 이름을 입력해주세요.";
                finishSave();
                return;
            }
            if (restaurants.some(r => r.id === 'reroll')) {
                statusMessage.textContent = "'다시 한 번'이 포함된 룰렛은 저장할 수 없습니다.";
                finishSave();
                return;
            }

            // 직접 만든 룰렛 저장 시에는 지역명 자동 추가 기능 비활성화
            if (restaurants.every(r => r.id.startsWith('custom'))) {
                try {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    await addDoc(collection(db, "artifacts", appId, "users", userId, "roulettes"), {
                        name: name, // 사용자가 입력한 이름 그대로 저장
                        restaurants: restaurants,
                        createdAt: serverTimestamp()
                    });
                    statusMessage.textContent = `'${name}' 룰렛이 저장되었습니다.`;
                    rouletteNameInput.value = '';
                    saveContainer.classList.add('hidden');
                } catch (error) {
                    console.error("룰렛 저장 실패:", error);
                    statusMessage.textContent = "룰렛 저장에 실패했습니다.";
                }
                finishSave();
                return;
            }

            // 위치 기반 룰렛 저장 (기존 로직)
            if (!userId || !lastKnownCoords) {
                statusMessage.textContent = "위치 정보가 필요합니다.";
                finishSave();
                return;
            }
            const geocoder = new kakao.maps.services.Geocoder();
            geocoder.coord2RegionCode(lastKnownCoords.lng, lastKnownCoords.lat, async (result, status) => {
                let regionName = "알수없음";
                if (status === kakao.maps.services.Status.OK) {
                    const region = result.find(r => r.region_type === 'H');
                    if(region) regionName = region.address_name.split(' ').pop();
                }
                
                const finalName = `[${regionName}] ${name}`;
                
                try {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    await addDoc(collection(db, "artifacts", appId, "users", userId, "roulettes"), {
                        name: finalName,
                        restaurants: restaurants,
                        createdAt: serverTimestamp()
                    });
                    statusMessage.textContent = `'${finalName}' 룰렛이 저장되었습니다.`;
                    rouletteNameInput.value = '';
                    saveContainer.classList.add('hidden');
                } catch (error) {
                    console.error("룰렛 저장 실패:", error);
                    statusMessage.textContent = "룰렛 저장에 실패했습니다.";
                }
                finishSave();
            });
        }

        function loadSavedRoulettes() {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const q = query(collection(db, "artifacts", appId, "users", userId, "roulettes"), orderBy("createdAt", "desc"));

            onSnapshot(q, (snapshot) => {
                savedRoulettesList.innerHTML = snapshot.empty ? '<p class="text-center text-gray-500">저장된 룰렛이 없습니다.</p>' : '';
                snapshot.forEach((doc) => {
                    const roulette = doc.data();
                    const div = document.createElement('div');
                    div.className = 'flex justify-between items-center p-2 border-b';
                    div.innerHTML = `
                        <span class="font-semibold truncate" title="${safeText(roulette.name)}">${safeText(roulette.name)}</span>
                        <div class="flex-shrink-0 space-x-1">
                            <button data-id="${doc.id}" class="load-btn bg-green-100 text-green-800 text-xs font-semibold px-2 py-1 rounded">불러오기</button>
                            <button data-id="${doc.id}" class="share-btn bg-yellow-100 text-yellow-800 text-xs font-semibold px-2 py-1 rounded">자랑하기</button>
                            <button data-id="${doc.id}" class="delete-btn bg-red-100 text-red-800 text-xs font-semibold px-2 py-1 rounded">삭제</button>
                        </div>
                    `;
                    savedRoulettesList.appendChild(div);
                });

                document.querySelectorAll('.load-btn').forEach(btn => btn.addEventListener('click', (e) => loadSpecificRoulette(e.target.dataset.id, 'private')));
                document.querySelectorAll('.share-btn').forEach(btn => btn.addEventListener('click', (e) => handleShare(e.target.dataset.id)));
                document.querySelectorAll('.delete-btn').forEach(btn => btn.addEventListener('click', (e) => deleteSpecificRoulette(e.target.dataset.id)));
            });
        }

        async function loadSpecificRoulette(docId, type) {
            if (!userId) return;
            if (teamMode) {
                statusMessage.textContent = '팀플레이 모드에서는 개인이나 공개 룰렛을 불러올 수 없어요. 먼저 팀에서 나가주세요.';
                return;
            }
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const collectionPath = type === 'private'
                    ? ["artifacts", appId, "users", userId, "roulettes"] 
                    : ["artifacts", appId, "public", "data", "shared-roulettes"];
                
                const docRef = doc(db, ...collectionPath, docId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const rouletteData = docSnap.data();
                    resetState();
                    const loadedRestaurants = Array.isArray(rouletteData.restaurants) ? rouletteData.restaurants : [];
                    const loadedCount = clampSegmentCount(loadedRestaurants.length || customSegmentCount);
                    customSegmentCount = loadedCount;
                    segmentCount = loadedCount;
                    if (customSlotCountInput) {
                        customSlotCountInput.value = loadedCount;
                    }
                    syncCustomSlotCountDisplay(loadedCount);
                    renderCustomInputs(loadedRestaurants.map(item => item.place_name || ''));
                    statusMessage.textContent = `'${rouletteData.name}' 룰렛을 적용했습니다.`;
                    processRestaurantData(loadedRestaurants, rouletteData.name);
                    drawWheel();
                    updateStartButtonState();
                }
            } catch (error) {
                console.error("룰렛 불러오기 실패:", error);
            }
        }
        
        async function deleteSpecificRoulette(docId) {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            await deleteDoc(doc(db, "artifacts", appId, "users", userId, "roulettes", docId));
        }

        async function handleShare(docId) {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const docRef = doc(db, "artifacts", appId, "users", userId, "roulettes", docId);
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                const rouletteToShare = docSnap.data();
                await addDoc(collection(db, "artifacts", appId, "public", "data", "shared-roulettes"), {
                    ...rouletteToShare,
                    sharedBy: userId,
                    sharedAt: serverTimestamp(),
                    likes: 0,
                    dislikes: 0,
                    voters: []
                });
                statusMessage.textContent = `'${rouletteToShare.name}' 룰렛을 자랑했습니다!`;
            }
        }

        function loadSharedRoulettes() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const q = query(collection(db, "artifacts", appId, "public", "data", "shared-roulettes"));
            
            onSnapshot(q, (snapshot) => {
                let roulettes = [];
                snapshot.forEach(doc => {
                    const shared = doc.data();
                    roulettes.push({ id: doc.id, ...shared });
                });

                roulettes.sort((a, b) => {
                    const likesDiff = (b.likes || 0) - (a.likes || 0);
                    if (likesDiff !== 0) return likesDiff;
                    const dateB = b.sharedAt?.toDate() || 0;
                    const dateA = a.sharedAt?.toDate() || 0;
                    return dateB - dateA;
                });

                allSharedRoulettes = roulettes;
                renderSharedRoulettes();
            });
        }

        function renderSharedRoulettes() {
            const searchTerm = searchSharedInput.value.toLowerCase();
            const filteredList = allSharedRoulettes.filter(shared => shared.name?.toLowerCase().includes(searchTerm));

            sharedRoulettesList.innerHTML = filteredList.length === 0 ? '<p class="text-center text-gray-500">일치하는 룰렛이 없어요.</p>' : '';
            
            filteredList.forEach(shared => {
                const div = document.createElement('div');
                div.className = 'p-3 mb-3 border border-slate-200 rounded-lg shadow-sm bg-white';
                const restaurants = Array.isArray(shared.restaurants) ? shared.restaurants : [];
                div.innerHTML = `
                    <p class="font-bold truncate" title="${safeText(shared.name)}">${safeText(shared.name)}</p>
                    <ul class="text-sm text-gray-600 mt-2 grid grid-cols-3 gap-2">
                        ${restaurants.slice(0,3).map(r => `<li class="truncate bg-slate-100 px-2 py-1 rounded text-xs">${safeText(r.place_name)}</li>`).join('')}
                        ${restaurants.length > 3 ? '<li class="text-gray-400 col-span-3 text-xs">... 등 다양한 식당이 있어요</li>' : ''}
                    </ul>
                    <div class="flex items-center justify-between mt-3">
                        <div class="flex items-center space-x-2">
                            <button data-id="${shared.id}" data-vote="like" class="vote-btn flex items-center bg-blue-50 px-3 py-1 rounded-full text-xs hover:bg-blue-100">👍 <span class="ml-1 font-semibold">${shared.likes || 0}</span></button>
                            <button data-id="${shared.id}" data-vote="dislike" class="vote-btn flex items-center bg-rose-50 px-3 py-1 rounded-full text-xs hover:bg-rose-100">👎 <span class="ml-1 font-semibold">${shared.dislikes || 0}</span></button>
                        </div>
                        <button data-id="${shared.id}" class="apply-btn bg-indigo-500 hover:bg-indigo-600 text-white text-sm font-bold py-1 px-3 rounded">적용하기</button>
                    </div>
                `;
                sharedRoulettesList.appendChild(div);
            });

            document.querySelectorAll('.apply-btn').forEach(btn => btn.addEventListener('click', (e) => loadSpecificRoulette(e.target.dataset.id, 'public')));
            document.querySelectorAll('.vote-btn').forEach(btn => btn.addEventListener('click', (e) => handleVote(e.currentTarget.dataset.id, e.currentTarget.dataset.vote)));
        }

        async function handleVote(docId, voteType) {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const docRef = doc(db, "artifacts", appId, "public", "data", "shared-roulettes", docId);
            
            const docSnap = await getDoc(docRef);
            if (!docSnap.exists()) return;

            const localVotesRaw = localStorage.getItem('lunch-votes') || '{}';
            const localVotes = JSON.parse(localVotesRaw);
            if (localVotes[docId]) {
                statusMessage.textContent = '이미 투표하셨습니다.';
                return;
            }

            const voters = docSnap.data().voters || [];
            if (voters.includes(userId)) {
                statusMessage.textContent = '이미 투표하셨습니다.';
                localVotes[docId] = true;
                localStorage.setItem('lunch-votes', JSON.stringify(localVotes));
                return;
            }

            const updateData = {
                voters: arrayUnion(userId)
            };
            if (voteType === 'like') {
                updateData.likes = increment(1);
            } else {
                updateData.dislikes = increment(1);
            }
            await updateDoc(docRef, updateData);
            localVotes[docId] = true;
            localStorage.setItem('lunch-votes', JSON.stringify(localVotes));
            statusMessage.textContent = voteType === 'like' ? '좋아요 감사합니다!' : '의견을 남겨주셔서 감사해요.';
        }

        function populateWinnerCard(winner) {
            const displayName = winner.isTeamEntry ? (winner.rawText || winner.place_name) : winner.place_name;
            winnerName.textContent = displayName;
            winnerCallBtn.classList.remove('hidden');
            winnerMapBtn.classList.remove('opacity-60', 'pointer-events-none');

            if (winner.isTeamEntry) {
                winnerAddress.innerHTML = `<span class="font-semibold text-gray-700">✍️</span> 팀에서 직접 적은 메뉴예요.`;
                winnerPhone.innerHTML = `<span class="font-semibold text-gray-700">📞</span> 연락처 정보가 없어요.`;
                winnerCallBtn.href = '#';
                winnerCallBtn.classList.add('hidden');
                winnerMapBtn.href = '#';
                winnerMapBtn.classList.add('opacity-60', 'pointer-events-none');
                winnerTip.innerHTML = `<span class="font-semibold text-gray-700">💡</span> 팀원들과 맛집 정보를 공유해보세요!`;
                winnerTag.textContent = '팀 추천';
                return;
            }

            winnerAddress.innerHTML = `<span class="font-semibold text-gray-700">📍</span> ${safeText(winner.road_address_name || winner.address_name || '주소 정보 없음')}`;
            const phone = winner.phone || '';
            if (phone) {
                winnerPhone.innerHTML = `<span class="font-semibold text-gray-700">📞</span> ${safeText(phone)}`;
                winnerCallBtn.href = `tel:${phone.replace(/[^0-9+]/g, '')}`;
            } else {
                winnerPhone.innerHTML = `<span class="font-semibold text-gray-700">📞</span> 전화 정보가 없어요.`;
                winnerCallBtn.href = '#';
                winnerCallBtn.classList.add('hidden');
            }
            if (winner.place_url) {
                winnerMapBtn.href = winner.place_url;
            } else {
                winnerMapBtn.href = '#';
                winnerMapBtn.classList.add('opacity-60', 'pointer-events-none');
            }
            winnerTip.innerHTML = `<span class="font-semibold text-gray-700">⏰</span> 영업시간 정보는 카카오 페이지에서 확인해주세요.`;
            winnerTag.textContent = modeSelect.value === 'random' ? '완전 랜덤!' : (modeSelect.value === 'distance' ? '가까운 행운' : '추천 픽');
        }
    </script>
</body>
</html>
