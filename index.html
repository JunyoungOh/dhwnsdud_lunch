<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>오늘 뭐 먹지? 룰렛 (DB 연동)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=9ddcc83d3b7ed7f48495e2de9a0a4460&libraries=services"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .roulette-container {
            position: relative;
            width: 90vw;
            height: 90vw;
            max-width: 450px;
            max-height: 450px;
        }
        canvas {
            width: 100%;
            height: 100%;
            transition: transform 5s cubic-bezier(0.25, 1, 0.5, 1);
        }
        .pointer {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 30px solid #ef4444; /* red-500 */
            z-index: 10;
        }
        .blinking {
            animation: blinker 1s linear infinite;
        }
        @keyframes blinker {
            50% {
                opacity: 0.3;
            }
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        .mode-button {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .mode-button:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 35px -15px rgba(30, 64, 175, 0.35);
        }
        .mode-button-active {
            background-color: #111827 !important;
            color: #f8fafc !important;
            box-shadow: 0 25px 50px -12px rgba(30, 64, 175, 0.45);
        }
        .mode-button-badge {
            font-size: 0.75rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #94a3b8;
            font-weight: 600;
        }
        .mode-button-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #0f172a;
        }
        .mode-button-subtitle {
            font-size: 0.95rem;
            color: #4b5563;
        }
        .mode-tab-label {
            font-weight: 600;
            color: #1f2937;
        }
        .mode-button-arrow {
            font-size: 1.75rem;
            color: #cbd5f5;
        }
        .mode-button-active .mode-button-badge,
        .mode-button-active .mode-button-title,
        .mode-button-active .mode-button-subtitle,
        .mode-button-active .mode-tab-label,
        .mode-button-active .mode-button-arrow {
            color: #f8fafc !important;
        }
        .mode-hidden {
            display: none !important;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="min-h-screen flex flex-col">
        <section id="landing-screen" class="flex-1 flex flex-col items-center justify-center px-4 py-12 text-center">
            <div class="max-w-2xl mx-auto space-y-10">
                <div class="space-y-3">
                    <h1 class="text-4xl sm:text-5xl font-bold text-gray-900">오늘 뭐 먹지?</h1>
                    <p class="text-gray-600 text-base sm:text-lg">세 가지 방식으로 점심 고민을 단번에 해결해 보세요.</p>
                </div>
                <div class="grid gap-4">
                    <button class="mode-button flex items-center justify-between w-full h-28 px-6 rounded-2xl border border-transparent bg-white text-left shadow-sm" data-mode-target="location">
                        <div class="space-y-2">
                            <span class="mode-button-badge">MODE 01</span>
                            <p class="mode-button-title">📍 위치기반 모드</p>
                            <p class="mode-button-subtitle">현재 위치 정보를 바탕으로 후보를 자동으로 채워요.</p>
                        </div>
                        <span class="mode-button-arrow">➜</span>
                    </button>
                    <button class="mode-button flex items-center justify-between w-full h-28 px-6 rounded-2xl border border-transparent bg-white text-left shadow-sm" data-mode-target="team">
                        <div class="space-y-2">
                            <span class="mode-button-badge">MODE 02</span>
                            <p class="mode-button-title">🤝 팀플레이 모드</p>
                            <p class="mode-button-subtitle">같은 엑세스 코드로 접속해 팀원과 함께 룰렛을 채워요.</p>
                        </div>
                        <span class="mode-button-arrow">➜</span>
                    </button>
                    <button class="mode-button flex items-center justify-between w-full h-28 px-6 rounded-2xl border border-transparent bg-white text-left shadow-sm" data-mode-target="custom">
                        <div class="space-y-2">
                            <span class="mode-button-badge">MODE 03</span>
                            <p class="mode-button-title">🎨 커스텀 모드</p>
                            <p class="mode-button-subtitle">나만의 룰렛을 직접 만들고 자랑해 보세요.</p>
                        </div>
                        <span class="mode-button-arrow">➜</span>
                    </button>
                </div>
            </div>
            
        </section>

        <section id="app-shell" class="hidden flex-1 px-4 py-10">
            <div class="w-full max-w-7xl mx-auto space-y-8">
                <div class="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
                    <div class="space-y-2">
                        <h2 class="text-3xl font-bold text-gray-900">모드를 바꿔가며 다양한 점심 아이디어를 만나보세요</h2>
                        <p id="mode-description" class="text-sm text-gray-500">현재 위치를 기반으로 주변 식당 후보를 자동으로 채워 드립니다.</p>
                    </div>
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 w-full sm:w-auto">
                        <button class="mode-button mode-tab flex items-center justify-center h-14 px-5 rounded-full border border-transparent bg-white shadow-sm" data-mode-target="location">
                            <span class="mode-tab-label">📍 위치기반</span>
                        </button>
                        <button class="mode-button mode-tab flex items-center justify-center h-14 px-5 rounded-full border border-transparent bg-white shadow-sm" data-mode-target="team">
                            <span class="mode-tab-label">🤝 팀플레이</span>
                        </button>
                        <button class="mode-button mode-tab flex items-center justify-center h-14 px-5 rounded-full border border-transparent bg-white shadow-sm" data-mode-target="custom">
                            <span class="mode-tab-label">🎨 커스텀</span>
                        </button>
                    </div>
                </div>
                <div class="flex flex-col xl:flex-row gap-6">
                    <aside class="w-full xl:w-72 space-y-6">
                        <div id="restaurant-list-container" data-mode-visible="location" class="bg-white p-5 rounded-2xl shadow-lg mode-hidden">
                            <div class="flex items-center justify-between mb-3">
                                <h3 class="text-xl font-bold text-gray-900">오늘의 후보</h3>
                                <span class="text-xs font-semibold text-amber-600 bg-amber-100 px-2 py-0.5 rounded-full">자동 추천</span>
                            </div>
                            <div id="candidate-lists-wrapper" class="space-y-4"></div>
                        </div>

                        <div id="team-card" data-mode-visible="team" class="bg-white rounded-2xl shadow-lg p-5 space-y-4 mode-hidden">
                            <div class="text-center space-y-1">
                                <h3 class="text-xl font-bold text-gray-900">🤝 팀플레이</h3>
                                <p class="text-xs text-gray-500">같은 엑세스 코드로 접속하면 하나의 룰렛을 함께 채울 수 있어요.</p>
                            </div>
                            <div class="flex flex-col sm:flex-row gap-2">
                                <input id="team-access-input" type="text" placeholder="엑세스 코드 (영문/숫자)" class="border rounded px-3 py-2 text-sm flex-1">
                                <button id="team-join-btn" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded-md">참여하기</button>
                                <button id="team-leave-btn" class="hidden bg-slate-500 hover:bg-slate-600 text-white font-bold py-2 px-4 rounded-md">나가기</button>
                            </div>
                            <p id="team-status" class="text-xs text-center text-slate-500">엑세스 코드를 입력하면 팀이 생성되거나 입장됩니다.</p>
                            <div id="team-slots-container" class="space-y-2 hidden"></div>
                        </div>
                    </aside>

                    <section class="flex-1 space-y-6">
                        <div class="bg-white rounded-2xl shadow-xl p-6 sm:p-8 space-y-6">
                            <div class="space-y-4 text-center">
                                <span id="active-mode-badge" class="inline-flex items-center justify-center gap-2 px-4 py-1 rounded-full bg-slate-100 text-sm font-semibold text-slate-600">📍 위치기반 모드</span>
                                <h3 class="text-3xl font-bold text-gray-900">오늘 뭐 먹지?</h3>
                                <p id="status-message" class="text-gray-600 min-h-[1.5rem]">모드를 선택해 주세요.</p>
                                <div id="location-fallback" data-mode-visible="location" class="hidden mode-hidden mt-2 flex flex-wrap items-center justify-center gap-2 text-sm">
                                    <span class="text-gray-500">위치 접근이 어렵다면?</span>
                                    <label class="flex items-center gap-2">
                                        <span class="text-gray-600">동네 선택</span>
                                        <select id="manual-location-select" class="border rounded px-2 py-1 text-sm">
                                            <option value="">동네를 골라주세요</option>
                                            <option value="37.4979,127.0276">서울 강남역</option>
                                            <option value="37.5575,126.9249">서울 홍대입구</option>
                                            <option value="37.4021,127.1089">경기 판교</option>
                                            <option value="35.1576,129.0591">부산 서면</option>
                                            <option value="35.8714,128.6014">대구 동성로</option>
                                            <option value="35.1796,129.0756">부산 남포동</option>
                                        </select>
                                    </label>
                                    <button id="apply-manual-location" class="bg-amber-500 hover:bg-amber-600 text-white font-semibold px-3 py-1 rounded-md">이 동네로 보기</button>
                                </div>
                            </div>

                            <div class="flex justify-center">
                                <div class="roulette-container">
                                    <div class="pointer"></div>
                                    <canvas id="rouletteCanvas"></canvas>
                                </div>
                            </div>

                            <div id="winner-card" class="hidden w-full max-w-xl mx-auto bg-slate-50 border border-slate-100 rounded-xl shadow-inner p-5 space-y-3">
                                <div class="flex items-start justify-between">
                                    <div>
                                        <p class="text-sm font-semibold text-green-600">오늘의 당첨!</p>
                                        <h4 id="winner-name" class="text-2xl font-bold text-gray-800"></h4>
                                    </div>
                                    <span id="winner-tag" class="text-xs bg-green-100 text-green-700 px-2 py-1 rounded-full">행운 가득</span>
                                </div>
                                <div class="space-y-2 text-sm text-gray-600">
                                    <p id="winner-address" class="flex items-center gap-2"></p>
                                    <p id="winner-phone" class="flex items-center gap-2"></p>
                                    <p id="winner-tip" class="flex items-center gap-2 text-xs text-gray-500"></p>
                                </div>
                                <div class="flex flex-wrap gap-2">
                                    <a id="winner-map-btn" class="flex-1 text-center bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 rounded-md" target="_blank" rel="noopener">길찾기</a>
                                    <a id="winner-call-btn" class="flex-1 text-center bg-emerald-500 hover:bg-emerald-600 text-white font-semibold py-2 rounded-md" target="_blank" rel="noopener">전화하기</a>
                                </div>
                                <button id="winner-reroll" class="w-full bg-gray-900 hover:bg-gray-700 text-white font-bold py-2 rounded-md">다시 돌리기</button>
                            </div>

                            <div class="space-y-4">
                                <div data-mode-visible="location" class="mode-hidden">
                                    <div class="bg-slate-50 border border-slate-200 rounded-xl p-4 space-y-4 text-left">
                                        <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                                            <label for="mode-select" class="font-semibold text-gray-700 flex items-center gap-2">
                                                룰렛 모드
                                                <span class="text-xs bg-slate-100 text-slate-500 px-2 py-0.5 rounded-full">평점/리뷰 기반 추천은 준비 중</span>
                                            </label>
                                            <select id="mode-select" class="rounded-md border-gray-300 shadow-sm">
                                                <option value="mix" selected>🍱 추천 믹스</option>
                                                <option value="distance">🚶‍♂️ 가까운 순 9곳</option>
                                                <option value="random">🎲 랜덤 9</option>
                                            </select>
                                        </div>
                                        <button id="resetBtn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 rounded-full shadow-lg">다시 불러오기</button>
                                    </div>
                                </div>

                                <div class="flex flex-wrap justify-center gap-3">
                                    <button id="startBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-10 rounded-full shadow-lg" disabled>START</button>
                                </div>

                                <div id="save-container" class="hidden">
                                    <div class="bg-slate-50 border border-slate-200 rounded-xl p-4">
                                        <div class="flex flex-col sm:flex-row sm:items-center sm:space-x-2 gap-2">
                                            <input type="text" id="roulette-name-input" placeholder="룰렛 이름 입력" class="border rounded px-3 py-2 flex-grow">
                                            <button id="saveBtn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-md">저장</button>
                                        </div>
                                        <p class="text-xs text-gray-500 mt-3 text-center">마음에 드는 룰렛이 나오면 소장해두고 계속 사용해보세요!</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <aside id="custom-panels" data-mode-visible="custom" class="w-full xl:w-96 space-y-6 mode-hidden">
                        <div class="bg-white rounded-2xl shadow-lg p-5">
                            <h3 class="text-xl font-bold text-center mb-2">나의 룰렛 목록</h3>
                            <div id="saved-roulettes-list" class="h-48 overflow-y-auto custom-scrollbar"></div>
                        </div>
                        <div class="bg-white rounded-2xl shadow-lg p-5 space-y-4">
                            <div class="text-center space-y-1">
                                <h3 class="text-xl font-bold text-gray-900">📝 직접 차트 만들기</h3>
                                <p class="text-xs text-gray-500">9칸을 모두 채우지 않아도 괜찮아요. 빈칸은 자동으로 ‘다시 한 번’으로 채워집니다.</p>
                            </div>
                            <div class="grid grid-cols-2 gap-2">
                                <button class="sample-template-btn bg-slate-200 hover:bg-slate-300 text-gray-700 text-sm font-semibold py-2 rounded" data-template="korean">한식 샘플</button>
                                <button class="sample-template-btn bg-slate-200 hover:bg-slate-300 text-gray-700 text-sm font-semibold py-2 rounded" data-template="noodle">면 요리 샘플</button>
                                <button class="sample-template-btn bg-slate-200 hover:bg-slate-300 text-gray-700 text-sm font-semibold py-2 rounded" data-template="office">직장인 빠른 점심</button>
                                <button class="sample-template-btn bg-slate-200 hover:bg-slate-300 text-gray-700 text-sm font-semibold py-2 rounded" data-template="snack">분식 인기 메뉴</button>
                            </div>
                            <div id="custom-chart-inputs" class="grid grid-cols-3 gap-2">
                                <input type="text" class="custom-input border rounded px-2 py-1 text-sm" placeholder="항목 1">
                                <input type="text" class="custom-input border rounded px-2 py-1 text-sm" placeholder="항목 2">
                                <input type="text" class="custom-input border rounded px-2 py-1 text-sm" placeholder="항목 3">
                                <input type="text" class="custom-input border rounded px-2 py-1 text-sm" placeholder="항목 4">
                                <input type="text" class="custom-input border rounded px-2 py-1 text-sm" placeholder="항목 5">
                                <input type="text" class="custom-input border rounded px-2 py-1 text-sm" placeholder="항목 6">
                                <input type="text" class="custom-input border rounded px-2 py-1 text-sm" placeholder="항목 7">
                                <input type="text" class="custom-input border rounded px-2 py-1 text-sm" placeholder="항목 8">
                                <input type="text" class="custom-input border rounded px-2 py-1 text-sm" placeholder="항목 9">
                            </div>
                            <button id="apply-custom-btn" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 rounded-md">적용하기</button>
                        </div>
                        <div class="bg-white rounded-2xl shadow-lg p-5 space-y-3">
                            <div class="text-center space-y-1">
                                <h3 class="text-xl font-bold text-gray-900">👑 룰렛 자랑하기</h3>
                                <p class="text-xs text-gray-500">좋아요가 많은 순서대로 보여드려요. 싫어요가 많은 글은 운영자가 확인 후 숨깁니다.</p>
                            </div>
                            <input type="search" id="search-shared" placeholder="예: (역삼) 족발" class="w-full p-2 border rounded-md">
                            <div id="shared-roulettes-list" class="h-[430px] overflow-y-auto custom-scrollbar"></div>
                        </div>
                    </aside>
                </div>
            </div>
        </section>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, doc, getDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, updateDoc, increment, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- UI 요소 ---
        const canvas = document.getElementById('rouletteCanvas');
        const ctx = canvas.getContext('2d');
        const resetBtn = document.getElementById('resetBtn');
        const startBtn = document.getElementById('startBtn');
        const saveBtn = document.getElementById('saveBtn');
        const statusMessage = document.getElementById('status-message');
        const saveContainer = document.getElementById('save-container');
        const rouletteNameInput = document.getElementById('roulette-name-input');
        const savedRoulettesList = document.getElementById('saved-roulettes-list');
        const restaurantListContainer = document.getElementById('restaurant-list-container');
        const candidateListsWrapper = document.getElementById('candidate-lists-wrapper');
        const modeSelect = document.getElementById('mode-select');
        const sharedRoulettesList = document.getElementById('shared-roulettes-list');
        const searchSharedInput = document.getElementById('search-shared');
        const applyCustomBtn = document.getElementById('apply-custom-btn');
        const locationFallback = document.getElementById('location-fallback');
        const manualLocationSelect = document.getElementById('manual-location-select');
        const applyManualLocationBtn = document.getElementById('apply-manual-location');
        const winnerCard = document.getElementById('winner-card');
        const winnerName = document.getElementById('winner-name');
        const winnerAddress = document.getElementById('winner-address');
        const winnerPhone = document.getElementById('winner-phone');
        const winnerTip = document.getElementById('winner-tip');
        const winnerMapBtn = document.getElementById('winner-map-btn');
        const winnerCallBtn = document.getElementById('winner-call-btn');
        const winnerRerollBtn = document.getElementById('winner-reroll');
        const winnerTag = document.getElementById('winner-tag');
        const teamAccessInput = document.getElementById('team-access-input');
        const teamJoinBtn = document.getElementById('team-join-btn');
        const teamLeaveBtn = document.getElementById('team-leave-btn');
        const teamStatus = document.getElementById('team-status');
        const teamSlotsContainer = document.getElementById('team-slots-container');
        const landingScreen = document.getElementById('landing-screen');
        const appShell = document.getElementById('app-shell');
        const activeModeBadge = document.getElementById('active-mode-badge');
        const modeDescription = document.getElementById('mode-description');
        const modeButtons = document.querySelectorAll('[data-mode-target]');
        const modeScopedElements = document.querySelectorAll('[data-mode-visible]');

        // --- 전역 변수 ---
        const SEGMENT_COUNT = 9;
        const colors = ['#fde68a', '#dcfce7', '#dbeafe', '#f3e8ff', '#fee2e2', '#fef3c7', '#e0f2fe', '#fce7f3', '#e5e7eb'];
        let restaurants = [];
        let isSpinning = false;
        let winnerIndex = -1;
        let blinkAnimationId;
        let db, auth, userId;
        let lastKnownCoords = null;
        let allSharedRoulettes = [];
        let teamMode = false;
        let teamCode = '';
        let teamDocRef = null;
        let teamUnsubscribe = null;
        let teamSlots = Array.from({ length: SEGMENT_COUNT }, () => '');
        let lastTeamSpinTrigger = '';
        let teamSnapshotInitialized = false;

        const Mode = {
            LOCATION: 'location',
            TEAM: 'team',
            CUSTOM: 'custom'
        };

        const modeMeta = {
            [Mode.LOCATION]: {
                badge: '📍 위치기반 모드',
                description: '현재 위치를 기반으로 주변 식당 후보를 자동으로 채워 드립니다.'
            },
            [Mode.TEAM]: {
                badge: '🤝 팀플레이 모드',
                description: '엑세스 코드를 공유해 팀원과 함께 룰렛을 채우고 동시에 돌려보세요.'
            },
            [Mode.CUSTOM]: {
                badge: '🎨 커스텀 모드',
                description: '나만의 후보를 직접 구성하고 저장하거나 자랑해 보세요.'
            }
        };

        let currentMode = null;

        // --- 초기화 ---
        window.onload = () => {
            const size = Math.min(window.innerWidth * 0.9, 450);
            canvas.width = size;
            canvas.height = size;
            drawWheel();
            initializeFirebase();
        };

        function attemptAutoDiscovery() {
            if (currentMode !== Mode.LOCATION) return;
            statusMessage.textContent = '주변 맛집을 모으는 중이에요...';
            candidateListsWrapper.innerHTML = '<p class="text-sm text-gray-400 text-center">주변 후보를 불러오는 중이에요...</p>';
            handleReset({ silent: true });
        }

        function updateModeButtons(activeMode) {
            modeButtons.forEach(button => {
                const target = button.dataset.modeTarget;
                const isActive = target === activeMode;
                button.classList.toggle('mode-button-active', isActive);
            });
        }

        function updateModeScopedElements(activeMode) {
            modeScopedElements.forEach(element => {
                const availableModes = (element.dataset.modeVisible || '')
                    .split(',')
                    .map(mode => mode.trim())
                    .filter(Boolean);
                const shouldShow = availableModes.includes(activeMode);
                element.classList.toggle('mode-hidden', !shouldShow);
            });
        }

        function setMode(mode) {
            if (!modeMeta[mode]) return;
            const previousMode = currentMode;
            const isSameMode = previousMode === mode;
            currentMode = mode;

            landingScreen.classList.add('hidden');
            appShell.classList.remove('hidden');

            updateModeButtons(mode);
            updateModeScopedElements(mode);

            const meta = modeMeta[mode];
            activeModeBadge.textContent = meta.badge;
            modeDescription.textContent = meta.description;

            if (isSameMode) {
                if (mode === Mode.LOCATION) {
                    attemptAutoDiscovery();
                }
                return;
            }

            if (mode === Mode.LOCATION) {
                if (teamMode) {
                    leaveTeamMode({ silent: true });
                }
                attemptAutoDiscovery();
            } else if (mode === Mode.TEAM) {
                if (!teamMode) {
                    resetState(true);
                    statusMessage.textContent = '엑세스 코드를 입력하면 팀이 생성되거나 입장됩니다.';
                }
            } else if (mode === Mode.CUSTOM) {
                if (teamMode) {
                    leaveTeamMode({ silent: true });
                }
                if (previousMode !== Mode.CUSTOM) {
                    resetState(true);
                    if (!restaurants.length) {
                        statusMessage.textContent = '나만의 룰렛을 만들어 보세요.';
                    }
                }
            }

            if (mode !== Mode.LOCATION) {
                locationFallback.classList.add('hidden');
            }

            updateStartButtonState();
        }
        
        const textEscapes = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
        function safeText(text = '') {
            return String(text).replace(/[&<>"']/g, char => textEscapes[char] || char);
        }

        function updateStartButtonState() {
            if (teamMode) {
                const allFilled = teamSlots.every(slot => typeof slot === 'string' && slot.trim() !== '');
                startBtn.disabled = isSpinning || !allFilled;
                resetBtn.disabled = isSpinning;
            } else {
                startBtn.disabled = isSpinning || restaurants.length < SEGMENT_COUNT;
                resetBtn.disabled = isSpinning;
            }
        }

        function sanitizeAccessCode(raw = '') {
            return raw.replace(/[^a-zA-Z0-9]/g, '').toUpperCase().slice(0, 12);
        }

        async function initializeFirebase() {
            try {
                const firebaseConfig = {
                  apiKey: "AIzaSyCULXkDYqAfCtpN7PmQktYachfyB7P8dqk",
                  authDomain: "lunch-78f47.firebaseapp.com",
                  projectId: "lunch-78f47",
                  storageBucket: "lunch-78f47.appspot.com",
                  messagingSenderId: "612330931668",
                  appId: "1:612330931668:web:07ab3d8ac7bba96f5ac241"
                };

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        loadSavedRoulettes();
                        loadSharedRoulettes();
                        resetBtn.disabled = false;
                    } else {
                        signInAnonymously(auth).catch(error => console.error("Anonymous sign-in failed:", error));
                    }
                });
            } catch (error) {
                console.error("Firebase 초기화 실패:", error);
                statusMessage.textContent = "앱 초기화에 실패했습니다.";
            }
        }

        function updateTeamUIState() {
            if (teamMode) {
                teamJoinBtn.classList.add('hidden');
                teamLeaveBtn.classList.remove('hidden');
                teamSlotsContainer.classList.remove('hidden');
                teamAccessInput.value = teamCode;
            } else {
                teamJoinBtn.classList.remove('hidden');
                teamLeaveBtn.classList.add('hidden');
                teamSlotsContainer.classList.add('hidden');
                teamAccessInput.value = '';
                teamStatus.textContent = '엑세스 코드를 입력하면 팀이 생성되거나 입장됩니다.';
            }
        }

        function createTeamEntry(index, text) {
            const raw = typeof text === 'string' ? text : '';
            const display = raw.trim() === '' ? `칸 ${index + 1}` : raw;
            return {
                id: `team-${index}`,
                place_name: display,
                rawText: raw,
                place_url: '#',
                address_name: '',
                road_address_name: '',
                phone: '',
                distance: 0,
                isTeamEntry: true
            };
        }

        function updateTeamSlotsUI(slots = []) {
            if (!teamMode) return;
            teamSlotsContainer.innerHTML = '';
            slots.forEach((slot, index) => {
                const row = document.createElement('div');
                row.className = 'flex items-center gap-2';

                const label = document.createElement('span');
                label.className = 'w-6 text-xs font-semibold text-slate-500 text-right';
                label.textContent = `${index + 1}.`;

                const input = document.createElement('input');
                input.className = 'team-slot-input border rounded px-2 py-1 text-sm flex-1';
                input.value = slot || '';
                input.setAttribute('data-index', index);

                const button = document.createElement('button');
                button.className = 'team-slot-save bg-indigo-500 hover:bg-indigo-600 text-white text-xs font-semibold px-3 py-1 rounded-md flex-shrink-0';
                button.textContent = '저장';

                button.addEventListener('click', () => saveTeamSlot(index, input.value));
                input.addEventListener('keyup', (event) => {
                    if (event.key === 'Enter') {
                        saveTeamSlot(index, input.value);
                    }
                });

                row.appendChild(label);
                row.appendChild(input);
                row.appendChild(button);
                teamSlotsContainer.appendChild(row);
            });
        }

        function applyTeamSlotsToRestaurants(slots = []) {
            if (!teamMode) return;
            teamSlots = Array.from({ length: SEGMENT_COUNT }, (_, idx) => (slots[idx] || ''));
            restaurants = teamSlots.map((slot, index) => createTeamEntry(index, slot));
            candidateListsWrapper.innerHTML = '';
            saveContainer.classList.add('hidden');
            drawWheel();
            updateTeamSlotsUI(teamSlots);

            const filledCount = teamSlots.filter(slot => slot.trim() !== '').length;
            if (filledCount === SEGMENT_COUNT) {
                teamStatus.textContent = '모든 칸이 채워졌어요! 이제 START 버튼으로 함께 돌려보세요.';
                if (winnerIndex === -1 && !isSpinning) {
                    statusMessage.textContent = '팀 룰렛이 준비되었습니다! START 버튼을 누르면 모두가 동시에 볼 수 있어요.';
                }
            } else {
                teamStatus.textContent = `${filledCount}/${SEGMENT_COUNT}칸 채워졌어요. 모두 채우면 START 버튼이 활성화됩니다.`;
                if (winnerIndex === -1 && !isSpinning) {
                    statusMessage.textContent = '팀 룰렛을 채우는 중이에요. 팀원들과 함께 각 칸을 작성해 주세요.';
                }
            }
            updateStartButtonState();
        }

        async function saveTeamSlot(index, value) {
            if (!teamMode || !teamDocRef) return;
            const trimmed = (value || '').trim();
            try {
                const snap = await getDoc(teamDocRef);
                const data = snap.exists() ? snap.data() : {};
                const slots = Array.isArray(data.slots)
                    ? [...data.slots]
                    : Array.from({ length: SEGMENT_COUNT }, () => '');

                slots[index] = trimmed;

                await setDoc(
                    teamDocRef,
                    {
                        slots,
                        updatedAt: serverTimestamp(),
                        lastUpdatedBy: userId || null
                    },
                    { merge: true }
                );
            } catch (error) {
                console.error('팀 슬롯 업데이트 실패:', error);
                statusMessage.textContent = '슬롯을 저장하지 못했습니다. 잠시 후 다시 시도해 주세요.';
            }
        }

        async function clearTeamSlots() {
            if (!teamMode || !teamDocRef) return;
            try {
                await setDoc(teamDocRef, {
                    slots: Array.from({ length: SEGMENT_COUNT }, () => '')
                }, { merge: true });
                winnerIndex = -1;
                canvas.classList.remove('blinking');
                drawWheel();
                statusMessage.textContent = '팀 룰렛을 초기화했습니다. 다시 내용을 채워주세요.';
            } catch (error) {
                console.error('팀 룰렛 초기화 실패:', error);
                statusMessage.textContent = '팀 룰렛 초기화에 실패했습니다.';
            }
        }

        async function joinTeamRoom() {
            if (!db) {
                statusMessage.textContent = '앱이 준비되는 중입니다. 잠시 후 다시 시도해 주세요.';
                return;
            }
            const sanitized = sanitizeAccessCode(teamAccessInput.value.trim());
            if (!sanitized) {
                teamStatus.textContent = '영문과 숫자로 이루어진 엑세스 코드를 입력해 주세요.';
                teamAccessInput.focus();
                return;
            }
            if (teamMode && sanitized === teamCode) {
                teamStatus.textContent = `이미 '${teamCode}' 팀에 참여 중입니다.`;
                return;
            }

            teamJoinBtn.disabled = true;
            teamJoinBtn.classList.add('opacity-60', 'cursor-not-allowed');
            try {
                await enterTeamMode(sanitized);
            } catch (error) {
                console.error('팀플레이 입장 실패:', error);
                statusMessage.textContent = '팀에 참여하지 못했습니다. 잠시 후 다시 시도해 주세요.';
            } finally {
                teamJoinBtn.disabled = false;
                teamJoinBtn.classList.remove('opacity-60', 'cursor-not-allowed');
            }
        }

        async function enterTeamMode(code) {
            if (!db) return;
            if (teamUnsubscribe) {
                teamUnsubscribe();
                teamUnsubscribe = null;
            }

            resetState(true);
            canvas.classList.remove('blinking');
            winnerIndex = -1;

            teamMode = true;
            teamCode = code;
            teamAccessInput.value = code;
            updateTeamUIState();

            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

            try {
                const appDocRef = doc(db, "artifacts", appId);
                await setDoc(appDocRef, {
                    initializedAt: serverTimestamp()
                }, { merge: true });
            } catch (error) {
                console.error('팀 베이스 문서 준비 실패:', error);
                throw error;
            }

            teamDocRef = doc(db, "artifacts", appId, "team-rooms", code);

            try {
                const docSnap = await getDoc(teamDocRef);
                if (!docSnap.exists()) {
                    await setDoc(teamDocRef, {
                        slots: Array.from({ length: SEGMENT_COUNT }, () => ''),
                        createdAt: serverTimestamp()
                    });
                }
            } catch (error) {
                console.error('팀 문서 준비 실패:', error);
                teamMode = false;
                teamDocRef = null;
                updateTeamUIState();
                throw error;
            }

            lastTeamSpinTrigger = '';
            teamSnapshotInitialized = false;
            teamUnsubscribe = onSnapshot(teamDocRef, handleTeamSnapshot);
            statusMessage.textContent = `팀 룰렛 '${code}'에 참여했어요. 각 칸을 채워주세요.`;
        }

        function handleTeamSnapshot(docSnap) {
            if (!docSnap.exists()) return;
            const data = docSnap.data() || {};
            const slots = Array.isArray(data.slots) ? data.slots : [];
            applyTeamSlotsToRestaurants(slots);

            if (data.spin && data.spin.triggerId) {
                if (!teamSnapshotInitialized) {
                    lastTeamSpinTrigger = data.spin.triggerId;
                } else if (data.spin.triggerId !== lastTeamSpinTrigger) {
                    lastTeamSpinTrigger = data.spin.triggerId;
                    triggerTeamSpinFromSnapshot(data.spin);
                }
            }
            teamSnapshotInitialized = true;
        }

        function triggerTeamSpinFromSnapshot(spinState = {}) {
            const rotation = Number(spinState.totalRotation) || 0;
            const targetIndex = typeof spinState.winnerIndex === 'number'
                ? spinState.winnerIndex
                : calculateWinnerIndex(rotation);
            animateSpin(rotation, targetIndex, { triggeredByTeam: true });
        }

        function leaveTeamMode(options = {}) {
            const { silent = false } = options;
            if (teamUnsubscribe) {
                teamUnsubscribe();
                teamUnsubscribe = null;
            }
            teamMode = false;
            teamCode = '';
            teamDocRef = null;
            teamSlots = Array.from({ length: SEGMENT_COUNT }, () => '');
            lastTeamSpinTrigger = '';
            teamSnapshotInitialized = false;
            winnerIndex = -1;
            canvas.classList.remove('blinking');
            updateTeamUIState();
            resetState(true);
            if (!silent) {
                statusMessage.textContent = '팀에서 나왔어요. 새로운 엑세스 코드를 입력해 보세요.';
            }
            updateStartButtonState();
        }

        // --- 이벤트 리스너 ---
        modeButtons.forEach(button => {
            button.addEventListener('click', () => setMode(button.dataset.modeTarget));
        });
        resetBtn.addEventListener('click', () => handleReset());
        startBtn.addEventListener('click', handleStart);
        saveBtn.addEventListener('click', handleSave);
        searchSharedInput.addEventListener('input', renderSharedRoulettes);
        applyCustomBtn.addEventListener('click', handleApplyCustomChart);
        teamJoinBtn.addEventListener('click', joinTeamRoom);
        teamLeaveBtn.addEventListener('click', () => leaveTeamMode());
        teamAccessInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter') {
                joinTeamRoom();
            }
        });
        applyManualLocationBtn.addEventListener('click', () => {
            if (teamMode) {
                statusMessage.textContent = '팀플레이 모드에서는 주변 식당 불러오기를 사용할 수 없어요.';
                return;
            }
            if (currentMode !== Mode.LOCATION) {
                statusMessage.textContent = '위치기반 모드에서만 사용할 수 있는 기능이에요.';
                return;
            }
            const value = manualLocationSelect.value;
            if (!value) {
                statusMessage.textContent = '동네를 선택해 주세요.';
                return;
            }
            const [lat, lng] = value.split(',').map(Number);
            locationFallback.classList.add('hidden');
            fetchRestaurants(lat, lng, 'manual');
        });
        winnerRerollBtn.addEventListener('click', () => {
            if (!startBtn.disabled) {
                handleStart();
            }
        });

        document.querySelectorAll('.sample-template-btn').forEach(btn => {
            btn.addEventListener('click', () => applyTemplate(btn.dataset.template));
        });
        
        // --- 렌더링 함수 ---
        function drawWheel() {
            const radius = canvas.width / 2;
            const segmentAngle = (2 * Math.PI) / SEGMENT_COUNT;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(radius, radius);

            for (let i = 0; i < SEGMENT_COUNT; i++) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const startAngle = segmentAngle * i - segmentAngle / 2;
                const endAngle = segmentAngle * (i + 1) - segmentAngle / 2;
                ctx.arc(0, 0, radius - 5, startAngle, endAngle);
                ctx.closePath();
                
                if (winnerIndex === i && canvas.classList.contains('blinking')) {
                     ctx.fillStyle = i % 2 === 0 ? '#fca5a5' : '#f87171';
                } else {
                    ctx.fillStyle = colors[i % colors.length];
                }
                ctx.fill();
                
                ctx.save();
                ctx.rotate(startAngle + segmentAngle / 2);
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#1f2937';
                ctx.font = `bold ${radius * 0.08}px 'Noto Sans KR'`;
                
                const text = restaurants[i] ? restaurants[i].place_name : (restaurants.length > 0 ? '?' : '준비 중');
                const textRadius = radius * 0.9;
                
                let displayText = text;
                if (ctx.measureText(text).width > radius * 0.7) {
                    displayText = text.substring(0, 7) + '...';
                }

                ctx.fillText(displayText, textRadius, 0);
                ctx.restore();
            }
            ctx.restore();
        }

        // --- 상태 관리 함수 ---
        function handleReset(options = {}) {
            if (isSpinning) return;
            if (teamMode) {
                resetBtn.disabled = true;
                clearTeamSlots().finally(() => updateStartButtonState());
                return;
            }
            if (currentMode !== Mode.LOCATION) {
                statusMessage.textContent = '위치기반 모드에서만 다시 불러올 수 있어요.';
                return;
            }
            const { silent = false } = options;
            resetState(silent);
            if (!silent) {
                statusMessage.textContent = '주변 식당을 다시 찾고 있어요...';
            }
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(onGeoSuccess, onGeoError, { enableHighAccuracy: false, timeout: 8000 });
            } else {
                statusMessage.textContent = '위치 정보를 사용할 수 없습니다. 동네를 직접 선택해 주세요.';
                resetBtn.disabled = false;
                locationFallback.classList.remove('hidden');
            }
        }

        function resetState(keepStatus = false) {
            isSpinning = false;
            startBtn.disabled = true;
            resetBtn.disabled = true;
            saveContainer.classList.add('hidden');
            candidateListsWrapper.innerHTML = '';
            restaurants = [];
            winnerIndex = -1;
            canvas.style.transition = 'none';
            canvas.style.transform = `rotate(0deg)`;
            canvas.classList.remove('blinking');
            if (blinkAnimationId) cancelAnimationFrame(blinkAnimationId);
            drawWheel();
            winnerCard.classList.add('hidden');
            if (!keepStatus) {
                statusMessage.textContent = '주변 맛집을 모으는 중이에요...';
            }
            updateStartButtonState();
        }

        function calculateWinnerIndex(totalRotation) {
            const normalized = ((totalRotation % 360) + 360) % 360;
            const segmentAngle = 360 / SEGMENT_COUNT;
            const winningAngle = (270 - normalized + 360) % 360;
            return Math.round(winningAngle / segmentAngle) % SEGMENT_COUNT;
        }

        function animateSpin(totalRotation, forcedIndex = null) {
            isSpinning = true;
            saveContainer.classList.add('hidden');
            canvas.classList.remove('blinking');
            if (blinkAnimationId) cancelAnimationFrame(blinkAnimationId);
            winnerCard.classList.add('hidden');
            updateStartButtonState();

            canvas.style.transition = 'transform 5s cubic-bezier(0.1, 0.7, 0.3, 1)';
            canvas.style.transform = `rotate(${totalRotation}deg)`;

            setTimeout(() => {
                isSpinning = false;
                const targetIndex = typeof forcedIndex === 'number' ? forcedIndex : calculateWinnerIndex(totalRotation);
                winnerIndex = targetIndex;
                const winner = restaurants[winnerIndex];
                updateStartButtonState();

                if (!winner || (winner.isTeamEntry && (winner.rawText || '').trim() === '')) {
                    statusMessage.textContent = '아직 비어 있는 칸에 멈췄어요. 내용을 채워볼까요?';
                    winnerCard.classList.add('hidden');
                    startBlinking();
                    return;
                }

                if (!teamMode && winner.id === 'reroll') {
                    statusMessage.innerHTML = `아쉽네요! <span class="font-bold text-red-600">다시 한 번!</span>`;
                    winnerCard.classList.add('hidden');
                    startBlinking();
                    return;
                }

                if (teamMode && winner.isTeamEntry) {
                    const displayName = safeText((winner.rawText || winner.place_name));
                    statusMessage.innerHTML = `팀 룰렛 결과는 <span class="font-bold text-emerald-600">${displayName}</span>!`;
                } else {
                    statusMessage.innerHTML = `오늘의 식사는 <a href="${winner.place_url || '#'}" target="_blank" class="font-bold text-blue-600 underline">${safeText(winner.place_name)}</a>!`;
                }

                populateWinnerCard(winner);
                winnerCard.classList.remove('hidden');         
                startBlinking();
            }, 5000);
        }

        async function handleStart() {
            if (isSpinning) return;

            if (teamMode) {
                if (!teamDocRef) {
                    statusMessage.textContent = '팀 정보가 아직 준비되지 않았습니다. 잠시 후 다시 시도해 주세요.';
                    return;
                }
                const allFilled = teamSlots.every(slot => slot.trim() !== '');
                if (!allFilled) {
                    statusMessage.textContent = '모든 칸을 채워야 룰렛을 돌릴 수 있어요!';
                    return;
                }
                if (blinkAnimationId) cancelAnimationFrame(blinkAnimationId);
                canvas.classList.remove('blinking');
                winnerCard.classList.add('hidden');
                isSpinning = true;
                updateStartButtonState();
                const randomSpins = Math.floor(Math.random() * 5) + 5;
                const randomStopAngle = Math.random() * 360;
                const totalRotation = randomSpins * 360 + randomStopAngle;
                const winnerIdx = calculateWinnerIndex(totalRotation);
                const spinPayload = {
                    triggerId: `${userId || 'guest'}-${Date.now()}`,
                    totalRotation,
                    winnerIndex: winnerIdx,
                    initiatedAt: Date.now(),
                    initiator: userId || null
                };
                const previousTrigger = lastTeamSpinTrigger;
                lastTeamSpinTrigger = spinPayload.triggerId;
                try {
                    await updateDoc(teamDocRef, { spin: spinPayload });
                    animateSpin(totalRotation, winnerIdx);
                } catch (error) {
                    console.error('팀 룰렛 회전 정보 업데이트 실패:', error);
                    statusMessage.textContent = '룰렛을 돌리지 못했어요. 다시 시도해 주세요.';
                    isSpinning = false;
                    lastTeamSpinTrigger = previousTrigger;
                    updateStartButtonState();
                }
                return;
            }

            if (restaurants.length < SEGMENT_COUNT) return;

            const randomSpins = Math.floor(Math.random() * 5) + 5;
            const randomStopAngle = Math.random() * 360;
            const totalRotation = randomSpins * 360 + randomStopAngle;
            const winnerIdx = calculateWinnerIndex(totalRotation);
            animateSpin(totalRotation, winnerIdx);
        }   
        
        function startBlinking() {
            let lastTime = 0;
            let show = true;
            function blink(currentTime) {
                if (isSpinning) return;
                if (currentTime - lastTime > 500) {
                    lastTime = currentTime;
                    show = !show;
                    canvas.classList.toggle('blinking', show);
                    drawWheel();
                }
                blinkAnimationId = requestAnimationFrame(blink);
            }
            blinkAnimationId = requestAnimationFrame(blink);
        }

        // --- 데이터 처리 함수 ---
        function onGeoSuccess(position) {
            lastKnownCoords = { lat: position.coords.latitude, lng: position.coords.longitude };
            statusMessage.textContent = '주변 식당 정보를 가져오는 중...';
            locationFallback.classList.add('hidden');
            fetchRestaurants(lastKnownCoords.lat, lastKnownCoords.lng, 'geo');
        }

        function onGeoError(error) {
            console.error(error);
            statusMessage.textContent = '위치 정보를 확인할 수 없어요. 아래에서 동네를 직접 선택해 주세요.';
            resetBtn.disabled = false;
            locationFallback.classList.remove('hidden');
        }

        function fetchRestaurants(lat, lng, source = 'geo') {
            const places = new kakao.maps.services.Places();
            places.categorySearch('FD6', (result, status) => {
                if (status === kakao.maps.services.Status.OK) {
                    processRestaurantData(result, '', source);
                } else if (status === kakao.maps.services.Status.ZERO_RESULT) {
                    processRestaurantData([]);
                }
                else {
                    statusMessage.textContent = '주변 식당 정보를 가져오는데 실패했습니다.';
                    resetBtn.disabled = false;
                }
            }, { location: new kakao.maps.LatLng(lat, lng), radius: 1000, size: 15 });
        }

        function processRestaurantData(data, titlePrefix = '', source = 'geo') {
            if (teamMode) return;
            const mode = modeSelect.value;
            let placesForRoulette = [];
            let listHtml = '';
            
            const createListItem = (place) => {
                if (place.id === 'reroll') {
                    return `<li class="text-gray-500">- 다시 한 번</li>`;
                }
                const distanceMeters = Number(place.distance || 0);
                const distanceText = distanceMeters > 0 ? `${Math.round(distanceMeters / 10) * 10}m` : '거리 정보 없음';
                const category = place.category_name ? place.category_name.split('>').pop().trim() : '';
                const linkContent = place.place_url && place.place_url !== '#'
                    ? `<a href="${place.place_url}" target="_blank" class="hover:underline hover:text-blue-600">${safeText(place.place_name)}</a>`
                    : safeText(place.place_name);

                return `<li class="bg-slate-50 rounded-md px-3 py-2 shadow-sm" title="${safeText(place.place_name)}">
                            <div class="flex items-center justify-between text-sm font-semibold text-gray-700">
                                <span class="truncate">${linkContent}</span>
                                <span class="text-xs text-gray-500">${safeText(category)}</span>
                            </div>
                            <div class="mt-1 text-xs text-gray-500">${distanceText} · ${safeText(place.road_address_name || place.address_name || '')}</div>
                        </li>`;
            };

            if (titlePrefix) {
                placesForRoulette = data;
                listHtml = `<div>
                                <h3 class="text-lg font-semibold text-indigo-700 mb-2 border-b-2 border-indigo-200 pb-1">${safeText(titlePrefix)}</h3>
                                <ul class="space-y-2 text-gray-700">${placesForRoulette.map(p => createListItem(p)).join('')}</ul>
                            </div>`;
            } else {
                switch (mode) {
                    case 'distance': {
                        const distanceSorted = [...data].sort((a, b) => Number(a.distance || Infinity) - Number(b.distance || Infinity));
                        placesForRoulette = distanceSorted;
                        listHtml = `<div>
                                        <h3 class="text-lg font-semibold text-blue-700 mb-2 border-b-2 border-blue-200 pb-1">🚶‍♂️ 가까운 순 추천</h3>
                                        <ul class="space-y-2 text-gray-700">${placesForRoulette.map(p => createListItem(p)).join('')}</ul>
                                    </div>`;
                        break;
                    }
                    case 'random': {
                        const randomPlaces = [...data].sort(() => 0.5 - Math.random());
                        placesForRoulette = randomPlaces;
                        listHtml = `<div>
                                        <h3 class="text-lg font-semibold text-orange-700 mb-2 border-b-2 border-orange-200 pb-1">🎲 랜덤 추천</h3>
                                        <ul class="space-y-2 text-gray-700">${placesForRoulette.map(p => createListItem(p)).join('')}</ul>
                                    </div>`;
                        break;
                    }
                    default: {
                        const distanceSorted = [...data].sort((a, b) => Number(a.distance || Infinity) - Number(b.distance || Infinity));
                        const close = distanceSorted.slice(0, 3);
                        const remainingAfterClose = data.filter(place => !close.find(c => c.id === place.id));
                        const varietyMap = new Map();
                        const variety = [];
                        for (const place of remainingAfterClose) {
                            const category = (place.category_name || '').split('>').pop()?.trim() || '기타';
                            if (!varietyMap.has(category)) {
                                variety.push(place);
                                varietyMap.set(category, true);
                            }
                            if (variety.length >= 3) break;
                        }
                        const leftovers = data.filter(place => !close.includes(place) && !variety.includes(place));
                        const randomPick = [];
                        while (randomPick.length < 3 && leftovers.length > 0) {
                            const randomIndex = Math.floor(Math.random() * leftovers.length);
                            randomPick.push(leftovers.splice(randomIndex, 1)[0]);
                        }
                        placesForRoulette = [...close, ...variety, ...randomPick];
                        listHtml = `<div class="space-y-4">
                                        <div>
                                            <h3 class="text-lg font-semibold text-emerald-700 mb-2 border-b-2 border-emerald-200 pb-1">🍱 가까우면서 인기 있는 조합</h3>
                                            <ul class="space-y-2 text-gray-700">${close.map(p => createListItem(p)).join('')}</ul>
                                        </div>
                                        <div>
                                            <h3 class="text-lg font-semibold text-teal-700 mb-2 border-b-2 border-teal-200 pb-1">🍲 다양한 메뉴</h3>
                                            <ul class="space-y-2 text-gray-700">${variety.map(p => createListItem(p)).join('')}</ul>
                                        </div>
                                        <div>
                                            <h3 class="text-lg font-semibold text-orange-700 mb-2 border-b-2 border-orange-200 pb-1">🎲 깜짝 선택</h3>
                                            <ul class="space-y-2 text-gray-700">${randomPick.map(p => createListItem(p)).join('')}</ul>
                                        </div>
                                    </div>`;
                    }
                }
            }
            
            const rerollOption = { place_name: '다시 한 번', id: 'reroll', place_url: '#' };
            while (placesForRoulette.length < SEGMENT_COUNT) {
                placesForRoulette.push(rerollOption);
            }

            restaurants = placesForRoulette.slice(0, SEGMENT_COUNT);
            statusMessage.textContent = source === 'manual' ? '선택한 동네의 후보가 준비되었어요! START를 눌러주세요.' : '룰렛이 준비되었습니다! START 버튼을 누르세요.';
            updateStartButtonState();
            saveContainer.classList.remove('hidden');
            rouletteNameInput.value = '';
            drawWheel();
            candidateListsWrapper.innerHTML = listHtml;
            locationFallback.classList.add('hidden');
        }

        function handleApplyCustomChart() {
            if (teamMode) {
                statusMessage.textContent = '팀플레이 모드에서는 직접 만든 룰렛을 적용할 수 없어요. 먼저 팀에서 나가주세요.';
                return;
            }
            const inputs = document.querySelectorAll('.custom-input');
            const customNames = Array.from(inputs).map(input => input.value.trim()).filter(name => name !== '');

            if (customNames.length === 0) {
                statusMessage.textContent = "식당 이름을 하나 이상 입력해주세요.";
                return;
            }

            const customRestaurants = customNames.map((name, index) => ({
                place_name: safeText(name),
                id: `custom_${Date.now()}_${index}`,
                place_url: '#'
            }));
            
            resetState();
            processRestaurantData(customRestaurants, '직접 만든 룰렛');
            statusMessage.textContent = '직접 만든 룰렛을 적용했습니다!';
            updateStartButtonState();
        }

        function applyTemplate(type) {
            const templates = {
                korean: ['된장찌개', '김치찌개', '불고기 백반', '냉면', '제육볶음', '칼국수', '돈까스', '곰탕', '비빔밥'],
                noodle: ['짜장면', '짬뽕', '우동', '파스타', '라멘', '막국수', '쌀국수', '칼국수', '소바'],
                office: ['샐러드', '샌드위치', '포케', '김밥', '덮밥', '컵밥', '라이스버거', '파스타', '타코'],
                snack: ['떡볶이', '순대', '튀김 모둠', '김밥', '어묵', '라볶이', '찐만두', '핫도그', '튀김우동']
            };
            const selected = templates[type] || [];
            const inputs = document.querySelectorAll('.custom-input');
            inputs.forEach((input, index) => {
                input.value = selected[index] || '';
            });
        }

        // --- Firebase Firestore 함수 ---
        async function handleSave() {
            if (saveBtn.dataset.loading === 'true') return;
            saveBtn.dataset.loading = 'true';
            saveBtn.disabled = true;
            saveBtn.classList.add('opacity-60', 'cursor-not-allowed');
            const finishSave = () => {
                saveBtn.disabled = false;
                saveBtn.classList.remove('opacity-60', 'cursor-not-allowed');
                delete saveBtn.dataset.loading;
            };
            if (teamMode) {
                statusMessage.textContent = '팀플레이 룰렛은 저장할 수 없습니다.';
                finishSave();
                return;
            }
            const name = rouletteNameInput.value.trim();
            if (!name) {
                statusMessage.textContent = "룰렛 이름을 입력해주세요.";
                finishSave();
                return;
            }
            if (restaurants.some(r => r.id === 'reroll')) {
                statusMessage.textContent = "'다시 한 번'이 포함된 룰렛은 저장할 수 없습니다.";
                finishSave();
                return;
            }

            // 직접 만든 룰렛 저장 시에는 지역명 자동 추가 기능 비활성화
            if (restaurants.every(r => r.id.startsWith('custom'))) {
                try {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    await addDoc(collection(db, "artifacts", appId, "users", userId, "roulettes"), {
                        name: name, // 사용자가 입력한 이름 그대로 저장
                        restaurants: restaurants,
                        createdAt: serverTimestamp()
                    });
                    statusMessage.textContent = `'${name}' 룰렛이 저장되었습니다.`;
                    rouletteNameInput.value = '';
                    saveContainer.classList.add('hidden');
                } catch (error) {
                    console.error("룰렛 저장 실패:", error);
                    statusMessage.textContent = "룰렛 저장에 실패했습니다.";
                }
                finishSave();
                return;
            }

            // 위치 기반 룰렛 저장 (기존 로직)
            if (!userId || !lastKnownCoords) {
                statusMessage.textContent = "위치 정보가 필요합니다.";
                finishSave();
                return;
            }
            const geocoder = new kakao.maps.services.Geocoder();
            geocoder.coord2RegionCode(lastKnownCoords.lng, lastKnownCoords.lat, async (result, status) => {
                let regionName = "알수없음";
                if (status === kakao.maps.services.Status.OK) {
                    const region = result.find(r => r.region_type === 'H');
                    if(region) regionName = region.address_name.split(' ').pop();
                }
                
                const finalName = `[${regionName}] ${name}`;
                
                try {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    await addDoc(collection(db, "artifacts", appId, "users", userId, "roulettes"), {
                        name: finalName,
                        restaurants: restaurants,
                        createdAt: serverTimestamp()
                    });
                    statusMessage.textContent = `'${finalName}' 룰렛이 저장되었습니다.`;
                    rouletteNameInput.value = '';
                    saveContainer.classList.add('hidden');
                } catch (error) {
                    console.error("룰렛 저장 실패:", error);
                    statusMessage.textContent = "룰렛 저장에 실패했습니다.";
                }
                finishSave();
            });
        }

        function loadSavedRoulettes() {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const q = query(collection(db, "artifacts", appId, "users", userId, "roulettes"), orderBy("createdAt", "desc"));

            onSnapshot(q, (snapshot) => {
                savedRoulettesList.innerHTML = snapshot.empty ? '<p class="text-center text-gray-500">저장된 룰렛이 없습니다.</p>' : '';
                snapshot.forEach((doc) => {
                    const roulette = doc.data();
                    const div = document.createElement('div');
                    div.className = 'flex justify-between items-center p-2 border-b';
                    div.innerHTML = `
                        <span class="font-semibold truncate" title="${safeText(roulette.name)}">${safeText(roulette.name)}</span>
                        <div class="flex-shrink-0 space-x-1">
                            <button data-id="${doc.id}" class="load-btn bg-green-100 text-green-800 text-xs font-semibold px-2 py-1 rounded">불러오기</button>
                            <button data-id="${doc.id}" class="share-btn bg-yellow-100 text-yellow-800 text-xs font-semibold px-2 py-1 rounded">자랑하기</button>
                            <button data-id="${doc.id}" class="delete-btn bg-red-100 text-red-800 text-xs font-semibold px-2 py-1 rounded">삭제</button>
                        </div>
                    `;
                    savedRoulettesList.appendChild(div);
                });

                document.querySelectorAll('.load-btn').forEach(btn => btn.addEventListener('click', (e) => loadSpecificRoulette(e.target.dataset.id, 'private')));
                document.querySelectorAll('.share-btn').forEach(btn => btn.addEventListener('click', (e) => handleShare(e.target.dataset.id)));
                document.querySelectorAll('.delete-btn').forEach(btn => btn.addEventListener('click', (e) => deleteSpecificRoulette(e.target.dataset.id)));
            });
        }

        async function loadSpecificRoulette(docId, type) {
            if (!userId) return;
            if (teamMode) {
                statusMessage.textContent = '팀플레이 모드에서는 개인이나 공개 룰렛을 불러올 수 없어요. 먼저 팀에서 나가주세요.';
                return;
            }
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const collectionPath = type === 'private'
                    ? ["artifacts", appId, "users", userId, "roulettes"] 
                    : ["artifacts", appId, "public", "data", "shared-roulettes"];
                
                const docRef = doc(db, ...collectionPath, docId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const rouletteData = docSnap.data();
                    resetState();
                    restaurants = rouletteData.restaurants;
                    statusMessage.textContent = `'${rouletteData.name}' 룰렛을 적용했습니다.`;
                    processRestaurantData(restaurants, rouletteData.name);
                    drawWheel();
                    updateStartButtonState();
                }
            } catch (error) {
                console.error("룰렛 불러오기 실패:", error);
            }
        }
        
        async function deleteSpecificRoulette(docId) {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            await deleteDoc(doc(db, "artifacts", appId, "users", userId, "roulettes", docId));
        }

        async function handleShare(docId) {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const docRef = doc(db, "artifacts", appId, "users", userId, "roulettes", docId);
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                const rouletteToShare = docSnap.data();
                await addDoc(collection(db, "artifacts", appId, "public", "data", "shared-roulettes"), {
                    ...rouletteToShare,
                    sharedBy: userId,
                    sharedAt: serverTimestamp(),
                    likes: 0,
                    dislikes: 0,
                    voters: []
                });
                statusMessage.textContent = `'${rouletteToShare.name}' 룰렛을 자랑했습니다!`;
            }
        }

        function loadSharedRoulettes() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const q = query(collection(db, "artifacts", appId, "public", "data", "shared-roulettes"));
            
            onSnapshot(q, (snapshot) => {
                let roulettes = [];
                snapshot.forEach(doc => {
                    const shared = doc.data();
                    roulettes.push({ id: doc.id, ...shared });
                });

                roulettes.sort((a, b) => {
                    const likesDiff = (b.likes || 0) - (a.likes || 0);
                    if (likesDiff !== 0) return likesDiff;
                    const dateB = b.sharedAt?.toDate() || 0;
                    const dateA = a.sharedAt?.toDate() || 0;
                    return dateB - dateA;
                });

                allSharedRoulettes = roulettes;
                renderSharedRoulettes();
            });
        }

        function renderSharedRoulettes() {
            const searchTerm = searchSharedInput.value.toLowerCase();
            const filteredList = allSharedRoulettes.filter(shared => shared.name?.toLowerCase().includes(searchTerm));

            sharedRoulettesList.innerHTML = filteredList.length === 0 ? '<p class="text-center text-gray-500">일치하는 룰렛이 없어요.</p>' : '';
            
            filteredList.forEach(shared => {
                const div = document.createElement('div');
                div.className = 'p-3 mb-3 border border-slate-200 rounded-lg shadow-sm bg-white';
                const restaurants = Array.isArray(shared.restaurants) ? shared.restaurants : [];
                div.innerHTML = `
                    <p class="font-bold truncate" title="${safeText(shared.name)}">${safeText(shared.name)}</p>
                    <ul class="text-sm text-gray-600 mt-2 grid grid-cols-3 gap-2">
                        ${restaurants.slice(0,3).map(r => `<li class="truncate bg-slate-100 px-2 py-1 rounded text-xs">${safeText(r.place_name)}</li>`).join('')}
                        ${restaurants.length > 3 ? '<li class="text-gray-400 col-span-3 text-xs">... 등 다양한 식당이 있어요</li>' : ''}
                    </ul>
                    <div class="flex items-center justify-between mt-3">
                        <div class="flex items-center space-x-2">
                            <button data-id="${shared.id}" data-vote="like" class="vote-btn flex items-center bg-blue-50 px-3 py-1 rounded-full text-xs hover:bg-blue-100">👍 <span class="ml-1 font-semibold">${shared.likes || 0}</span></button>
                            <button data-id="${shared.id}" data-vote="dislike" class="vote-btn flex items-center bg-rose-50 px-3 py-1 rounded-full text-xs hover:bg-rose-100">👎 <span class="ml-1 font-semibold">${shared.dislikes || 0}</span></button>
                        </div>
                        <button data-id="${shared.id}" class="apply-btn bg-indigo-500 hover:bg-indigo-600 text-white text-sm font-bold py-1 px-3 rounded">적용하기</button>
                    </div>
                `;
                sharedRoulettesList.appendChild(div);
            });

            document.querySelectorAll('.apply-btn').forEach(btn => btn.addEventListener('click', (e) => loadSpecificRoulette(e.target.dataset.id, 'public')));
            document.querySelectorAll('.vote-btn').forEach(btn => btn.addEventListener('click', (e) => handleVote(e.currentTarget.dataset.id, e.currentTarget.dataset.vote)));
        }

        async function handleVote(docId, voteType) {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const docRef = doc(db, "artifacts", appId, "public", "data", "shared-roulettes", docId);
            
            const docSnap = await getDoc(docRef);
            if (!docSnap.exists()) return;

            const localVotesRaw = localStorage.getItem('lunch-votes') || '{}';
            const localVotes = JSON.parse(localVotesRaw);
            if (localVotes[docId]) {
                statusMessage.textContent = '이미 투표하셨습니다.';
                return;
            }

            const voters = docSnap.data().voters || [];
            if (voters.includes(userId)) {
                statusMessage.textContent = '이미 투표하셨습니다.';
                localVotes[docId] = true;
                localStorage.setItem('lunch-votes', JSON.stringify(localVotes));
                return;
            }

            const updateData = {
                voters: arrayUnion(userId)
            };
            if (voteType === 'like') {
                updateData.likes = increment(1);
            } else {
                updateData.dislikes = increment(1);
            }
            await updateDoc(docRef, updateData);
            localVotes[docId] = true;
            localStorage.setItem('lunch-votes', JSON.stringify(localVotes));
            statusMessage.textContent = voteType === 'like' ? '좋아요 감사합니다!' : '의견을 남겨주셔서 감사해요.';
        }

        function populateWinnerCard(winner) {
            const displayName = winner.isTeamEntry ? (winner.rawText || winner.place_name) : winner.place_name;
            winnerName.textContent = displayName;
            winnerCallBtn.classList.remove('hidden');
            winnerMapBtn.classList.remove('opacity-60', 'pointer-events-none');

            if (winner.isTeamEntry) {
                winnerAddress.innerHTML = `<span class="font-semibold text-gray-700">✍️</span> 팀에서 직접 적은 메뉴예요.`;
                winnerPhone.innerHTML = `<span class="font-semibold text-gray-700">📞</span> 연락처 정보가 없어요.`;
                winnerCallBtn.href = '#';
                winnerCallBtn.classList.add('hidden');
                winnerMapBtn.href = '#';
                winnerMapBtn.classList.add('opacity-60', 'pointer-events-none');
                winnerTip.innerHTML = `<span class="font-semibold text-gray-700">💡</span> 팀원들과 맛집 정보를 공유해보세요!`;
                winnerTag.textContent = '팀 추천';
                return;
            }

            winnerAddress.innerHTML = `<span class="font-semibold text-gray-700">📍</span> ${safeText(winner.road_address_name || winner.address_name || '주소 정보 없음')}`;
            const phone = winner.phone || '';
            if (phone) {
                winnerPhone.innerHTML = `<span class="font-semibold text-gray-700">📞</span> ${safeText(phone)}`;
                winnerCallBtn.href = `tel:${phone.replace(/[^0-9+]/g, '')}`;
            } else {
                winnerPhone.innerHTML = `<span class="font-semibold text-gray-700">📞</span> 전화 정보가 없어요.`;
                winnerCallBtn.href = '#';
                winnerCallBtn.classList.add('hidden');
            }
            if (winner.place_url) {
                winnerMapBtn.href = winner.place_url;
            } else {
                winnerMapBtn.href = '#';
                winnerMapBtn.classList.add('opacity-60', 'pointer-events-none');
            }
            winnerTip.innerHTML = `<span class="font-semibold text-gray-700">⏰</span> 영업시간 정보는 카카오 페이지에서 확인해주세요.`;
            winnerTag.textContent = modeSelect.value === 'random' ? '완전 랜덤!' : (modeSelect.value === 'distance' ? '가까운 행운' : '추천 픽');
        }
    </script>
</body>
</html>
