<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>오늘 뭐 먹지? 룰렛 (DB 연동)</title>
    <meta property="og:title" content="오늘 뭐 먹지? 점심 룰렛" />
    <meta property="og:description" content="선택고민을 덜어주며 즐거움 한 스푼을 더 할 점심 추천 멀티 게임 허브" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://dummyimage.com/1200x630/fbf5ff/4338ca&text=오늘+뭐+먹지%3F" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        brand: ['"Pretendard"', '"Noto Sans KR"', 'sans-serif'],
                    },
                    colors: {
                        brand: {
                            amber: '#f59f0b',
                            indigo: '#4c51bf',
                            slate: '#0f172a'
                        }
                    },
                    boxShadow: {
                        brand: '0 20px 45px -22px rgba(79, 70, 229, 0.55)',
                        brandSoft: '0 25px 60px -28px rgba(15, 23, 42, 0.35)'
                    }
                }
            }
        };
    </script>
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=9ddcc83d3b7ed7f48495e2de9a0a4460&libraries=services"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Pretendard:wght@400;600;700&display=swap');
        body {
            font-family: 'Pretendard', 'Noto Sans KR', sans-serif;
            background: radial-gradient(120% 120% at 0% 0%, rgba(226, 232, 255, 0.65) 0%, rgba(241, 245, 249, 0.25) 45%, rgba(251, 191, 36, 0.16) 100%);
            color: #0f172a;
        }
        .top-nav-blur {
            background: rgba(248, 250, 252, 0.5);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(148, 163, 184, 0.18);
            box-shadow: 0 22px 44px -32px rgba(15, 23, 42, 0.35);
        }
        .floating-nav {
            background: rgba(15, 23, 42, 0.78);
            backdrop-filter: blur(18px);
            border-radius: 9999px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            box-shadow: 0 25px 60px -30px rgba(15, 23, 42, 0.55);
            padding: 0.4rem 0.6rem;
        }
        .floating-nav button {
            color: rgba(248, 250, 252, 0.78);
            transition: all 0.2s ease;
        }
        .floating-nav button:hover {
            color: #fef3c7;
            transform: translateY(-1px) scale(1.05);
        }
        .floating-nav button.mode-button-active {
            background: rgba(248, 250, 252, 0.16) !important;
            color: #fef08a !important;
        }
        .glass-card {
            background: rgba(255, 255, 255, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.65);
            box-shadow: 0 35px 80px -50px rgba(79, 70, 229, 0.45);
            backdrop-filter: blur(18px);
        }
        .hero-gradient {
            background: linear-gradient(135deg, rgba(254, 243, 199, 0.6), rgba(199, 210, 254, 0.65));
        }
        .mode-panel {
            position: relative;
            opacity: 0;
            transform: translateY(12px) scale(0.985);
        }
        .mode-panel.mode-hidden {
            pointer-events: none;
        }
        .mode-panel-active {
            animation: fadeSlideIn 0.35s ease forwards;
        }
        @keyframes fadeSlideIn {
            0% {
                opacity: 0;
                transform: translateY(16px) scale(0.98);
            }
            100% {
                opacity: 1;
                transform: none;
            }
        }
        .mode-hidden-hard {
            display: none !important;
        }
        .mode-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            border-radius: 9999px;
            background: rgba(15, 23, 42, 0.06);
            padding: 0.4rem 0.9rem;
            font-weight: 600;
            font-size: 0.8rem;
            color: #334155;
        }
        .roulette-container {
            position: relative;
            width: 90vw;
            height: 90vw;
            max-width: 450px;
            max-height: 450px;
        }
        canvas {
            width: 100%;
            height: 100%;
            transition: transform 5s cubic-bezier(0.25, 1, 0.5, 1);
        }
        .pointer {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 30px solid #ef4444; /* red-500 */
            z-index: 10;
        }
        .blinking {
            animation: blinker 1s linear infinite;
        }
        @keyframes blinker {
            50% {
                opacity: 0.3;
            }
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        .mode-button {
            position: relative;
            transition: all 0.35s cubic-bezier(0.33, 1, 0.68, 1);
            color: #0f172a;
            backdrop-filter: blur(14px);
        }
        .mode-button::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            border: 1px solid rgba(255, 255, 255, 0.25);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .mode-button:hover {
            transform: translateY(-3px) scale(1.01);
            box-shadow: var(--shadow-elevated, 0 25px 48px -28px rgba(30, 64, 175, 0.45));
        }
        .mode-button:hover::after {
            opacity: 1;
        }
        .mode-button-active {
            background: linear-gradient(140deg, rgba(15, 23, 42, 0.92), rgba(79, 70, 229, 0.82)) !important;
            color: #f8fafc !important;
            box-shadow: 0 25px 60px -24px rgba(79, 70, 229, 0.6);
        }
        .mode-button-active::after {
            border-color: rgba(248, 250, 252, 0.35);
            opacity: 1;
        }
        #landing-screen {
            background: linear-gradient(165deg, rgba(250, 245, 255, 0.55), rgba(226, 240, 255, 0.48));
        }
        #landing-screen.hidden {
            display: none !important;
        }
        .mode-button-location {
            background: linear-gradient(145deg, rgba(253, 244, 215, 0.75), rgba(250, 204, 21, 0.35));
            box-shadow: 0 22px 48px -28px rgba(217, 119, 6, 0.5);
        }
        .mode-button-team {
            background: linear-gradient(145deg, rgba(222, 255, 243, 0.78), rgba(16, 185, 129, 0.2));
            box-shadow: 0 22px 48px -28px rgba(16, 185, 129, 0.4);
        }
        .mode-button-custom {
            background: linear-gradient(145deg, rgba(233, 233, 254, 0.78), rgba(129, 140, 248, 0.25));
            box-shadow: 0 22px 48px -28px rgba(79, 70, 229, 0.45);
        }
        .mode-button-race {
            background: linear-gradient(145deg, rgba(254, 228, 226, 0.78), rgba(244, 114, 182, 0.25));
            box-shadow: 0 22px 48px -28px rgba(244, 63, 94, 0.45);
        }
        .mode-button-badge {
            font-size: 0.75rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #94a3b8;
            font-weight: 600;
        }
        .mode-button-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #0f172a;
        }
        .mode-button-subtitle {
            font-size: 0.95rem;
            color: #4b5563;
        }
        .mode-button-arrow {
            font-size: 1.75rem;
            color: #cbd5f5;
        }
        .mode-button-active .mode-button-badge,
        .mode-button-active .mode-button-title,
        .mode-button-active .mode-button-subtitle,
        .mode-button-active .mode-button-arrow {
            color: #f8fafc !important;
        }
        .mode-hidden {
            display: none !important;
        }
        .game-stage {
            width: 100%;
        }
        #ladderCanvas {
            width: 100%;
            max-width: 560px;
            background: linear-gradient(180deg, #ffffff, #f8fafc);
            border-radius: 1rem;
            border: 1px solid #e2e8f0;
            box-shadow: inset 0 1px 3px rgba(148, 163, 184, 0.18);
        }
        .ladder-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        .ball-pool {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            padding: 1rem;
            background: linear-gradient(180deg, rgba(248, 250, 252, 0.9), rgba(241, 245, 249, 0.9));
            border-radius: 1rem;
            border: 1px solid rgba(148, 163, 184, 0.3);
            min-height: 120px;
        }
        .ball-item {
            width: 72px;
            height: 72px;
            border-radius: 9999px;
            background: radial-gradient(circle at 30% 30%, #fef3c7, #f59e0b);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: #78350f;
            box-shadow: 0 10px 18px -12px rgba(120, 53, 15, 0.6);
            transition: transform 0.18s ease, box-shadow 0.18s ease;
        }
        .ball-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 30px -16px rgba(120, 53, 15, 0.55);
        }
        .ball-item-active {
            transform: scale(1.08);
            background: radial-gradient(circle at 30% 30%, #fef08a, #eab308);
            color: #b45309;
            box-shadow: 0 18px 36px -14px rgba(217, 119, 6, 0.6);
        }
        .ball-item-label {
            font-size: 0.75rem;
            text-align: center;
            line-height: 1.1;
            padding: 0 0.3rem;
        }
        .location-game-hint {
            background: rgba(255, 255, 255, 0.8);
            border: 1px dashed rgba(148, 163, 184, 0.6);
        }
        .race-track {
            position: relative;
            width: 100%;
            height: 0.7rem;
            border-radius: 9999px;
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(251, 191, 36, 0.4);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.65);
            overflow: hidden;
        }
        .race-track-inner {
            position: absolute;
            inset: 1.4px;
            border-radius: inherit;
            background: rgba(251, 191, 36, 0.22);
            overflow: hidden;
        }
        .race-track-fill {
            position: absolute;
            left: 0;
            top: 0;
            width: 0%;
            height: 100%;
            border-radius: inherit;
            background: linear-gradient(90deg, #fcd34d, #f97316);
            transition: width 0.2s ease-out;
            box-shadow: inset 0 0 14px rgba(251, 191, 36, 0.45);
        }
        .race-track-icon {
            position: absolute;
            top: 50%;
            left: 0%;
            transform: translate(-50%, -50%);
            font-size: 1.25rem;
            transition: left 0.15s ease-out;
            filter: drop-shadow(0 6px 8px rgba(15, 23, 42, 0.18));
            pointer-events: none;
        }
        .race-status-label {
            min-height: 0.9rem;
        }
        .race-lane {
            transition: transform 0.3s ease, filter 0.3s ease;
        }
        .race-track-lanes {
            display: flex;
            flex-direction: column;
            gap: 0.7rem;
        }
        .race-track-lanes > .race-lane {
            width: 100%;
        }
        .race-lane-horizontal {
            display: flex;
            align-items: center;
            gap: 0.7rem;
            padding: 0.7rem 0.9rem;
            border-radius: 1rem;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(254, 240, 199, 0.6));
            border: 1px solid rgba(251, 191, 36, 0.45);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 18px 30px -24px rgba(217, 119, 6, 0.45);
            flex-wrap: wrap;
        }
        .race-lane-horizontal .race-lane-meta {
            min-width: 126px;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            flex: 0 1 154px;
        }
        .race-lane-meta-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
            color: #9a3412;
        }
        .race-speed-indicator {
            font-size: 0.55rem;
            padding: 0.14rem 0.42rem;
            border-radius: 9999px;
            background: rgba(251, 191, 36, 0.18);
            color: #92400e;
        }
        .race-lane-progress {
            flex: 1 1 182px;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        .race-lane-progress .progress-label {
            font-size: 0.5rem;
            color: #b45309;
            font-weight: 600;
            letter-spacing: 0.04em;
            text-transform: uppercase;
        }
        .race-lane-boost {
            transform: scale(1.035);
            filter: drop-shadow(0 0 14px rgba(251, 191, 36, 0.35));
        }
        .race-lane-boost .race-track-fill {
            animation: raceBoostPulse 0.4s ease-in-out infinite alternate;
        }
        .race-lane-stumble {
            filter: grayscale(0.35) brightness(0.92);
            opacity: 0.82;
        }
        .race-lane-stumble .race-track-icon {
            animation: raceStumbleShake 0.6s ease-in-out infinite;
        }
        @keyframes raceBoostPulse {
            0% {
                box-shadow: inset 0 0 16px rgba(251, 191, 36, 0.5), 0 0 6px rgba(251, 191, 36, 0.35);
            }
            100% {
                box-shadow: inset 0 0 24px rgba(251, 146, 60, 0.75), 0 0 10px rgba(251, 146, 60, 0.45);
            }
        }
        @keyframes raceStumbleShake {
            0%, 100% {
                transform: translate(-50%, -50%) rotate(0deg);
            }
            25% {
                transform: translate(calc(-50% + 3px), calc(-50% - 3px)) rotate(-12deg);
            }
            50% {
                transform: translate(calc(-50% - 3px), calc(-50% + 3px)) rotate(10deg);
            }
            75% {
                transform: translate(calc(-50% + 1px), calc(-50% + 1px)) rotate(-6deg);
            }
        }
        @media (max-width: 640px) {
            .mode-button-title {
                font-size: 1.25rem;
            }
            .mode-button-subtitle {
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body class="min-h-screen antialiased text-slate-900">
    <div class="pointer-events-none fixed inset-0 -z-10 overflow-hidden">
        <div class="absolute -left-20 -top-10 h-[420px] w-[420px] rounded-full bg-gradient-to-br from-amber-200/70 via-amber-100/40 to-transparent blur-3xl"></div>
        <div class="absolute right-0 top-24 h-[560px] w-[560px] rounded-full bg-gradient-to-br from-indigo-200/70 via-indigo-100/40 to-transparent blur-3xl"></div>
    </div>
    <div class="relative min-h-screen flex flex-col">
        <header class="top-nav-blur sticky top-0 z-40">
            <div class="mx-auto flex max-w-7xl items-center justify-between gap-4 px-5 py-4 sm:px-8">
                <div class="flex items-center gap-3">
                    <div class="flex h-11 w-11 items-center justify-center rounded-2xl bg-gradient-to-br from-amber-400 via-amber-500 to-indigo-500 text-white shadow-brand">
                        <span class="text-xl">🍽️</span>
                    </div>
                    <div class="flex flex-col text-left">
                        <span class="text-[0.65rem] uppercase tracking-[0.35em] text-slate-500">오늘 뭐 먹지?</span>
                        <span class="font-brand text-lg font-bold text-brand-slate sm:text-xl">Lunch Roulette Lab</span>
                    </div>
                </div>
                <nav class="hidden items-center gap-2 sm:flex">
                    <button id="home-btn" data-home-trigger class="mode-button rounded-full bg-white/40 px-5 py-2 text-sm font-semibold text-slate-700 shadow-brandSoft hover:bg-white/60">🏠 홈</button>
                    <button class="mode-button rounded-full bg-white/30 px-4 py-2 text-sm font-semibold shadow-brandSoft hover:bg-white/50" data-mode-target="location">📍 위치</button>
                    <button class="mode-button rounded-full bg-white/30 px-4 py-2 text-sm font-semibold shadow-brandSoft hover:bg-white/50" data-mode-target="team">🤝 팀</button>
                    <button class="mode-button rounded-full bg-white/30 px-4 py-2 text-sm font-semibold shadow-brandSoft hover:bg-white/50" data-mode-target="custom">🎨 커스텀</button>
                    <button class="mode-button rounded-full bg-white/30 px-4 py-2 text-sm font-semibold shadow-brandSoft hover:bg-white/50" data-mode-target="race">🏇 경마</button>
                    <button class="mode-button rounded-full bg-white/20 px-4 py-2 text-sm font-semibold shadow-brandSoft hover:bg-white/35">⚙️ 설정</button>
                </nav>
            </div>
        </header>
        <main class="flex-1">
            <section id="landing-screen" class="px-5 py-14 sm:px-8 sm:py-20">
                <div class="mx-auto flex max-w-6xl flex-col gap-12 rounded-3xl bg-white/40 p-8 shadow-[0_35px_80px_-50px_rgba(15,23,42,0.45)] backdrop-blur-xl sm:p-12 lg:flex-row">
                    <div class="flex-1 space-y-6 text-left">
                        <span class="mode-chip text-amber-600/90">오늘의 점심 파트너</span>
                        <h1 class="font-brand text-4xl font-bold leading-tight text-slate-900 sm:text-5xl">오늘 뭐 먹지? <br class="hidden sm:block" /><span class="bg-gradient-to-r from-amber-400 via-amber-500 to-indigo-500 bg-clip-text text-transparent">멀티 플레이 룰렛</span></h1>
                        <p class="text-base leading-relaxed text-slate-600 sm:text-lg">점심 정하기 게임 허브. 모드별 인터랙션을 즐기며 팀과 함께 플레이하거나, 나만의 룰렛을 만들어 공유할 수 있어요.</p>
                        <div class="flex flex-wrap items-center gap-2 text-sm text-slate-500">
                            <span class="inline-flex items-center gap-2 rounded-full bg-white/60 px-3 py-1 font-semibold text-amber-600 shadow-sm">✨ Micro Interaction</span>
                            <span class="inline-flex items-center gap-2 rounded-full bg-white/60 px-3 py-1 font-semibold text-indigo-600 shadow-sm">🪟 Glassmorphism</span>
                            <span class="inline-flex items-center gap-2 rounded-full bg-white/60 px-3 py-1 font-semibold text-slate-600 shadow-sm">🌈 Amber · Slate · Indigo</span>
                        </div>
                    </div>
                    <div class="flex-1 space-y-5">
                        <div class="grid gap-4 sm:grid-cols-2">
                            <button class="mode-button mode-button-location flex items-center justify-between rounded-2xl px-5 py-5 text-left" data-mode-target="location">
                                <div class="space-y-1.5">
                                    <span class="mode-button-badge">MODE 01</span>
                                    <p class="mode-button-title">📍 위치기반</p>
                                    <p class="mode-button-subtitle text-sm">주변 맛집을 탐색하고 자동으로 룰렛을 채웁니다.</p>
                                </div>
                                <span class="mode-button-arrow text-3xl text-slate-200">➜</span>
                            </button>
                            <button class="mode-button mode-button-team flex items-center justify-between rounded-2xl px-5 py-5 text-left" data-mode-target="team">
                                <div class="space-y-1.5">
                                    <span class="mode-button-badge">MODE 02</span>
                                    <p class="mode-button-title">🤝 팀플레이</p>
                                    <p class="mode-button-subtitle text-sm">엑세스 코드로 연결해 한 번에 룰렛을 완성해요.</p>
                                </div>
                                <span class="mode-button-arrow text-3xl text-slate-200">➜</span>
                            </button>
                            <button class="mode-button mode-button-custom flex items-center justify-between rounded-2xl px-5 py-5 text-left" data-mode-target="custom">
                                <div class="space-y-1.5">
                                    <span class="mode-button-badge">MODE 03</span>
                                    <p class="mode-button-title">🎨 커스텀</p>
                                    <p class="mode-button-subtitle text-sm">룰렛을 직접 꾸미고 커뮤니티에 공유해 보세요.</p>
                                </div>
                                <span class="mode-button-arrow text-3xl text-slate-200">➜</span>
                            </button>
                            <button class="mode-button mode-button-race flex items-center justify-between rounded-2xl px-5 py-5 text-left" data-mode-target="race">
                                <div class="space-y-1.5">
                                    <span class="mode-button-badge">MODE 04</span>
                                    <p class="mode-button-title">🏇 경마 모드</p>
                                    <p class="mode-button-subtitle text-sm">몰입감 있는 애니메이션으로 커피 내기를 결정!</p>
                                </div>
                                <span class="mode-button-arrow text-3xl text-slate-200">➜</span>
                            </button>
                        </div>
                        <div class="rounded-2xl bg-white/60 p-5 shadow-brandSoft">
                            <p class="flex items-center gap-2 text-sm font-semibold text-slate-700"><span class="text-lg">💡</span>모드 전환 가이드</p>
                            <p class="mt-2 text-sm leading-relaxed text-slate-600">각 모드는 독립된 섹션으로 구성되어 부드럽게 페이드/슬라이드 전환됩니다. 모바일에서는 하단 플로팅 탭으로 빠르게 이동할 수 있어요.</p>
                        </div>
                    </div>
                </div>
            </section>

            <section id="app-shell" class="hidden flex-1 px-5 py-12 sm:px-8">
            <div class="mx-auto flex w-full max-w-7xl flex-col gap-10">
                <div class="glass-card flex flex-col gap-6 rounded-3xl border border-white/40 bg-white/50 p-6 shadow-brandSoft backdrop-blur-lg sm:p-8">
                    <div class="flex flex-col gap-6 lg:flex-row lg:items-center lg:justify-between">
                        <div class="space-y-3 text-left">
                            <span class="mode-chip text-indigo-600/80">Active Mode</span>
                            <h2 class="text-3xl font-bold text-slate-900 sm:text-4xl">모드를 바꿔가며 다양한 점심 아이디어를 만나보세요</h2>
                            <p id="mode-description" class="text-sm text-slate-600 sm:text-base">현재 위치를 기반으로 주변 식당 후보를 자동으로 채워 드립니다.</p>
                        </div>
                        <div class="flex flex-wrap items-center justify-end gap-2">
                            <button class="mode-button mode-tab inline-flex items-center justify-center rounded-full bg-white/70 px-4 py-2 text-sm font-semibold text-slate-600 shadow-brandSoft transition-all hover:bg-white/90" data-mode-target="location">📍 위치</button>
                            <button class="mode-button mode-tab inline-flex items-center justify-center rounded-full bg-white/70 px-4 py-2 text-sm font-semibold text-slate-600 shadow-brandSoft transition-all hover:bg-white/90" data-mode-target="team">🤝 팀</button>
                            <button class="mode-button mode-tab inline-flex items-center justify-center rounded-full bg-white/70 px-4 py-2 text-sm font-semibold text-slate-600 shadow-brandSoft transition-all hover:bg-white/90" data-mode-target="custom">🎨 커스텀</button>
                            <button class="mode-button mode-tab inline-flex items-center justify-center rounded-full bg-white/70 px-4 py-2 text-sm font-semibold text-slate-600 shadow-brandSoft transition-all hover:bg-white/90" data-mode-target="race">🏇 경마</button>
                        </div>
                    </div>
                    <div class="flex flex-wrap items-center gap-3 text-xs text-slate-500">
                        <span class="inline-flex items-center gap-2 rounded-full bg-white/70 px-3 py-1 font-semibold text-indigo-500">🏠 홈 버튼은 상단 바에서 언제든 접근 가능</span>
                        <span class="inline-flex items-center gap-2 rounded-full bg-white/70 px-3 py-1 font-semibold text-amber-600">🔁 전환 시 페이드 &amp; 슬라이드</span>
                    </div>
                </div>
                <div class="flex flex-col gap-6 xl:flex-row">
                    <aside class="w-full xl:w-72 space-y-6">
                        <div id="restaurant-list-container" data-mode-visible="location" class="mode-panel mode-hidden rounded-3xl border border-white/40 bg-white/70 p-5 shadow-brandSoft backdrop-blur-md">
                            <div class="flex items-center justify-between mb-3">
                                <h3 class="text-xl font-bold text-gray-900">오늘의 후보</h3>
                                <span class="text-xs font-semibold text-amber-600 bg-amber-100 px-2 py-0.5 rounded-full">자동 추천</span>
                            </div>
                            <div id="candidate-lists-wrapper" class="space-y-4"></div>
                        </div>

                        <div id="team-card" data-mode-visible="team" class="mode-panel mode-hidden rounded-3xl border border-white/40 bg-white/70 p-5 shadow-brandSoft backdrop-blur-md space-y-4">
                            <div class="text-center space-y-1">
                                <h3 class="text-xl font-bold text-gray-900">🤝 팀플레이</h3>
                                <p class="text-xs text-gray-500">같은 엑세스 코드로 접속하면 하나의 룰렛을 함께 채울 수 있어요.</p>
                            </div>
                            <div class="flex flex-col sm:flex-row gap-2">
                                <input id="team-access-input" type="text" placeholder="엑세스 코드 (영문/숫자)" class="border rounded px-3 py-2 text-sm flex-1">
                                <button id="team-join-btn" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded-md">참여하기</button>
                                <button id="team-leave-btn" class="hidden bg-slate-500 hover:bg-slate-600 text-white font-bold py-2 px-4 rounded-md">나가기</button>
                            </div>
                            <p id="team-status" class="text-xs text-center text-slate-500">엑세스 코드를 입력하면 팀이 생성되거나 입장됩니다.</p>
                            <div class="flex flex-col items-center gap-1 text-xs text-slate-500">
                                <label for="team-slot-count" class="font-semibold text-gray-600">룰렛 칸 수</label>
                                <input id="team-slot-count" type="number" min="2" max="9" value="9" disabled class="w-20 border rounded px-2 py-1 text-sm text-center opacity-60 cursor-not-allowed">
                                <p class="text-[11px] text-slate-400">최소 2칸 · 최대 9칸</p>
                            </div>
                            <div id="team-slots-container" class="space-y-2 hidden"></div>
                        </div>

                        <div id="race-summary-card" data-mode-visible="race" class="mode-panel mode-hidden rounded-3xl border border-white/40 bg-white/70 p-5 shadow-brandSoft backdrop-blur-md space-y-4">
                            <div class="text-center space-y-1">
                                <h3 class="text-xl font-bold text-gray-900">🏆 우승 기록</h3>
                                <p class="text-xs text-gray-500">가장 많이 우승한 말들을 확인하세요.</p>
                            </div>
                            <div class="space-y-3" data-race-summary>
                                <p class="text-sm text-slate-500">아직 경마 기록이 없습니다.</p>
                            </div>
                        </div>
                    </aside>

                    <section class="flex-1 space-y-6">
                        <div class="mode-panel rounded-3xl border border-white/40 bg-white/75 p-6 sm:p-8 shadow-brandSoft backdrop-blur-lg space-y-6" data-mode-visible="location,team,custom">
                            <div class="space-y-4 text-center">
                                <span id="active-mode-badge" class="inline-flex items-center justify-center gap-2 px-4 py-1 rounded-full bg-slate-100 text-sm font-semibold text-slate-600">📍 위치기반 모드</span>
                                <h3 class="text-3xl font-bold text-gray-900">오늘 뭐 먹지?</h3>
                                <p id="status-message" class="text-gray-600 min-h-[1.5rem]">모드를 선택해 주세요.</p>
                                <div id="location-fallback" data-mode-visible="location" class="hidden mode-hidden mt-2 flex flex-wrap items-center justify-center gap-2 text-sm">
                                    <span class="text-gray-500">위치 접근이 어렵다면?</span>
                                    <label class="flex items-center gap-2">
                                        <span class="text-gray-600">동네 선택</span>
                                        <select id="manual-location-select" class="border rounded px-2 py-1 text-sm">
                                            <option value="">동네를 골라주세요</option>
                                            <option value="37.4979,127.0276">서울 강남역</option>
                                            <option value="37.5575,126.9249">서울 홍대입구</option>
                                            <option value="37.4021,127.1089">경기 판교</option>
                                            <option value="35.1576,129.0591">부산 서면</option>
                                            <option value="35.8714,128.6014">대구 동성로</option>
                                            <option value="35.1796,129.0756">부산 남포동</option>
                                        </select>
                                    </label>
                                    <button id="apply-manual-location" class="bg-amber-500 hover:bg-amber-600 text-white font-semibold px-3 py-1 rounded-md">이 동네로 보기</button>
                                </div>
                            </div>

                            <div id="location-game-stage" class="flex flex-col items-center gap-6">
                                <div id="roulette-stage" data-game-stage="roulette" class="game-stage flex justify-center">
                                    <div class="roulette-container">
                                        <div class="pointer"></div>
                                        <canvas id="rouletteCanvas"></canvas>
                                    </div>
                                </div>
                                <div id="ladder-stage" data-game-stage="ladder" class="game-stage hidden w-full max-w-2xl">
                                    <div class="ladder-wrapper">
                                        <canvas id="ladderCanvas"></canvas>
                                        <p id="ladder-result-text" class="text-sm text-slate-600 text-center">사다리타기 결과가 여기 표시됩니다.</p>
                                    </div>
                                </div>
                                <div id="ball-stage" data-game-stage="ball" class="game-stage hidden w-full max-w-2xl space-y-3">
                                    <div id="ball-pool" class="ball-pool"></div>
                                    <p id="ball-result-text" class="text-sm text-slate-600 text-center">공을 뽑으면 결과가 여기 표시됩니다.</p>
                                </div>
                            </div>

                            <div id="winner-card" class="hidden w-full max-w-xl mx-auto bg-slate-50 border border-slate-100 rounded-xl shadow-inner p-5 space-y-3">
                                <div class="flex items-start justify-between">
                                    <div>
                                        <p class="text-sm font-semibold text-green-600">오늘의 당첨!</p>
                                        <h4 id="winner-name" class="text-2xl font-bold text-gray-800"></h4>
                                    </div>
                                    <span id="winner-tag" class="text-xs bg-green-100 text-green-700 px-2 py-1 rounded-full">행운 가득</span>
                                </div>
                                <div class="space-y-2 text-sm text-gray-600">
                                    <p id="winner-address" class="flex items-center gap-2"></p>
                                    <p id="winner-phone" class="flex items-center gap-2"></p>
                                    <p id="winner-tip" class="flex items-center gap-2 text-xs text-gray-500"></p>
                                </div>
                                <div class="flex flex-wrap gap-2">
                                    <a id="winner-map-btn" class="flex-1 text-center bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 rounded-md" target="_blank" rel="noopener">길찾기</a>
                                    <a id="winner-call-btn" class="flex-1 text-center bg-emerald-500 hover:bg-emerald-600 text-white font-semibold py-2 rounded-md" target="_blank" rel="noopener">전화하기</a>
                                </div>
                                <button id="winner-reroll" class="w-full bg-gray-900 hover:bg-gray-700 text-white font-bold py-2 rounded-md">다시 돌리기</button>
                            </div>

                            <div class="space-y-4">
                                <div data-mode-visible="location" class="mode-hidden">
                                    <div class="bg-slate-50 border border-slate-200 rounded-xl p-4 space-y-4 text-left">
                                        <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                                            <label for="mode-select" class="font-semibold text-gray-700 flex items-center gap-2">
                                                추천 방식
                                                <span class="text-xs bg-slate-100 text-slate-500 px-2 py-0.5 rounded-full">평점/리뷰 기반 추천은 준비 중</span>
                                            </label>
                                            <select id="mode-select" class="rounded-md border-gray-300 shadow-sm">
                                                <option value="mix" selected>🍱 추천 믹스</option>
                                                <option value="distance">🚶‍♂️ 가까운 순 9곳</option>
                                                <option value="random">🎲 랜덤 9</option>
                                            </select>
                                        </div>
                                        <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                                            <label for="location-game-select" class="font-semibold text-gray-700 flex items-center gap-2">
                                                게임 방식
                                                <span class="text-xs bg-slate-100 text-slate-500 px-2 py-0.5 rounded-full">룰렛 · 사다리 · 공 뽑기</span>
                                            </label>
                                            <select id="location-game-select" class="rounded-md border-gray-300 shadow-sm">
                                                <option value="roulette">🎡 룰렛</option>
                                                <option value="ladder">🎯 사다리타기</option>
                                                <option value="ball">🔮 공 뽑기</option>
                                            </select>
                                        </div>
                                        <p id="location-game-hint" class="location-game-hint text-xs text-slate-500 px-3 py-2 rounded-lg">
                                            같은 후보로 원하는 게임을 선택해 점심 메뉴를 정할 수 있어요.
                                        </p>
                                        <div id="reset-default-slot">
                                            <div id="reset-btn-wrapper">
                                                <button id="resetBtn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 rounded-full shadow-lg">다시 불러오기</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div id="start-default-slot">
                                    <div id="start-btn-wrapper" class="flex flex-wrap justify-center gap-3">
                                        <button id="startBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-10 rounded-full shadow-lg" disabled>START</button>
                                    </div>
                                </div>

                                <div id="save-container" class="hidden">
                                    <div class="bg-slate-50 border border-slate-200 rounded-xl p-4">
                                        <div class="flex flex-col sm:flex-row sm:items-center sm:space-x-2 gap-2">
                                            <input type="text" id="roulette-name-input" placeholder="룰렛 이름 입력" class="border rounded px-3 py-2 flex-grow">
                                            <button id="saveBtn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-md">저장</button>
                                        </div>
                                        <p class="text-xs text-gray-500 mt-3 text-center">마음에 드는 룰렛이 나오면 소장해두고 계속 사용해보세요!</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="race-panel" data-mode-visible="race" class="mode-panel mode-hidden rounded-3xl border border-white/40 bg-white/75 p-6 sm:p-8 shadow-brandSoft backdrop-blur-lg space-y-6">
                            <div class="space-y-2 text-center">
                                <span class="inline-flex items-center justify-center gap-2 px-4 py-1 rounded-full bg-amber-100 text-sm font-semibold text-amber-600">🏇 MODE 04</span>
                                <h3 class="text-3xl font-bold text-gray-900">커피 내기 경마 트랙</h3>
                                <p id="race-status-label" class="text-gray-600 min-h-[1.5rem]">출전할 말을 선택해 주세요.</p>
                            </div>

                            <div class="grid gap-6 lg:grid-cols-2">
                                <div class="space-y-5">
                                    <div class="space-y-3">
                                        <label class="flex items-center justify-between text-sm font-semibold text-slate-700">
                                            출전 말 수
                                            <span class="text-xs text-slate-400">최소 2두 · 최대 10두</span>
                                        </label>
                                        <div class="flex items-center gap-3">
                                            <input id="race-horse-count-input" type="number" min="2" max="10" value="5" class="w-20 border rounded-md px-3 py-2 text-sm">
                                            <input id="race-horse-count-range" type="range" min="2" max="10" value="5" class="flex-1">
                                        </div>
                                    </div>

                                    <div class="space-y-3">
                                        <div class="flex items-center justify-between">
                                            <h4 class="font-semibold text-gray-800">말 선택</h4>
                                            <span id="race-selected-counter" class="text-xs text-slate-500">0 / 10</span>
                                        </div>
                                        <p class="text-xs text-slate-500">즐겨 찾는 말 10두 가운데에서 레이스에 내보낼 말을 골라 주세요.</p>
                                        <div id="race-horse-list" class="grid grid-cols-2 gap-2"></div>
                                    </div>
                                </div>

                                <div class="space-y-5">
                                    <div class="bg-slate-50 border border-slate-200 rounded-xl p-4 space-y-4">
                                        <div class="flex items-center justify-between">
                                            <span class="text-sm font-semibold text-slate-600">레이스 진행 상황</span>
                                            <span id="race-timer" class="text-xs text-slate-500">00:00</span>
                                        </div>
                                        <div id="race-track" class="race-track-lanes"></div>
                                        <div id="race-controls-container" class="space-y-3">
                                            <div class="text-xs text-slate-500">START를 누르면 모든 말이 출발해요. 경기가 끝날 때까지 UI가 잠깁니다.</div>
                                            <div id="race-controls-slot" class="flex flex-wrap justify-center gap-3"></div>
                                        </div>
                                    </div>

                                    <div id="race-results" class="hidden bg-slate-900 text-white rounded-xl p-5 space-y-3">
                                        <div class="flex items-center justify-between">
                                            <h4 class="text-lg font-semibold">결과 발표</h4>
                                            <span class="text-xs uppercase tracking-widest text-amber-300">Finish</span>
                                        </div>
                                        <ol id="race-results-list" class="space-y-2 text-sm"></ol>
                                        <button id="race-again-btn" class="hidden w-full bg-amber-500 hover:bg-amber-600 text-white font-semibold py-2 rounded-full">다시 달리기</button>
                                        <p class="text-xs text-amber-200 text-center">우승 기록은 저장되어 다음 레이스에도 반영돼요.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <aside id="custom-panels" data-mode-visible="custom" class="mode-panel mode-hidden w-full xl:w-96 space-y-6">
                        <div class="rounded-3xl border border-white/40 bg-white/70 p-5 shadow-brandSoft backdrop-blur-md">
                            <h3 class="text-xl font-bold text-center mb-2">나의 룰렛 목록</h3>
                            <div id="saved-roulettes-list" class="h-48 overflow-y-auto custom-scrollbar"></div>
                        </div>
                        <div class="rounded-3xl border border-white/40 bg-white/70 p-5 shadow-brandSoft backdrop-blur-md space-y-4">
                            <div class="text-center space-y-1">
                                <h3 class="text-xl font-bold text-gray-900">📝 직접 차트 만들기</h3>
                                <p class="text-xs text-gray-500">원하는 칸 수(최소 2칸 ~ 최대 9칸)로 자유롭게 채워보세요. 비어 있는 칸은 자동으로 ‘다시 한 번’으로 채워집니다.</p>
                            </div>
                            <div class="space-y-2">
                                <div class="flex items-center justify-between text-sm font-semibold text-slate-700">
                                    <span>룰렛 칸 수</span>
                                    <div class="flex items-center gap-2">
                                        <input id="custom-slot-count" type="range" min="2" max="9" value="9" class="w-32">
                                        <span id="custom-slot-count-display" class="text-xs text-slate-500">9칸</span>
                                    </div>
                                </div>
                                <p class="text-[11px] text-slate-400 text-right">슬라이더를 움직여 칸 수를 조절하세요.</p>
                            </div>
                            <div class="grid grid-cols-2 gap-2">
                                <button class="sample-template-btn bg-slate-200 hover:bg-slate-300 text-gray-700 text-sm font-semibold py-2 rounded" data-template="korean">한식 샘플</button>
                                <button class="sample-template-btn bg-slate-200 hover:bg-slate-300 text-gray-700 text-sm font-semibold py-2 rounded" data-template="noodle">면 요리 샘플</button>
                                <button class="sample-template-btn bg-slate-200 hover:bg-slate-300 text-gray-700 text-sm font-semibold py-2 rounded" data-template="office">직장인 빠른 점심</button>
                                <button class="sample-template-btn bg-slate-200 hover:bg-slate-300 text-gray-700 text-sm font-semibold py-2 rounded" data-template="snack">분식 인기 메뉴</button>
                            </div>
                            <div id="custom-chart-inputs" class="grid grid-cols-2 sm:grid-cols-3 gap-2"></div>
                            <button id="apply-custom-btn" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 rounded-md">적용하기</button>
                        </div>
                        <div class="rounded-3xl border border-white/40 bg-white/70 p-5 shadow-brandSoft backdrop-blur-md space-y-3">
                            <div class="text-center space-y-1">
                                <h3 class="text-xl font-bold text-gray-900">👑 룰렛 자랑하기</h3>
                                <p class="text-xs text-gray-500">좋아요가 많은 순서대로 보여드려요. 싫어요가 많은 글은 운영자가 확인 후 숨깁니다.</p>
                            </div>
                            <input type="search" id="search-shared" placeholder="예: (역삼) 족발" class="w-full rounded-xl border border-white/60 bg-white/90 px-3 py-2 text-sm shadow-inner focus:border-amber-200 focus:outline-none focus:ring-2 focus:ring-amber-200/60">
                            <div id="shared-roulettes-list" class="h-[430px] overflow-y-auto custom-scrollbar"></div>
                        </div>
                    </aside>
                </div>
            </div>
        </section>
        </main>
        <nav id="mobile-mode-nav" class="floating-nav fixed bottom-6 left-1/2 z-40 flex w-[92%] max-w-md -translate-x-1/2 items-center justify-between gap-1 px-2 py-2 sm:hidden hidden">
            <button data-home-trigger aria-label="홈으로 이동" class="mode-button inline-flex h-10 w-10 items-center justify-center rounded-full bg-white/15 text-base">🏠</button>
            <button class="mode-button inline-flex h-10 w-10 items-center justify-center rounded-full bg-white/12 text-base" data-mode-target="location" aria-label="위치 모드">📍</button>
            <button class="mode-button inline-flex h-10 w-10 items-center justify-center rounded-full bg-white/12 text-base" data-mode-target="team" aria-label="팀 모드">🤝</button>
            <button class="mode-button inline-flex h-10 w-10 items-center justify-center rounded-full bg-white/12 text-base" data-mode-target="custom" aria-label="커스텀 모드">🎨</button>
            <button class="mode-button inline-flex h-10 w-10 items-center justify-center rounded-full bg-white/12 text-base" data-mode-target="race" aria-label="경마 모드">🏇</button>
            <button class="mode-button inline-flex h-10 w-10 items-center justify-center rounded-full bg-white/12 text-base" aria-label="설정">⚙️</button>
        </nav>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, doc, getDoc, setDoc, deleteDoc, query, orderBy, serverTimestamp, updateDoc, increment, arrayUnion, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- UI 요소 ---
        const canvas = document.getElementById('rouletteCanvas');
        const ctx = canvas.getContext('2d');
        const resetBtn = document.getElementById('resetBtn');
        const startBtn = document.getElementById('startBtn');
        const saveBtn = document.getElementById('saveBtn');
        const statusMessage = document.getElementById('status-message');
        const saveContainer = document.getElementById('save-container');
        const rouletteNameInput = document.getElementById('roulette-name-input');
        const savedRoulettesList = document.getElementById('saved-roulettes-list');
        const restaurantListContainer = document.getElementById('restaurant-list-container');
        const candidateListsWrapper = document.getElementById('candidate-lists-wrapper');
        const modeSelect = document.getElementById('mode-select');
        const locationGameSelect = document.getElementById('location-game-select');
        const locationGameHint = document.getElementById('location-game-hint');
        const gameStageContainers = document.querySelectorAll('[data-game-stage]');
        const ladderCanvas = document.getElementById('ladderCanvas');
        const ladderResultText = document.getElementById('ladder-result-text');
        const ballPool = document.getElementById('ball-pool');
        const ballResultText = document.getElementById('ball-result-text');
        const sharedRoulettesList = document.getElementById('shared-roulettes-list');
        const searchSharedInput = document.getElementById('search-shared');
        const applyCustomBtn = document.getElementById('apply-custom-btn');
        const locationFallback = document.getElementById('location-fallback');
        const manualLocationSelect = document.getElementById('manual-location-select');
        const applyManualLocationBtn = document.getElementById('apply-manual-location');
        const winnerCard = document.getElementById('winner-card');
        const winnerName = document.getElementById('winner-name');
        const winnerAddress = document.getElementById('winner-address');
        const winnerPhone = document.getElementById('winner-phone');
        const winnerTip = document.getElementById('winner-tip');
        const winnerMapBtn = document.getElementById('winner-map-btn');
        const winnerCallBtn = document.getElementById('winner-call-btn');
        const winnerRerollBtn = document.getElementById('winner-reroll');
        const winnerTag = document.getElementById('winner-tag');
        const teamAccessInput = document.getElementById('team-access-input');
        const teamJoinBtn = document.getElementById('team-join-btn');
        const teamLeaveBtn = document.getElementById('team-leave-btn');
        const teamStatus = document.getElementById('team-status');
        const teamSlotsContainer = document.getElementById('team-slots-container');
        const landingScreen = document.getElementById('landing-screen');
        const landingScreenMobile = document.getElementById('landing-screen-mobile');
        const appShell = document.getElementById('app-shell');
        const activeModeBadge = document.getElementById('active-mode-badge');
        const modeDescription = document.getElementById('mode-description');
        const modeButtons = document.querySelectorAll('[data-mode-target]');
        const modeScopedElements = document.querySelectorAll('[data-mode-visible]');
        const homeButtons = document.querySelectorAll('[data-home-trigger]');
        const mobileModeNav = document.getElementById('mobile-mode-nav');
        const racePanel = document.getElementById('race-panel');
        const raceHorseCountInput = document.getElementById('race-horse-count-input');
        const raceHorseCountRange = document.getElementById('race-horse-count-range');
        const raceHorseList = document.getElementById('race-horse-list');
        const raceSelectedCounter = document.getElementById('race-selected-counter');
        const raceTrack = document.getElementById('race-track');
        const raceStatusLabel = document.getElementById('race-status-label');
        const raceTimer = document.getElementById('race-timer');
        const raceResults = document.getElementById('race-results');
        const raceResultsList = document.getElementById('race-results-list');
        const raceAgainBtn = document.getElementById('race-again-btn');
        const raceControlsSlot = document.getElementById('race-controls-slot');
        const raceControlsContainer = document.getElementById('race-controls-container');
        const startDefaultSlot = document.getElementById('start-default-slot');
        const resetDefaultSlot = document.getElementById('reset-default-slot');
        const startBtnWrapper = document.getElementById('start-btn-wrapper');
        const resetBtnWrapper = document.getElementById('reset-btn-wrapper');
        const raceSummaryNodes = document.querySelectorAll('[data-race-summary]');
        const teamSlotCountInput = document.getElementById('team-slot-count');
        const customSlotCountInput = document.getElementById('custom-slot-count');
        const customSlotCountDisplay = document.getElementById('custom-slot-count-display');
        const customChartInputs = document.getElementById('custom-chart-inputs');

        // --- 전역 변수 ---
        const MIN_SEGMENT_COUNT = 2;
        const MAX_SEGMENT_COUNT = 9;
        const DEFAULT_SEGMENT_COUNT = 9;
        let segmentCount = DEFAULT_SEGMENT_COUNT;
        const colors = ['#fde68a', '#dcfce7', '#dbeafe', '#f3e8ff', '#fee2e2', '#fef3c7', '#e0f2fe', '#fce7f3', '#e5e7eb'];
        let restaurants = [];
        let isSpinning = false;
        let winnerIndex = -1;
        let locationGameType = 'roulette';
        let isLadderRunning = false;
        let isBallDrawing = false;
        let ballAnimationTimeouts = [];
        let blinkAnimationId;
        let db, auth, userId;
        let lastKnownCoords = null;
        let allSharedRoulettes = [];
        let teamMode = false;
        let teamCode = '';
        let teamDocRef = null;
        let teamUnsubscribe = null;
        let teamSlots = Array.from({ length: segmentCount }, () => '');
        let lastTeamSpinTrigger = '';
        let teamSnapshotInitialized = false;
        let customSegmentCount = DEFAULT_SEGMENT_COUNT;
        const startBtnDefaultLabel = startBtn ? startBtn.textContent.trim() : 'START';
        const resetBtnDefaultLabel = resetBtn ? resetBtn.textContent.trim() : 'RESET';

        const RACE_BASE_DURATION = 60000;
        const RACE_MAX_EXTRA_DURATION = 12000;
        const RACE_HORSE_LIMIT = 10;
        const RACE_EVENT_BASE_CHANCE = 0.00009;
        const RACE_EVENT_BASE_COOLDOWN = 1600;
        const RACE_BASE_SPEED_FACTOR = 0.9;
        const HORSE_PERSONALITIES = {
            default: {
                name: '밸런스형',
                tagline: '언제나 평균적인 주행을 보여줘요.',
                randomness: 0.04,
                eventFrequency: 1,
                boostBias: 0.55,
                boostSpeedMultiplier: 1.5,
                stumbleSpeedMultiplier: 0.1,
                burstBonus: 1,
                effectDurationModifier: 1,
                eventCooldown: 1500
            },
            explosive: {
                name: '폭발형',
                tagline: '스타트부터 전력질주! 후반엔 숨이 찰 수도 있어요.',
                randomness: 0.05,
                eventFrequency: 1.1,
                boostBias: 0.6,
                boostSpeedMultiplier: 1.6,
                stumbleSpeedMultiplier: 0.08,
                fastStart: { until: 0.4, bonus: 1.35 },
                fatigue: { from: 0.7, penalty: 0.75 },
                burstBonus: 1.1,
                messages: {
                    boost: ['폭발적인 가속! 🔥', '부스터 온! ⚡'],
                    stumble: ['숨 고르기 중...', '속도를 조절합니다.']
                }
            },
            steady: {
                name: '꾸준형',
                tagline: '큰 파동 없이 꾸준히 달려요.',
                randomness: 0.02,
                eventFrequency: 0.65,
                boostBias: 0.55,
                boostSpeedMultiplier: 1.4,
                stumbleSpeedMultiplier: 0.12,
                baseDurationMultiplier: 0.98,
                messages: {
                    boost: ['꾸준히 속도 UP!'],
                    stumble: ['호흡을 가다듬는 중']
                }
            },
            slowStarter: {
                name: '슬로우 스타터',
                tagline: '초반엔 느리지만 후반 폭발!',
                randomness: 0.04,
                eventFrequency: 1.1,
                boostBias: 0.68,
                boostSpeedMultiplier: 1.75,
                stumbleSpeedMultiplier: 0.1,
                slowStart: { until: 0.35, penalty: 0.6 },
                lateSurge: { from: 0.55, multiplier: 1.6, eventBonus: 1.3, boostShift: 0.12 },
                messages: {
                    boost: ['후반 스퍼트!', '기어 변속 완료!'],
                    stumble: ['잠깐 비틀!']
                }
            },
            lucky: {
                name: '행운형',
                tagline: '좋은 일이 자주 일어나는 행운의 말!',
                randomness: 0.03,
                eventFrequency: 1.5,
                boostBias: 0.8,
                boostSpeedMultiplier: 1.85,
                stumbleSpeedMultiplier: 0.12,
                burstBonus: 1.2,
                effectDurationModifier: 0.9,
                messages: {
                    boost: ['행운의 바람! 🍀', '럭키 부스터!'],
                    stumble: ['운이 좀 나빠요...']
                }
            },
            volatile: {
                name: '롤러코스터',
                tagline: '컨디션이 널뛰어요. 대박 아니면 쪽박!',
                randomness: 0.09,
                eventFrequency: 1.6,
                boostBias: 0.52,
                boostSpeedMultiplier: 1.7,
                stumbleSpeedMultiplier: 0.05,
                durationVariance: 0.25,
                burstBonus: 1.4,
                effectDurationModifier: 1.1,
                messages: {
                    boost: ['컨디션 폭발! 🔥', '폭풍 질주!'],
                    stumble: ['컨디션 난조! 😵']
                }
            },
            calm: {
                name: '휴식형',
                tagline: '중간중간 숨을 고르며 달려요.',
                randomness: 0.025,
                eventFrequency: 0.9,
                boostBias: 0.45,
                boostSpeedMultiplier: 1.45,
                stumbleSpeedMultiplier: 0.06,
                restWindow: { from: 0.3, to: 0.6, chanceMultiplier: 1.4, boostModifier: 0.7 },
                effectDurationModifier: 1.05,
                messages: {
                    boost: ['차분한 가속!'],
                    stumble: ['숨 고르며 재정비 중']
                }
            },
            wave: {
                name: '파도타기',
                tagline: '리듬을 타며 파도처럼 출렁!',
                randomness: 0.05,
                eventFrequency: 1.0,
                boostBias: 0.6,
                boostSpeedMultiplier: 1.6,
                stumbleSpeedMultiplier: 0.09,
                wave: { frequency: 3, amplitude: 0.05 },
                messages: {
                    boost: ['파도타기 속도 UP! 🌊'],
                    stumble: ['다음 물결 대기...']
                }
            },
            breeze: {
                name: '산들바람',
                tagline: '바람처럼 가볍게 올라타요.',
                randomness: 0.035,
                eventFrequency: 1.05,
                boostBias: 0.62,
                boostSpeedMultiplier: 1.55,
                stumbleSpeedMultiplier: 0.1,
                midRaceBoost: { from: 0.45, to: 0.7, multiplier: 1.2 },
                messages: {
                    boost: ['산들바람의 가속!'],
                    stumble: ['바람이 잦아들었어요.']
                }
            }
        };
        const RACE_BASE_EFFECT_MESSAGES = {
            boost: ['부스터 온! ⚡', '폭풍 질주!', '스퍼트 가동!'],
            stumble: ['돌부리에 걸려 넘어짐! 😵', '잠깐 숨 고르기...', '관중 환호에 멈칫!']
        };
        let allHorses = [
            { id: 'horse-01', name: '번개', icon: '⚡', personality: 'explosive' },
            { id: 'horse-02', name: '질주', icon: '💨', personality: 'steady' },
            { id: 'horse-03', name: '새벽별', icon: '🌟', personality: 'slowStarter' },
            { id: 'horse-04', name: '커피콩', icon: '☕', personality: 'lucky' },
            { id: 'horse-05', name: '모래바람', icon: '🌬️', personality: 'volatile' },
            { id: 'horse-06', name: '달빛', icon: '🌙', personality: 'calm' },
            { id: 'horse-07', name: '토네이도', icon: '🌪️', personality: 'explosive' },
            { id: 'horse-08', name: '파도', icon: '🌊', personality: 'wave' },
            { id: 'horse-09', name: '봄바람', icon: '🌸', personality: 'breeze' },
            { id: 'horse-10', name: '폭죽', icon: '🎆', personality: 'volatile' }
        ];
        let selectedHorseIds = new Set();
        let raceQueue = [];
        let horseWinRecord = {};
        let raceParticipantCount = 5;
        let raceState = createEmptyRaceState();
        let raceStatsLoaded = false;

        const Mode = {
            LOCATION: 'location',
            TEAM: 'team',
            CUSTOM: 'custom',
            RACE: 'race'
        };

        const LOCATION_GAMES = {
            roulette: {
                label: '룰렛',
                readyMessage: '룰렛이 준비되었습니다! START 버튼을 누르세요.',
                manualReadyMessage: '선택한 동네의 후보가 준비되었어요! START 버튼을 눌러주세요.',
                selectMessage: '룰렛 모드로 전환했습니다. START 버튼으로 돌려볼까요?',
                emptyMessage: '룰렛 모드를 선택했습니다. 후보를 불러오면 바로 돌릴 수 있어요.',
                hint: '룰렛으로 빠르게 당첨자를 뽑아보세요.'
            },
            ladder: {
                label: '사다리타기',
                readyMessage: '사다리타기가 준비되었어요! START 버튼으로 사다리를 타보세요.',
                manualReadyMessage: '선택한 동네의 후보로 사다리판을 준비했어요! START 버튼으로 사다리를 타보세요.',
                selectMessage: '사다리타기 모드로 전환했습니다. START 버튼으로 사다리를 타보세요.',
                emptyMessage: '사다리타기를 하려면 후보가 필요해요. 주변 식당을 불러와 볼까요?',
                hint: '랜덤으로 생성된 사다리를 타고 결과를 확인해요.'
            },
            ball: {
                label: '공 뽑기',
                readyMessage: '공 뽑기 준비 완료! 행운의 공을 뽑아볼까요?',
                manualReadyMessage: '선택한 동네의 후보로 공을 준비해두었어요! START 버튼으로 공을 뽑아보세요.',
                selectMessage: '공 뽑기 모드로 전환했습니다. START 버튼으로 공을 뽑아보세요.',
                emptyMessage: '공 뽑기는 두 개 이상의 후보가 필요해요. 후보를 불러와 주세요.',
                hint: '후보 이름이 적힌 공을 굴려 행운의 선택을 만나보세요.'
            }
        };

        const modeMeta = {
            [Mode.LOCATION]: {
                badge: '📍 위치기반 모드',
                description: '현재 위치를 기반으로 주변 식당 후보를 자동으로 채워 드립니다.'
            },
            [Mode.TEAM]: {
                badge: '🤝 팀플레이 모드',
                description: '엑세스 코드를 공유해 팀원과 함께 룰렛을 채우고 동시에 돌려보세요.'
            },
            [Mode.CUSTOM]: {
                badge: '🎨 커스텀 모드',
                description: '나만의 후보를 직접 구성하고 저장하거나 자랑해 보세요.'
            },
            [Mode.RACE]: {
                badge: '🏇 커피 내기 경마',
                description: '말을 선택하고 최소 20초 이상 펼쳐지는 레이스로 커피 내기 우승자를 결정하세요.'
            }
        };

        let currentMode = null;

        function clampSegmentCount(value) {
            const numeric = Number(value);
            if (!Number.isFinite(numeric)) {
                return DEFAULT_SEGMENT_COUNT;
            }
            return Math.max(MIN_SEGMENT_COUNT, Math.min(MAX_SEGMENT_COUNT, Math.round(numeric)));
        }

        function syncTeamSlotCountInput(value) {
            if (teamSlotCountInput) {
                teamSlotCountInput.value = value;
            }
        }

        function syncCustomSlotCountDisplay(value) {
            if (customSlotCountDisplay) {
                customSlotCountDisplay.textContent = `${value}칸`;
            }
        }

        function renderCustomInputs(existingValues = []) {
            if (!customChartInputs) return;
            customChartInputs.innerHTML = '';
            for (let i = 0; i < customSegmentCount; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'custom-input border rounded px-2 py-1 text-sm';
                input.placeholder = `항목 ${i + 1}`;
                input.value = existingValues[i] || '';
                customChartInputs.appendChild(input);
            }
        }

        syncCustomSlotCountDisplay(customSegmentCount);
        renderCustomInputs();
        syncTeamSlotCountInput(segmentCount);
        if (locationGameSelect) {
            locationGameSelect.value = locationGameType;
        }
        updateLocationGameStageVisibility();
        resetLocationGameVisuals();
        if (locationGameHint) {
            const meta = getLocationGameMeta();
            locationGameHint.textContent = `${meta.label} 모드: ${meta.hint}`;
        }

        // --- 초기화 ---
        window.onload = () => {
            const size = Math.min(window.innerWidth * 0.9, 450);
            canvas.width = size;
            canvas.height = size;
            drawWheel();
            initializeRaceModule();
            initializeFirebase();
        };

        function attemptAutoDiscovery() {
            if (currentMode !== Mode.LOCATION) return;
            statusMessage.textContent = '주변 맛집을 모으는 중이에요...';
            candidateListsWrapper.innerHTML = '<p class="text-sm text-gray-400 text-center">주변 후보를 불러오는 중이에요...</p>';
            handleReset({ silent: true });
        }

        // --- 경마 모드 헬퍼 ---
        function createEmptyRaceState() {
            return {
                status: 'idle',
                startTimestamp: null,
                racers: [],
                results: [],
                animationId: null,
                progressElements: new Map(),
                speedLabels: new Map(),
                effectLabels: new Map(),
                durationMap: new Map()
            };
        }

        function getHorsePersonalityMeta(horse) {
            if (!horse) return HORSE_PERSONALITIES.default;
            const key = horse.personality;
            return HORSE_PERSONALITIES[key] || HORSE_PERSONALITIES.default;
        }

        function pickRandomMessage(messages, fallback) {
            if (Array.isArray(messages) && messages.length > 0) {
                return messages[Math.floor(Math.random() * messages.length)];
            }
            return fallback;
        }

        function initializeRaceModule() {
            if (!racePanel) return;
            selectedHorseIds = new Set(allHorses.slice(0, raceParticipantCount).map(horse => horse.id));
            loadHorseWinRecordFromStorage();
            renderHorseWinSummary();
            renderRaceHorseList();
            updateRaceSelectionUI();
            updateRaceTrackParticipants();
        }

        function loadHorseWinRecordFromStorage() {
            try {
                const raw = localStorage.getItem('lunch-race-wins');
                if (raw) {
                    const parsed = JSON.parse(raw);
                    if (parsed && typeof parsed === 'object') {
                        horseWinRecord = { ...horseWinRecord, ...parsed };
                    }
                }
            } catch (error) {
                console.warn('경마 기록 로드 실패:', error);
            }
            allHorses.forEach(horse => {
                if (typeof horseWinRecord[horse.id] !== 'number' || Number.isNaN(horseWinRecord[horse.id])) {
                    horseWinRecord[horse.id] = 0;
                }
            });
        }

        async function loadHorseWinRecordFromRemote() {
            if (!db || raceStatsLoaded) return;
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const statsSnapshot = await getDocs(collection(db, 'artifacts', appId, 'raceStats'));
                statsSnapshot.forEach(docSnap => {
                    const data = docSnap.data() || {};
                    const wins = typeof data.wins === 'number' && !Number.isNaN(data.wins) ? data.wins : 0;
                    horseWinRecord[docSnap.id] = wins;
                    const horseMeta = allHorses.find(horse => horse.id === docSnap.id);
                    if (horseMeta && typeof data.name === 'string' && data.name.trim() !== '') {
                        horseMeta.name = data.name;
                    }
                });
                raceStatsLoaded = true;
                renderHorseWinSummary();
                renderRaceHorseList();
                updateRaceSelectionUI();
            } catch (error) {
                console.error('경마 승수 불러오기 실패:', error);
            }
        }

        function renderHorseWinSummary() {
            if (!raceSummaryNodes || raceSummaryNodes.length === 0) return;
            const summary = allHorses.map(horse => ({
                ...horse,
                wins: horseWinRecord[horse.id] || 0
            })).sort((a, b) => {
                if (b.wins === a.wins) {
                    return a.name.localeCompare(b.name, 'ko');
                }
                return b.wins - a.wins;
            });

            raceSummaryNodes.forEach(node => {
                if (!node) return;
                const hasWinner = summary.some(item => item.wins > 0);
                if (!hasWinner) {
                    node.innerHTML = '<div class="p-4 bg-white border border-slate-200 rounded-2xl shadow-sm text-sm text-slate-500">아직 경마 기록이 없습니다.</div>';
                    return;
                }
                const topThree = summary.slice(0, 3);
                node.innerHTML = `
                    <div class="space-y-2">
                        ${topThree.map((horse, index) => `
                            <div class="flex items-center justify-between bg-white border border-slate-200 rounded-2xl px-3 py-2 shadow-sm">
                                <div class="flex items-center gap-2">
                                    <span class="text-sm font-bold text-amber-600">${index + 1}</span>
                                    <span class="text-sm font-semibold text-slate-700">${horse.icon || '🐎'} ${safeText(horse.name)}</span>
                                </div>
                                <span class="text-xs font-semibold text-slate-500">${horse.wins} 승</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            });
        }

        function renderRaceHorseList() {
            if (!raceHorseList) return;
            raceHorseList.innerHTML = '';
            allHorses.forEach(horse => {
                const personality = getHorsePersonalityMeta(horse);
                const label = document.createElement('label');
                label.className = 'flex items-center gap-3 bg-white border border-slate-200 rounded-xl px-3 py-2 shadow-sm';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'accent-amber-500';
                checkbox.value = horse.id;
                checkbox.checked = selectedHorseIds.has(horse.id);
                checkbox.addEventListener('change', () => handleRaceHorseToggle(horse.id, checkbox.checked));

                const infoWrap = document.createElement('div');
                infoWrap.className = 'flex-1 flex flex-col gap-1';

                const topRow = document.createElement('div');
                topRow.className = 'flex items-center justify-between gap-2';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'text-sm font-semibold text-slate-700';
                nameSpan.textContent = `${horse.icon || '🐎'} ${horse.name}`;

                const winBadge = document.createElement('span');
                winBadge.className = 'text-xs font-semibold text-amber-600 bg-amber-100 px-2 py-0.5 rounded-full';
                winBadge.textContent = `${horseWinRecord[horse.id] || 0} 승`;

                topRow.appendChild(nameSpan);
                topRow.appendChild(winBadge);
                infoWrap.appendChild(topRow);

                if (personality?.tagline) {
                    const traitSpan = document.createElement('span');
                    traitSpan.className = 'text-[11px] text-slate-400';
                    traitSpan.textContent = `[${personality.name}] ${personality.tagline}`;
                    infoWrap.appendChild(traitSpan);
                }

                label.appendChild(checkbox);
                label.appendChild(infoWrap);

                raceHorseList.appendChild(label);
            });
        }

        function setRaceStatus(message) {
            if (raceStatusLabel) {
                raceStatusLabel.textContent = message;
            }
        }

        function updateRaceParticipantInputs() {
            const selectedCount = selectedHorseIds.size;
            const maxParticipants = Math.max(2, Math.min(RACE_HORSE_LIMIT, selectedCount || RACE_HORSE_LIMIT));
            raceParticipantCount = Math.min(raceParticipantCount, maxParticipants);
            const currentValue = Math.max(2, Math.min(raceParticipantCount, maxParticipants));
            if (raceHorseCountInput) {
                raceHorseCountInput.max = maxParticipants;
                raceHorseCountInput.value = currentValue;
            }
            if (raceHorseCountRange) {
                raceHorseCountRange.max = maxParticipants;
                raceHorseCountRange.value = currentValue;
            }
            raceParticipantCount = currentValue;
        }

        function updateRaceSelectionUI() {
            if (!racePanel) return;
            const selectedCount = selectedHorseIds.size;
            if (raceSelectedCounter) {
                raceSelectedCounter.textContent = `${selectedCount} / ${RACE_HORSE_LIMIT}`;
            }
            updateRaceParticipantInputs();
            if (raceState.status === 'idle') {
                if (selectedCount < 2) {
                    setRaceStatus('말을 두 마리 이상 선택해 주세요.');
                } else if (selectedCount < raceParticipantCount) {
                    setRaceStatus('출전 말 수보다 적게 선택했어요. 체크박스를 더 선택해 주세요.');
                } else {
                    setRaceStatus('모든 준비가 끝났어요! START를 눌러 레이스를 시작하세요.');
                }
            }
            updateRaceTrackParticipants();
            updateStartButtonState();
        }

        function handleRaceHorseToggle(horseId, checked) {
            if (checked) {
                selectedHorseIds.add(horseId);
            } else {
                selectedHorseIds.delete(horseId);
            }
            updateRaceSelectionUI();
            updateStartButtonState();
        }

        function setRaceParticipantCount(count) {
            const parsed = Math.max(2, Math.min(RACE_HORSE_LIMIT, Number(count) || 0));
            raceParticipantCount = parsed;
            updateRaceParticipantInputs();
            updateRaceTrackParticipants();
            updateStartButtonState();
            if (raceState.status === 'idle' && selectedHorseIds.size >= raceParticipantCount) {
                setRaceStatus('모든 준비가 끝났어요! START를 눌러 레이스를 시작하세요.');
            }
        }

        function updateRaceTrackParticipants() {
            if (!raceTrack) return;
            raceState.progressElements = new Map();
            raceState.speedLabels = new Map();
            raceState.effectLabels = new Map();
            const selected = Array.from(selectedHorseIds);
            const participants = selected.slice(0, Math.min(raceParticipantCount, selected.length));
            if (participants.length < 2) {
                raceTrack.innerHTML = '<p class="text-sm text-slate-500">말을 두 마리 이상 선택하면 트랙이 준비됩니다.</p>';
                return;
            }
            raceTrack.innerHTML = '';
            participants.forEach((horseId, index) => {
                const horse = allHorses.find(item => item.id === horseId) || { id: horseId, name: horseId, icon: '🐎' };
                const personality = getHorsePersonalityMeta(horse);
                const defaultStatus = personality?.tagline || '';
                const lane = document.createElement('div');
                lane.className = 'race-lane race-lane-horizontal';

                const metaWrapper = document.createElement('div');
                metaWrapper.className = 'race-lane-meta';

                const titleRow = document.createElement('div');
                titleRow.className = 'race-lane-meta-title';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'flex items-center gap-2 text-sm';
                nameSpan.textContent = `${horse.icon || '🐎'} ${horse.name}`;

                const speedSpan = document.createElement('span');
                speedSpan.className = 'race-speed-indicator';
                speedSpan.textContent = '0%';

                titleRow.appendChild(nameSpan);
                titleRow.appendChild(speedSpan);

                const statusMessage = document.createElement('div');
                statusMessage.className = 'race-status-label text-xs text-amber-600 flex items-center gap-1';
                statusMessage.textContent = defaultStatus;

                metaWrapper.appendChild(titleRow);
                metaWrapper.appendChild(statusMessage);

                const progressWrapper = document.createElement('div');
                progressWrapper.className = 'race-lane-progress';

                const progressLabel = document.createElement('span');
                progressLabel.className = 'progress-label';
                progressLabel.textContent = '진행률';

                const trackOuter = document.createElement('div');
                trackOuter.className = 'race-track';

                const trackInner = document.createElement('div');
                trackInner.className = 'race-track-inner';

                const progressFill = document.createElement('div');
                progressFill.className = 'race-track-fill';
                progressFill.style.width = '0%';

                trackInner.appendChild(progressFill);
                trackOuter.appendChild(trackInner);

                const horseIcon = document.createElement('div');
                horseIcon.className = 'race-track-icon';
                horseIcon.textContent = horse.icon || '🐎';
                horseIcon.style.left = '0%';

                trackOuter.appendChild(horseIcon);

                progressWrapper.appendChild(progressLabel);
                progressWrapper.appendChild(trackOuter);

                lane.appendChild(metaWrapper);
                lane.appendChild(progressWrapper);
                raceTrack.appendChild(lane);

                raceState.progressElements.set(horseId, {
                    fill: progressFill,
                    icon: horseIcon,
                    lane
                });
                raceState.speedLabels.set(horseId, speedSpan);
                raceState.effectLabels.set(horseId, {
                    element: statusMessage,
                    defaultText: defaultStatus
                });
            });
        }

        function setRaceInputsDisabled(disabled) {
            if (raceHorseCountInput) raceHorseCountInput.disabled = disabled;
            if (raceHorseCountRange) raceHorseCountRange.disabled = disabled;
            if (raceHorseList) {
                raceHorseList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.disabled = disabled;
                });
            }
            if (disabled) {
                raceControlsContainer?.classList.add('pointer-events-none', 'opacity-60');
            } else {
                raceControlsContainer?.classList.remove('pointer-events-none', 'opacity-60');
            }
        }

        function mountRaceControls() {
            if (!raceControlsSlot) return;
            if (startBtnWrapper && !raceControlsSlot.contains(startBtnWrapper)) {
                raceControlsSlot.appendChild(startBtnWrapper);
            }
            if (resetBtnWrapper && !raceControlsSlot.contains(resetBtnWrapper)) {
                raceControlsSlot.appendChild(resetBtnWrapper);
            }
            if (startBtn) startBtn.textContent = startBtnDefaultLabel;
            if (resetBtn) resetBtn.textContent = 'RESET';
        }

        function unmountRaceControls() {
            if (startDefaultSlot && startBtnWrapper && !startDefaultSlot.contains(startBtnWrapper)) {
                startDefaultSlot.appendChild(startBtnWrapper);
            }
            if (resetDefaultSlot && resetBtnWrapper && !resetDefaultSlot.contains(resetBtnWrapper)) {
                resetDefaultSlot.appendChild(resetBtnWrapper);
            }
            if (startBtn) startBtn.textContent = startBtnDefaultLabel;
            if (resetBtn) resetBtn.textContent = resetBtnDefaultLabel;
        }

        function initRaceMode() {
            mountRaceControls();
            stopRaceAnimation();
            raceQueue = [];
            raceState = createEmptyRaceState();
            raceParticipantCount = Math.min(5, RACE_HORSE_LIMIT);
            selectedHorseIds = new Set(allHorses.slice(0, raceParticipantCount).map(horse => horse.id));
            renderRaceHorseList();
            updateRaceSelectionUI();
            setRaceInputsDisabled(false);
            raceTimer.textContent = '00:00';
            raceResults.classList.add('hidden');
            raceAgainBtn.classList.add('hidden');
            setRaceStatus('출전할 말을 선택해 주세요.');
            updateStartButtonState();
        }

        function resetRaceMode(options = {}) {
            const { keepSelection = false } = options;
            stopRaceAnimation();
            raceState = createEmptyRaceState();
            raceResults.classList.add('hidden');
            raceAgainBtn.classList.add('hidden');
            raceTimer.textContent = '00:00';
            if (!keepSelection) {
                raceParticipantCount = Math.min(5, RACE_HORSE_LIMIT);
                selectedHorseIds = new Set(allHorses.slice(0, raceParticipantCount).map(horse => horse.id));
                renderRaceHorseList();
            }
            updateRaceSelectionUI();
            setRaceInputsDisabled(false);
            if (keepSelection && selectedHorseIds.size >= Math.max(2, raceParticipantCount)) {
                setRaceStatus('같은 구성으로 다시 달릴 준비가 되었어요. START를 눌러주세요!');
            } else {
                setRaceStatus('출전할 말을 선택해 주세요.');
            }
            updateStartButtonState();
        }

        function stopRaceAnimation() {
            if (raceState && raceState.animationId) {
                cancelAnimationFrame(raceState.animationId);
            }
            raceState.animationId = null;
        }

        function teardownRaceMode() {
            stopRaceAnimation();
            setRaceInputsDisabled(false);
            raceState = createEmptyRaceState();
            raceResults?.classList.add('hidden');
            raceAgainBtn?.classList.add('hidden');
            raceTimer.textContent = '00:00';
            unmountRaceControls();
        }

        function formatRaceTime(ms) {
            const totalMs = Math.max(0, Math.floor(ms));
            const seconds = Math.floor(totalMs / 1000);
            const centi = Math.floor((totalMs % 1000) / 10);
            return `${String(seconds).padStart(2, '0')}:${String(centi).padStart(2, '0')}`;
        }

        function buildRaceParticipants() {
            const selected = Array.from(selectedHorseIds);
            const participants = selected.slice(0, Math.min(raceParticipantCount, selected.length));
            return participants.map((horseId, index) => {
                const horse = allHorses.find(item => item.id === horseId) || { id: horseId, name: horseId, icon: '🐎' };
                const personality = getHorsePersonalityMeta(horse);
                const baseDuration = (RACE_BASE_DURATION + Math.random() * RACE_MAX_EXTRA_DURATION) * (personality.baseDurationMultiplier || 1);
                const varianceMultiplier = 1 + ((Math.random() - 0.5) * (personality.durationVariance || 0));
                const duration = Math.max(RACE_BASE_DURATION * 0.6, baseDuration * varianceMultiplier);
                return {
                    horse,
                    progress: 0,
                    duration,
                    randomPhase: Math.random() * Math.PI * 2,
                    finishTime: null,
                    personality,
                    effect: null,
                    nextEventAllowedAt: 0,
                    lastUpdateTimestamp: null
                };
            });
        }

        function applyPersonalitySpeedMultiplier(personality, stage) {
            if (!personality) return 1;
            let multiplier = 1;
            if (personality.slowStart && stage < personality.slowStart.until) {
                multiplier *= personality.slowStart.penalty;
            }
            if (personality.fastStart && stage < personality.fastStart.until) {
                multiplier *= personality.fastStart.bonus;
            }
            if (personality.fatigue && stage > personality.fatigue.from) {
                const fatigueRatio = Math.min(1, (stage - personality.fatigue.from) / Math.max(0.0001, 1 - personality.fatigue.from));
                multiplier *= 1 - (1 - personality.fatigue.penalty) * fatigueRatio;
            }
            if (personality.lateSurge && stage > personality.lateSurge.from) {
                const surgeRatio = Math.min(1, (stage - personality.lateSurge.from) / Math.max(0.0001, 1 - personality.lateSurge.from));
                multiplier *= 1 + (personality.lateSurge.multiplier - 1) * surgeRatio;
            }
            if (personality.midRaceBoost && stage > personality.midRaceBoost.from && stage < personality.midRaceBoost.to) {
                multiplier *= personality.midRaceBoost.multiplier;
            }
            return Math.max(0.1, multiplier);
        }

        function maybeTriggerHorseEvent(racer, delta, stage, timestamp) {
            if (!racer || racer.finishTime) return;
            if (racer.effect || timestamp < racer.nextEventAllowedAt) return;
            const personality = racer.personality || HORSE_PERSONALITIES.default;
            let chance = RACE_EVENT_BASE_CHANCE * (personality.eventFrequency || 1) * delta;
            if (personality.restWindow && stage >= personality.restWindow.from && stage <= personality.restWindow.to) {
                chance *= personality.restWindow.chanceMultiplier || 1.2;
            }
            if (personality.lateSurge && stage >= personality.lateSurge.from) {
                chance *= personality.lateSurge.eventBonus || 1;
            }
            if (stage >= 0.85) {
                chance *= 1.1;
            }
            chance = Math.max(0, Math.min(0.8, chance));
            if (Math.random() >= chance) {
                return;
            }
            let boostBias = personality.boostBias ?? 0.5;
            if (personality.lateSurge && stage >= personality.lateSurge.from) {
                boostBias = Math.min(0.95, boostBias + (personality.lateSurge.boostShift || 0));
            }
            if (personality.restWindow && stage >= personality.restWindow.from && stage <= personality.restWindow.to) {
                boostBias *= personality.restWindow.boostModifier || 0.8;
            }
            const eventType = Math.random() < boostBias ? 'boost' : 'stumble';
            triggerHorseEvent(racer, eventType, timestamp);
        }

        function triggerHorseEvent(racer, type, timestamp) {
            const personality = racer.personality || HORSE_PERSONALITIES.default;
            const durationBase = type === 'boost' ? 1500 : 2400;
            const durationVariance = type === 'boost' ? 800 : 1100;
            const duration = (durationBase + Math.random() * durationVariance) * (personality.effectDurationModifier || 1);
            const effect = {
                type,
                until: timestamp + duration,
                speedMultiplier: type === 'boost'
                    ? (personality.boostSpeedMultiplier || 1.85)
                    : (personality.stumbleSpeedMultiplier || 0.06),
                burstProgress: type === 'boost'
                    ? (0.14 + Math.random() * 0.06) * (personality.burstBonus || 1.05)
                    : 0,
                burstApplied: false
            };
            racer.effect = effect;
            racer.nextEventAllowedAt = effect.until + (personality.eventCooldown || RACE_EVENT_BASE_COOLDOWN);
            const baseMessage = pickRandomMessage(RACE_BASE_EFFECT_MESSAGES[type], type === 'boost' ? '부스터 온! ⚡' : '돌부리에 걸려 넘어짐! 😵');
            const message = pickRandomMessage(personality.messages?.[type], baseMessage);
            setHorseEventLabel(racer.horse.id, message, type);
            highlightHorseLane(racer.horse.id, type);
        }

        function setHorseEventLabel(horseId, message, type) {
            const entry = raceState.effectLabels?.get(horseId);
            if (!entry) return;
            const element = entry.element;
            if (!element) return;
            element.textContent = message;
            element.classList.remove('text-amber-600', 'text-emerald-600', 'text-rose-500');
            if (type === 'boost') {
                element.classList.add('text-emerald-600');
            } else if (type === 'stumble') {
                element.classList.add('text-rose-500');
            } else {
                element.classList.add('text-amber-600');
            }
        }

        function clearHorseEventLabel(horseId) {
            const entry = raceState.effectLabels?.get(horseId);
            if (!entry) return;
            const element = entry.element;
            if (!element) return;
            element.textContent = entry.defaultText || '';
            element.classList.remove('text-emerald-600', 'text-rose-500');
            if (entry.defaultText) {
                element.classList.add('text-amber-600');
            } else {
                element.classList.remove('text-amber-600');
            }
        }

        function highlightHorseLane(horseId, type) {
            const entry = raceState.progressElements?.get(horseId);
            if (!entry?.lane) return;
            entry.lane.classList.remove('race-lane-boost', 'race-lane-stumble');
            if (type === 'boost') {
                entry.lane.classList.add('race-lane-boost');
            } else if (type === 'stumble') {
                entry.lane.classList.add('race-lane-stumble');
            }
        }

        function clearHorseLaneHighlight(horseId) {
            const entry = raceState.progressElements?.get(horseId);
            if (!entry?.lane) return;
            entry.lane.classList.remove('race-lane-boost', 'race-lane-stumble');
        }

        function clearHorseEffect(horseId) {
            clearHorseLaneHighlight(horseId);
            clearHorseEventLabel(horseId);
        }

        function handleRaceStart() {
            if (raceState.status === 'running') return;
            const participants = buildRaceParticipants();
            if (participants.length < 2) {
                setRaceStatus('말을 두 마리 이상 선택해 주세요.');
                updateStartButtonState();
                return;
            }
            if (participants.length < raceParticipantCount) {
                setRaceStatus('출전 말 수보다 적게 선택했어요. 체크박스를 더 선택해 주세요.');
                updateStartButtonState();
                return;
            }

            const trackElements = raceState.progressElements;
            const speedElements = raceState.speedLabels;
            const effectElements = raceState.effectLabels;
            const nextState = createEmptyRaceState();
            nextState.progressElements = trackElements;
            nextState.speedLabels = speedElements;
            nextState.effectLabels = effectElements;
            raceState = nextState;
            raceState.racers = participants;
            raceState.durationMap = new Map(participants.map(item => [item.horse.id, item.duration]));
            raceState.results = [];
            raceState.status = 'running';
            raceState.startTimestamp = performance.now();
            setRaceInputsDisabled(true);
            raceResults.classList.add('hidden');
            raceAgainBtn.classList.add('hidden');
            setRaceStatus('레이스가 진행 중입니다! ☕');
            updateStartButtonState();
            raceState.animationId = requestAnimationFrame(updateRaceFrame);
        }

        function updateRaceFrame(timestamp) {
            if (raceState.status !== 'running') return;
            if (typeof raceState.startTimestamp !== 'number') {
                raceState.startTimestamp = timestamp;
            }
            const elapsed = timestamp - raceState.startTimestamp;
            raceTimer.textContent = formatRaceTime(elapsed);

            raceState.racers.forEach(racer => {
                if (racer.finishTime) return;
                const personality = racer.personality || HORSE_PERSONALITIES.default;
                const baseProgress = Math.min(1, elapsed / racer.duration);
                const previousTimestamp = racer.lastUpdateTimestamp ?? raceState.startTimestamp;
                const rawDelta = timestamp - previousTimestamp;
                const delta = Math.max(16, Math.min(260, rawDelta));
                racer.lastUpdateTimestamp = timestamp;
                const stage = Math.min(1, elapsed / racer.duration);

                if (racer.effect && timestamp >= racer.effect.until) {
                    clearHorseEffect(racer.horse.id);
                    racer.effect = null;
                }

                maybeTriggerHorseEvent(racer, delta, stage, timestamp);

                if (racer.effect && timestamp >= racer.effect.until) {
                    clearHorseEffect(racer.horse.id);
                    racer.effect = null;
                }

                let speedMultiplier = applyPersonalitySpeedMultiplier(personality, stage);
                if (racer.effect) {
                    speedMultiplier *= racer.effect.speedMultiplier;
                }

                let randomness = (Math.random() - 0.5) * (personality.randomness || HORSE_PERSONALITIES.default.randomness) * (delta / 1000);
                if (racer.effect?.type === 'stumble') {
                    randomness = Math.min(randomness, 0);
                }

                let waveBonus = 0;
                if (personality.wave) {
                    waveBonus = Math.sin(stage * Math.PI * personality.wave.frequency + racer.randomPhase) * personality.wave.amplitude * (delta / 1000);
                    if (racer.effect?.type === 'stumble') {
                        waveBonus *= 0.25;
                    }
                }

                const baseIncrement = (delta / racer.duration) * speedMultiplier * RACE_BASE_SPEED_FACTOR;
                let nextProgress = racer.progress + baseIncrement + randomness + waveBonus;

                if (racer.effect?.type === 'boost' && !racer.effect.burstApplied) {
                    nextProgress = Math.max(nextProgress, racer.progress + racer.effect.burstProgress);
                    racer.effect.burstApplied = true;
                }

                if (!racer.effect || racer.effect.type !== 'stumble') {
                    nextProgress = Math.max(nextProgress, baseProgress);
                }

                nextProgress = Math.min(1, Math.max(racer.progress, nextProgress));
                
                racer.progress = nextProgress;
                
                const trackElements = raceState.progressElements.get(racer.horse.id);
                const progressPercent = Math.min(100, nextProgress * 100);
                if (trackElements?.fill) {
                    trackElements.fill.style.width = `${progressPercent}%`;
                }
                if (trackElements?.icon) {
                    trackElements.icon.style.left = `${progressPercent}%`;
                }
                
                const speedLabel = raceState.speedLabels.get(racer.horse.id);
                if (speedLabel) {
                    speedLabel.textContent = nextProgress >= 1 ? '도착!' : `${Math.round(nextProgress * 100)}%`;
                }
                
                if (nextProgress >= 1 && !racer.finishTime) {
                    racer.finishTime = timestamp;
                    raceState.results.push({
                        horse: racer.horse,
                        finishTime: timestamp,
                        duration: timestamp - raceState.startTimestamp
                    });
                    clearHorseEffect(racer.horse.id);
                }
            });

            if (raceState.results.length === raceState.racers.length) {
                finalizeRace(timestamp);
                return;
            }

            raceState.animationId = requestAnimationFrame(updateRaceFrame);
        }

        function finalizeRace(timestamp) {
            stopRaceAnimation();
            raceState.status = 'finished';
            const finalElapsed = timestamp - raceState.startTimestamp;
            raceTimer.textContent = formatRaceTime(finalElapsed);
            setRaceInputsDisabled(false);
            raceAgainBtn.classList.remove('hidden');
            raceState.racers.forEach(racer => clearHorseEffect(racer.horse.id));

            raceResultsList.innerHTML = '';
            raceState.results.sort((a, b) => a.duration - b.duration);
            raceState.speedLabels.forEach(label => {
                if (label) {
                    label.textContent = '도착!';
                }
            });
            raceState.results.forEach((result, index) => {
                const li = document.createElement('li');
                li.className = 'flex items-center justify-between bg-slate-800/60 rounded-lg px-3 py-2';
                li.innerHTML = `<span class="font-semibold">#${index + 1} ${result.horse.icon || '🐎'} ${safeText(result.horse.name)}</span><span class="text-xs text-slate-300">${formatRaceTime(result.duration)}</span>`;
                raceResultsList.appendChild(li);
            });
            raceResults.classList.remove('hidden');

            if (raceState.results.length > 0) {
                const winner = raceState.results[0].horse;
                horseWinRecord[winner.id] = (horseWinRecord[winner.id] || 0) + 1;
                raceQueue.unshift({
                    timestamp: Date.now(),
                    results: raceState.results.map((entry, index) => ({
                        rank: index + 1,
                        horseId: entry.horse.id,
                        name: entry.horse.name,
                        duration: entry.duration
                    }))
                });
                if (raceQueue.length > 10) {
                    raceQueue = raceQueue.slice(0, 10);
                }
                persistHorseWinRecord(winner);
            }

            renderHorseWinSummary();
            renderRaceHorseList();
            setRaceStatus('레이스가 종료되었습니다! 다시 달리기를 누르면 같은 구성으로 재도전할 수 있어요.');
            updateStartButtonState();
        }

        function persistHorseWinRecord(winnerHorse) {
            try {
                localStorage.setItem('lunch-race-wins', JSON.stringify(horseWinRecord));
            } catch (error) {
                console.warn('경마 기록 저장 실패:', error);
            }
            if (!db) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const docRef = doc(db, 'artifacts', appId, 'raceStats', winnerHorse.id);
            setDoc(docRef, {
                name: winnerHorse.name,
                wins: horseWinRecord[winnerHorse.id] || 0,
                updatedAt: serverTimestamp()
            }, { merge: true }).catch(error => console.error('경마 승수 저장 실패:', error));
        }

        function updateModeButtons(activeMode) {
            modeButtons.forEach(button => {
                const target = button.dataset.modeTarget;
                const isActive = target === activeMode;
                button.classList.toggle('mode-button-active', isActive);
            });
        }

        function updateModeScopedElements(activeMode) {
            modeScopedElements.forEach(element => {
                const availableModes = (element.dataset.modeVisible || '')
                    .split(',')
                    .map(mode => mode.trim())
                    .filter(Boolean);
                const shouldShow = availableModes.includes(activeMode);
                const prefersTransition = element.classList.contains('mode-panel');
                if (prefersTransition) {
                    if (shouldShow) {
                        element.classList.remove('mode-hidden');
                        element.classList.remove('mode-panel-active');
                        void element.offsetWidth;
                        element.classList.add('mode-panel-active');
                    } else {
                        element.classList.remove('mode-panel-active');
                        element.classList.add('mode-hidden');
                    }
                } else {
                    element.classList.toggle('mode-hidden', !shouldShow);
                }
            });
        }

        function setMode(mode) {
            if (!modeMeta[mode]) return;
            const previousMode = currentMode;
            const isSameMode = previousMode === mode;
            currentMode = mode;

            if (previousMode === Mode.RACE && mode !== Mode.RACE) {
                teardownRaceMode();
            }

            landingScreen.classList.add('hidden');
            landingScreenMobile?.classList.add('hidden');
            appShell.classList.remove('hidden');
            mobileModeNav?.classList.remove('hidden');

            updateModeButtons(mode);
            updateModeScopedElements(mode);

            const meta = modeMeta[mode];
            activeModeBadge.textContent = meta.badge;
            modeDescription.textContent = meta.description;

            if (mode === Mode.CUSTOM) {
                segmentCount = customSegmentCount;
                if (customSlotCountInput) {
                    customSlotCountInput.value = customSegmentCount;
                }
                syncCustomSlotCountDisplay(customSegmentCount);
                drawWheel();
            } else if (mode === Mode.LOCATION || mode === Mode.RACE || (mode === Mode.TEAM && !teamMode)) {
                segmentCount = DEFAULT_SEGMENT_COUNT;
                drawWheel();
            }

            if (!teamMode || mode !== Mode.TEAM) {
                syncTeamSlotCountInput(segmentCount);
            }

            if (isSameMode) {
                if (mode === Mode.LOCATION) {
                    attemptAutoDiscovery();
                }
                if (mode === Mode.RACE) {
                    updateRaceSelectionUI();
                }
                return;
            }

            if (mode === Mode.LOCATION) {
                if (teamMode) {
                    leaveTeamMode({ silent: true });
                }
                attemptAutoDiscovery();
                updateLocationGameStageVisibility();
                updateLocationGameDisplays();
                if (locationGameHint) {
                    const meta = getLocationGameMeta();
                    locationGameHint.textContent = `${meta.label} 모드: ${meta.hint}`;
                }
            } else if (mode === Mode.TEAM) {
                if (!teamMode) {
                    resetState(true);
                    statusMessage.textContent = '엑세스 코드를 입력하면 팀이 생성되거나 입장됩니다.';
                }
            } else if (mode === Mode.CUSTOM) {
                if (teamMode) {
                    leaveTeamMode({ silent: true });
                }
                if (previousMode !== Mode.CUSTOM) {
                    resetState(true);
                    if (!restaurants.length) {
                        statusMessage.textContent = '나만의 룰렛을 만들어 보세요.';
                    }
                }
            } else if (mode === Mode.RACE) {
                if (teamMode) {
                    leaveTeamMode({ silent: true });
                }
                initRaceMode();
            }

            if (mode !== Mode.LOCATION) {
                locationFallback.classList.add('hidden');
            }

            updateLocationGameStageVisibility();
            updateStartButtonState();
        }

        function returnToLanding() {
            if (teamMode) {
                leaveTeamMode({ silent: true });
            } else {
                resetState(true);
            }

            if (currentMode === Mode.RACE) {
                teardownRaceMode();
            }

            currentMode = null;
            landingScreen.classList.remove('hidden');
            landingScreenMobile?.classList.remove('hidden');
            appShell.classList.add('hidden');
            mobileModeNav?.classList.add('hidden');
            modeButtons.forEach(button => button.classList.remove('mode-button-active'));
            modeScopedElements.forEach(element => element.classList.add('mode-hidden'));
            statusMessage.textContent = '모드를 선택해 주세요.';
            modeDescription.textContent = '네 가지 방식으로 점심 고민을 단번에 해결해 보세요.';
            activeModeBadge.textContent = '모드를 선택해 주세요';
            locationFallback.classList.add('hidden');
        }  
        
        const textEscapes = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
        function safeText(text = '') {
            return String(text).replace(/[&<>"']/g, char => textEscapes[char] || char);
        }

        function getLocationGameMeta(type = locationGameType) {
            return LOCATION_GAMES[type] || LOCATION_GAMES.roulette;
        }

        function shortenText(text = '', limit = 8) {
            const raw = typeof text === 'string' ? text.trim() : String(text || '');
            if (raw.length <= limit) return raw;
            return `${raw.slice(0, Math.max(1, limit - 1))}…`;
        }

        function updateLocationGameStageVisibility() {
            if (!gameStageContainers) return;
            const activeType = currentMode === Mode.LOCATION ? locationGameType : 'roulette';
            gameStageContainers.forEach(stage => {
                const stageType = stage.dataset.gameStage;
                stage.classList.toggle('hidden', stageType !== activeType);
            });
            if (locationGameSelect && currentMode === Mode.LOCATION && locationGameSelect.value !== locationGameType) {
                locationGameSelect.value = locationGameType;
            }
        }

        function getLocationGameParticipants() {
            return restaurants.filter(item => item && item.id !== 'reroll');
        }

        function isLocationGameBusy() {
            if (locationGameType === 'ladder') return isLadderRunning;
            if (locationGameType === 'ball') return isBallDrawing;
            return isSpinning;
        }

        function updateLocationGameDisplays() {
            const participants = getLocationGameParticipants();
            renderLadderPreview(participants);
            renderBallPool(participants);
        }

        function resetLocationGameVisuals() {
            stopBallAnimation();
            if (winnerCard) {
                winnerCard.classList.add('hidden');
            }
            if (canvas) {
                canvas.classList.remove('blinking');
            }
            if (ladderResultText) {
                ladderResultText.textContent = '사다리타기 결과가 여기 표시됩니다.';
            }
            if (ballResultText) {
                ballResultText.textContent = '공을 뽑으면 결과가 여기 표시됩니다.';
            }
            updateLocationGameDisplays();
        }

        function setLocationGameType(type) {
            const normalized = Object.prototype.hasOwnProperty.call(LOCATION_GAMES, type) ? type : 'roulette';
            if (locationGameType === normalized) {
                updateLocationGameStageVisibility();
                if (locationGameHint) {
                    const meta = getLocationGameMeta();
                    locationGameHint.textContent = `${meta.label} 모드: ${meta.hint}`;
                }
                return;
            }
            locationGameType = normalized;
            updateLocationGameStageVisibility();
            resetLocationGameVisuals();
            if (locationGameHint) {
                const meta = getLocationGameMeta();
                locationGameHint.textContent = `${meta.label} 모드: ${meta.hint}`;
            }
            if (currentMode === Mode.LOCATION && !teamMode) {
                const meta = getLocationGameMeta();
                const participants = getLocationGameParticipants();
                statusMessage.textContent = participants.length === 0 ? meta.emptyMessage : meta.selectMessage;
            }
            updateStartButtonState();
        }

        function prepareLadderDrawing(participantCount = 2) {
            if (!ladderCanvas) return null;
            const count = Math.max(2, participantCount);
            const containerWidth = ladderCanvas.parentElement ? ladderCanvas.parentElement.clientWidth : ladderCanvas.clientWidth || 480;
            const width = Math.min(containerWidth || 480, 640);
            const height = Math.max(320, count * 60);
            const dpr = window.devicePixelRatio || 1;
            const ctx = ladderCanvas.getContext('2d');
            ladderCanvas.width = width * dpr;
            ladderCanvas.height = height * dpr;
            ladderCanvas.style.width = `${width}px`;
            ladderCanvas.style.height = `${height}px`;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
            ctx.clearRect(0, 0, width, height);
            const leftPadding = 50;
            const rightPadding = 50;
            const topPadding = 60;
            const bottomPadding = 90;
            const innerWidth = Math.max(10, width - leftPadding - rightPadding);
            const columnPositions = Array.from({ length: count }, (_, idx) => {
                if (count === 1) {
                    return width / 2;
                }
                const spacing = innerWidth / (count - 1);
                return leftPadding + spacing * idx;
            });
            return {
                ctx,
                width,
                height,
                topPadding,
                bottomPadding,
                leftPadding,
                rightPadding,
                columnPositions,
                participantCount: count
            };
        }

        function generateLadderRungs(participantCount, drawing) {
            if (!drawing || participantCount < 2) return [];
            const rungTarget = Math.max(6, participantCount * 2);
            const verticalSpace = drawing.height - drawing.topPadding - drawing.bottomPadding;
            const minGap = verticalSpace / (rungTarget + 1);
            const rungs = [];
            let attempts = 0;
            while (rungs.length < rungTarget && attempts < rungTarget * 8) {
                attempts += 1;
                const column = Math.floor(Math.random() * (participantCount - 1));
                const baseY = drawing.topPadding + (rungs.length + 1) * minGap;
                const jitter = (Math.random() - 0.5) * minGap * 0.6;
                const y = Math.max(drawing.topPadding + 10, Math.min(drawing.height - drawing.bottomPadding - 10, baseY + jitter));
                if (rungs.some(r => r.column === column && Math.abs(r.y - y) < minGap * 0.6)) continue;
                rungs.push({ column, y });
            }
            rungs.sort((a, b) => a.y - b.y);
            return rungs;
        }

        function drawLadderBase(ctx, drawing, rungs = []) {
            if (!ctx || !drawing) return;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#cbd5f5';
            ctx.lineWidth = 3;
            drawing.columnPositions.forEach((x) => {
                ctx.beginPath();
                ctx.moveTo(x, drawing.topPadding);
                ctx.lineTo(x, drawing.height - drawing.bottomPadding);
                ctx.stroke();
            });
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            rungs.forEach(rung => {
                const startX = drawing.columnPositions[rung.column];
                const endX = drawing.columnPositions[rung.column + 1];
                ctx.beginPath();
                ctx.moveTo(startX, rung.y);
                ctx.lineTo(endX, rung.y);
                ctx.stroke();
            });
        }

        function drawLadderEmptyMessage(ctx, drawing, message) {
            if (!ctx || !drawing) return;
            ctx.fillStyle = '#94a3b8';
            ctx.font = "14px 'Noto Sans KR'";
            ctx.textAlign = 'center';
            ctx.fillText(message, drawing.width / 2, drawing.height / 2);
        }

        function drawLadderLabels(ctx, drawing, participants = [], highlightIndex = null) {
            if (!ctx || !drawing) return;
            ctx.font = "12px 'Noto Sans KR'";
            ctx.fillStyle = '#64748b';
            ctx.textAlign = 'center';
            drawing.columnPositions.forEach((x, index) => {
                ctx.fillText(`${index + 1}`, x, drawing.topPadding - 20);
            });
            ctx.font = "bold 13px 'Noto Sans KR'";
            drawing.columnPositions.forEach((x, index) => {
                const participant = participants[index];
                if (!participant) return;
                ctx.fillStyle = index === highlightIndex ? '#16a34a' : '#1f2937';
                ctx.fillText(shortenText(participant.place_name, 8), x, drawing.height - drawing.bottomPadding + 32);
            });
        }

        function computeLadderPath(drawing, rungs, startColumn) {
            let column = startColumn;
            const points = [{ x: drawing.columnPositions[column], y: drawing.topPadding }];
            rungs.forEach(rung => {
                const currentX = drawing.columnPositions[column];
                points.push({ x: currentX, y: rung.y });
                if (column === rung.column) {
                    column += 1;
                    points.push({ x: drawing.columnPositions[column], y: rung.y });
                } else if (column === rung.column + 1) {
                    column -= 1;
                    points.push({ x: drawing.columnPositions[column], y: rung.y });
                }
            });
            points.push({ x: drawing.columnPositions[column], y: drawing.height - drawing.bottomPadding });
            return { finalColumn: column, points };
        }

        function drawLadderPath(ctx, points = []) {
            if (!ctx || !points.length) return;
            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
        }

        function drawLadderMarkers(ctx, drawing, startColumn, finalColumn) {
            if (!ctx || !drawing) return;
            ctx.fillStyle = '#f97316';
            ctx.beginPath();
            ctx.arc(drawing.columnPositions[startColumn], drawing.topPadding - 28, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#16a34a';
            ctx.beginPath();
            ctx.arc(drawing.columnPositions[finalColumn], drawing.height - drawing.bottomPadding + 40, 9, 0, Math.PI * 2);
            ctx.fill();
        }

        function renderLadderPreview(participants = []) {
            if (!ladderCanvas) return;
            const drawing = prepareLadderDrawing(participants.length);
            if (!drawing) return;
            if (participants.length < 2) {
                drawLadderBase(drawing.ctx, drawing, []);
                drawLadderEmptyMessage(drawing.ctx, drawing, '후보가 준비되면 사다리판이 만들어져요.');
                if (ladderResultText) {
                    ladderResultText.textContent = '후보가 2개 이상 모이면 사다리를 탈 수 있어요.';
                }
                return;
            }
            const rungs = generateLadderRungs(participants.length, drawing);
            drawLadderBase(drawing.ctx, drawing, rungs);
            drawLadderLabels(drawing.ctx, drawing, participants);
            if (ladderResultText) {
                ladderResultText.textContent = 'START 버튼으로 사다리를 타보세요.';
            }
        }

        function playLadderGame() {
            const participants = getLocationGameParticipants();
            if (participants.length < 2) {
                statusMessage.textContent = '사다리타기를 하려면 최소 2개의 후보가 필요해요.';
                return;
            }
            if (!ladderCanvas) {
                statusMessage.textContent = '사다리 화면을 준비하지 못했습니다.';
                return;
            }
            stopBallAnimation();
            if (blinkAnimationId) cancelAnimationFrame(blinkAnimationId);
            canvas.classList.remove('blinking');
            winnerCard.classList.add('hidden');
            isLadderRunning = true;
            updateStartButtonState();
            const drawing = prepareLadderDrawing(participants.length);
            if (!drawing) {
                isLadderRunning = false;
                updateStartButtonState();
                statusMessage.textContent = '사다리판을 준비하지 못했습니다.';
                return;
            }
            const rungs = generateLadderRungs(participants.length, drawing);
            drawLadderBase(drawing.ctx, drawing, rungs);
            const startColumn = Math.floor(Math.random() * participants.length);
            const pathInfo = computeLadderPath(drawing, rungs, startColumn);
            drawLadderPath(drawing.ctx, pathInfo.points);
            drawLadderMarkers(drawing.ctx, drawing, startColumn, pathInfo.finalColumn);
            drawLadderLabels(drawing.ctx, drawing, participants, pathInfo.finalColumn);
            const winner = participants[pathInfo.finalColumn];
            if (ladderResultText) {
                ladderResultText.innerHTML = `랜덤으로 선택된 ${startColumn + 1}번 사다리의 결과는 <span class="font-semibold text-emerald-600">${safeText(winner.place_name)}</span>!`;
            }
            statusMessage.innerHTML = `사다리타기 결과는 <span class="font-bold text-emerald-600">${safeText(winner.place_name)}</span>!`;
            populateWinnerCard(winner);
            winnerCard.classList.remove('hidden');
            isLadderRunning = false;
            updateStartButtonState();
        }

        function stopBallAnimation() {
            if (ballAnimationTimeouts.length) {
                ballAnimationTimeouts.forEach(id => clearTimeout(id));
                ballAnimationTimeouts = [];
            }
            if (ballPool) {
                ballPool.querySelectorAll('.ball-item').forEach(ball => ball.classList.remove('ball-item-active'));
            }
            isBallDrawing = false;
        }

        function renderBallPool(participants = []) {
            if (!ballPool) return;
            ballPool.innerHTML = '';
            if (participants.length === 0) {
                const empty = document.createElement('p');
                empty.className = 'text-sm text-slate-500 text-center w-full';
                empty.textContent = '후보가 준비되면 공을 자동으로 채워드려요.';
                ballPool.appendChild(empty);
                if (ballResultText) {
                    ballResultText.textContent = '후보가 준비되면 공을 뽑을 수 있어요.';
                }
                return;
            }
            if (participants.length < 2) {
                const notice = document.createElement('p');
                notice.className = 'text-sm text-slate-500 text-center w-full';
                notice.textContent = '후보가 두 개 이상 모여야 공을 뽑을 수 있어요.';
                ballPool.appendChild(notice);
                if (ballResultText) {
                    ballResultText.textContent = '후보를 더 추가해 주세요.';
                }
                return;
            }
            participants.forEach((participant, index) => {
                const ball = document.createElement('div');
                ball.className = 'ball-item';
                ball.dataset.index = String(index);
                ball.title = participant.place_name || '';
                const label = document.createElement('span');
                label.className = 'ball-item-label';
                label.textContent = shortenText(participant.place_name, 5);
                ball.appendChild(label);
                ballPool.appendChild(ball);
            });
            if (ballResultText) {
                ballResultText.textContent = 'START 버튼으로 공을 뽑아보세요.';
            }
        }

        function finalizeBallWinner(winner) {
            if (!winner) {
                statusMessage.textContent = '당첨자를 확인하지 못했습니다.';
                isBallDrawing = false;
                updateStartButtonState();
                return;
            }
            if (ballResultText) {
                ballResultText.innerHTML = `행운의 공은 <span class="font-semibold text-emerald-600">${safeText(winner.place_name)}</span>!`;
            }
            statusMessage.innerHTML = `공 뽑기 결과는 <span class="font-bold text-emerald-600">${safeText(winner.place_name)}</span>!`;
            populateWinnerCard(winner);
            winnerCard.classList.remove('hidden');
            isBallDrawing = false;
            updateStartButtonState();
            if (ballAnimationTimeouts.length) {
                ballAnimationTimeouts.forEach(id => clearTimeout(id));
                ballAnimationTimeouts = [];
            }
        }

        function playBallDrawGame() {
            const participants = getLocationGameParticipants();
            if (participants.length < 2) {
                statusMessage.textContent = '공 뽑기는 두 개 이상의 후보가 필요해요.';
                return;
            }
            stopBallAnimation();
            if (blinkAnimationId) cancelAnimationFrame(blinkAnimationId);
            canvas.classList.remove('blinking');
            winnerCard.classList.add('hidden');
            let balls = Array.from(ballPool?.querySelectorAll('.ball-item') || []);
            if (balls.length !== participants.length) {
                renderBallPool(participants);
                balls = Array.from(ballPool?.querySelectorAll('.ball-item') || []);
            }
            if (balls.length !== participants.length) {
                statusMessage.textContent = '공을 준비하지 못했습니다. 잠시 후 다시 시도해 주세요.';
                return;
            }
            isBallDrawing = true;
            updateStartButtonState();
            const winnerIndex = Math.floor(Math.random() * participants.length);
            const totalCycles = participants.length * 5 + Math.floor(Math.random() * participants.length) + 8;
            const sequence = [];
            for (let i = 0; i < totalCycles; i++) {
                sequence.push(i % participants.length);
            }
            sequence.push(winnerIndex);
            const stepDuration = 120;
            sequence.forEach((seqIndex, step) => {
                const timeoutId = setTimeout(() => {
                    balls.forEach(ball => ball.classList.remove('ball-item-active'));
                    const targetBall = balls[seqIndex];
                    if (targetBall) {
                        targetBall.classList.add('ball-item-active');
                    }
                    if (step === sequence.length - 1) {
                        finalizeBallWinner(participants[seqIndex]);
                    }
                }, step * stepDuration);
                ballAnimationTimeouts.push(timeoutId);
            });
        }

        function updateStartButtonState() {
            if (currentMode === Mode.RACE) {
                const selectedCount = selectedHorseIds.size;
                const participantsNeeded = Math.max(2, raceParticipantCount);
                const ready = selectedCount >= participantsNeeded;
                startBtn.disabled = raceState.status === 'running' || !ready;
                resetBtn.disabled = raceState.status === 'running';
                return;
            }
            if (teamMode) {
                const allFilled = teamSlots.every(slot => typeof slot === 'string' && slot.trim() !== '');
                startBtn.disabled = isSpinning || !allFilled;
                resetBtn.disabled = isSpinning;
                return;
            }
            if (currentMode === Mode.LOCATION) {
                const locationBusy = isLocationGameBusy();
                const participants = getLocationGameParticipants();
                const ready = locationGameType === 'roulette'
                    ? restaurants.length >= segmentCount
                    : participants.length >= 2;
                startBtn.disabled = locationBusy || !ready;
                resetBtn.disabled = locationBusy;
            } else {
                startBtn.disabled = isSpinning || restaurants.length < segmentCount;
                resetBtn.disabled = isSpinning;
            }
        }

        function sanitizeAccessCode(raw = '') {
            return raw.replace(/[^a-zA-Z0-9]/g, '').toUpperCase().slice(0, 12);
        }

        async function initializeFirebase() {
            try {
                const firebaseConfig = {
                  apiKey: "AIzaSyCULXkDYqAfCtpN7PmQktYachfyB7P8dqk",
                  authDomain: "lunch-78f47.firebaseapp.com",
                  projectId: "lunch-78f47",
                  storageBucket: "lunch-78f47.appspot.com",
                  messagingSenderId: "612330931668",
                  appId: "1:612330931668:web:07ab3d8ac7bba96f5ac241"
                };

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        loadSavedRoulettes();
                        loadSharedRoulettes();
                        resetBtn.disabled = false;
                        loadHorseWinRecordFromRemote();
                    } else {
                        signInAnonymously(auth).catch(error => console.error("Anonymous sign-in failed:", error));
                    }
                });
            } catch (error) {
                console.error("Firebase 초기화 실패:", error);
                statusMessage.textContent = "앱 초기화에 실패했습니다.";
            }
        }

        function updateTeamUIState() {
            if (teamMode) {
                teamJoinBtn.classList.add('hidden');
                teamLeaveBtn.classList.remove('hidden');
                teamSlotsContainer.classList.remove('hidden');
                teamAccessInput.value = teamCode;
                syncTeamSlotCountInput(segmentCount);
            } else {
                teamJoinBtn.classList.remove('hidden');
                teamLeaveBtn.classList.add('hidden');
                teamSlotsContainer.classList.add('hidden');
                teamAccessInput.value = '';
                teamStatus.textContent = '엑세스 코드를 입력하면 팀이 생성되거나 입장됩니다.';
                segmentCount = currentMode === Mode.CUSTOM ? customSegmentCount : DEFAULT_SEGMENT_COUNT;
                syncTeamSlotCountInput(segmentCount);
                drawWheel();
                updateStartButtonState();
            }
            if (teamSlotCountInput) {
                const disabled = !teamMode;
                teamSlotCountInput.disabled = disabled;
                teamSlotCountInput.classList.toggle('opacity-60', disabled);
                teamSlotCountInput.classList.toggle('cursor-not-allowed', disabled);
            }
        }

        function createTeamEntry(index, text) {
            const raw = typeof text === 'string' ? text : '';
            const display = raw.trim() === '' ? `칸 ${index + 1}` : raw;
            return {
                id: `team-${index}`,
                place_name: display,
                rawText: raw,
                place_url: '#',
                address_name: '',
                road_address_name: '',
                phone: '',
                distance: 0,
                isTeamEntry: true
            };
        }

        function updateTeamSlotsUI(slots = []) {
            if (!teamMode) return;
            teamSlotsContainer.innerHTML = '';
            slots.forEach((slot, index) => {
                const row = document.createElement('div');
                row.className = 'flex items-center gap-2';

                const label = document.createElement('span');
                label.className = 'w-6 text-xs font-semibold text-slate-500 text-right';
                label.textContent = `${index + 1}.`;

                const input = document.createElement('input');
                input.className = 'team-slot-input border rounded px-2 py-1 text-sm flex-1';
                input.value = slot || '';
                input.setAttribute('data-index', index);

                const button = document.createElement('button');
                button.className = 'team-slot-save bg-indigo-500 hover:bg-indigo-600 text-white text-xs font-semibold px-3 py-1 rounded-md flex-shrink-0';
                button.textContent = '저장';

                button.addEventListener('click', () => saveTeamSlot(index, input.value));
                input.addEventListener('keyup', (event) => {
                    if (event.key === 'Enter') {
                        saveTeamSlot(index, input.value);
                    }
                });

                row.appendChild(label);
                row.appendChild(input);
                row.appendChild(button);
                teamSlotsContainer.appendChild(row);
            });
        }

        function applyTeamSlotsToRestaurants(slots = [], count = segmentCount) {
            if (!teamMode) return;
            const normalizedCount = clampSegmentCount(count);
            segmentCount = normalizedCount;
            const normalizedSlots = Array.from({ length: normalizedCount }, (_, idx) => (slots[idx] || ''));
            teamSlots = normalizedSlots;
            restaurants = teamSlots.map((slot, index) => createTeamEntry(index, slot));
            candidateListsWrapper.innerHTML = '';
            saveContainer.classList.add('hidden');
            drawWheel();
            updateTeamSlotsUI(teamSlots);

            const filledCount = teamSlots.filter(slot => slot.trim() !== '').length;
            syncTeamSlotCountInput(normalizedCount);
            if (filledCount === normalizedCount) {
                teamStatus.textContent = '모든 칸이 채워졌어요! 이제 START 버튼으로 함께 돌려보세요.';
                if (winnerIndex === -1 && !isSpinning) {
                    statusMessage.textContent = '팀 룰렛이 준비되었습니다! START 버튼을 누르면 모두가 동시에 볼 수 있어요.';
                }
            } else {
                teamStatus.textContent = `${filledCount}/${normalizedCount}칸 채워졌어요. 모두 채우면 START 버튼이 활성화됩니다.`;
                if (winnerIndex === -1 && !isSpinning) {
                    statusMessage.textContent = '팀 룰렛을 채우는 중이에요. 팀원들과 함께 각 칸을 작성해 주세요.';
                }
            }
            updateStartButtonState();
        }

        async function saveTeamSlot(index, value) {
            if (!teamMode || !teamDocRef) return;
            const trimmed = (value || '').trim();
            try {
                const snap = await getDoc(teamDocRef);
                const data = snap.exists() ? snap.data() : {};
                const slots = Array.from({ length: segmentCount }, (_, idx) => {
                    if (Array.isArray(data.slots)) {
                        return data.slots[idx] || '';
                    }
                    return '';
                });

                if (index >= slots.length) return;
                slots[index] = trimmed;

                await setDoc(
                    teamDocRef,
                    {
                        slots,
                        updatedAt: serverTimestamp(),
                        lastUpdatedBy: userId || null
                    },
                    { merge: true }
                );
            } catch (error) {
                console.error('팀 슬롯 업데이트 실패:', error);
                statusMessage.textContent = '슬롯을 저장하지 못했습니다. 잠시 후 다시 시도해 주세요.';
            }
        }

        function handleTeamSlotCountChange() {
            if (!teamSlotCountInput) return;
            const desiredCount = clampSegmentCount(teamSlotCountInput.value);
            syncTeamSlotCountInput(desiredCount);
            if (!teamMode || !teamDocRef) {
                segmentCount = desiredCount;
                drawWheel();
                updateStartButtonState();
                return;
            }
            updateTeamSegmentCount(desiredCount);
        }

        async function updateTeamSegmentCount(newCount) {
            if (!teamMode || !teamDocRef) return;
            const clamped = clampSegmentCount(newCount);
            const previousCount = segmentCount;
            const previousSlots = [...teamSlots];
            const normalizedSlots = Array.from({ length: clamped }, (_, idx) => teamSlots[idx] || '');
            applyTeamSlotsToRestaurants(normalizedSlots, clamped);

            let wasDisabled = false;
            if (teamSlotCountInput) {
                wasDisabled = teamSlotCountInput.disabled;
                teamSlotCountInput.disabled = true;
                teamSlotCountInput.classList.add('opacity-60');
                teamSlotCountInput.classList.add('cursor-not-allowed');
            }

            try {
                await setDoc(teamDocRef, {
                    segmentCount: clamped,
                    slots: normalizedSlots,
                    updatedAt: serverTimestamp(),
                    lastUpdatedBy: userId || null
                }, { merge: true });
            } catch (error) {
                console.error('팀 칸 수 변경 실패:', error);
                statusMessage.textContent = '팀 칸 수를 변경하지 못했습니다. 잠시 후 다시 시도해 주세요.';
                applyTeamSlotsToRestaurants(previousSlots, previousCount);
                syncTeamSlotCountInput(previousCount);
            } finally {
                if (teamSlotCountInput) {
                    const disabled = !teamMode || wasDisabled;
                    teamSlotCountInput.disabled = disabled;
                    teamSlotCountInput.classList.toggle('opacity-60', disabled);
                    teamSlotCountInput.classList.toggle('cursor-not-allowed', disabled);
                }
            }
        }

        async function clearTeamSlots() {
            if (!teamMode || !teamDocRef) return;
            try {
                await setDoc(teamDocRef, {
                    slots: Array.from({ length: segmentCount }, () => ''),
                    segmentCount
                }, { merge: true });
                winnerIndex = -1;
                canvas.classList.remove('blinking');
                drawWheel();
                statusMessage.textContent = '팀 룰렛을 초기화했습니다. 다시 내용을 채워주세요.';
            } catch (error) {
                console.error('팀 룰렛 초기화 실패:', error);
                statusMessage.textContent = '팀 룰렛 초기화에 실패했습니다.';
            }
        }

        async function joinTeamRoom() {
            if (!db) {
                statusMessage.textContent = '앱이 준비되는 중입니다. 잠시 후 다시 시도해 주세요.';
                return;
            }
            const sanitized = sanitizeAccessCode(teamAccessInput.value.trim());
            if (!sanitized) {
                teamStatus.textContent = '영문과 숫자로 이루어진 엑세스 코드를 입력해 주세요.';
                teamAccessInput.focus();
                return;
            }
            if (teamMode && sanitized === teamCode) {
                teamStatus.textContent = `이미 '${teamCode}' 팀에 참여 중입니다.`;
                return;
            }

            teamJoinBtn.disabled = true;
            teamJoinBtn.classList.add('opacity-60', 'cursor-not-allowed');
            try {
                await enterTeamMode(sanitized);
            } catch (error) {
                console.error('팀플레이 입장 실패:', error);
                statusMessage.textContent = '팀에 참여하지 못했습니다. 잠시 후 다시 시도해 주세요.';
            } finally {
                teamJoinBtn.disabled = false;
                teamJoinBtn.classList.remove('opacity-60', 'cursor-not-allowed');
            }
        }

        async function enterTeamMode(code) {
            if (!db) return;
            if (teamUnsubscribe) {
                teamUnsubscribe();
                teamUnsubscribe = null;
            }

            resetState(true);
            canvas.classList.remove('blinking');
            winnerIndex = -1;
            segmentCount = DEFAULT_SEGMENT_COUNT;
            syncTeamSlotCountInput(segmentCount);
            drawWheel();
            updateStartButtonState();
            
            teamMode = true;
            teamCode = code;
            teamAccessInput.value = code;
            updateTeamUIState();

            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

            try {
                const appDocRef = doc(db, "artifacts", appId);
                await setDoc(appDocRef, {
                    initializedAt: serverTimestamp()
                }, { merge: true });
            } catch (error) {
                console.error('팀 베이스 문서 준비 실패:', error);
                throw error;
            }

            teamDocRef = doc(db, "artifacts", appId, "team-rooms", code);

            try {
                const docSnap = await getDoc(teamDocRef);
                if (!docSnap.exists()) {
                    await setDoc(teamDocRef, {
                        slots: Array.from({ length: DEFAULT_SEGMENT_COUNT }, () => ''),
                        segmentCount: DEFAULT_SEGMENT_COUNT,
                        createdAt: serverTimestamp()
                    });
                }
            } catch (error) {
                console.error('팀 문서 준비 실패:', error);
                teamMode = false;
                teamDocRef = null;
                updateTeamUIState();
                throw error;
            }

            lastTeamSpinTrigger = '';
            teamSnapshotInitialized = false;
            teamUnsubscribe = onSnapshot(teamDocRef, handleTeamSnapshot);
            statusMessage.textContent = `팀 룰렛 '${code}'에 참여했어요. 각 칸을 채워주세요.`;
        }

        function handleTeamSnapshot(docSnap) {
            if (!docSnap.exists()) return;
            const data = docSnap.data() || {};
            const slots = Array.isArray(data.slots) ? data.slots : [];
            const sanitizedCount = clampSegmentCount(
                typeof data.segmentCount === 'undefined' ? DEFAULT_SEGMENT_COUNT : data.segmentCount
            );
            const normalizedSlots = Array.from({ length: sanitizedCount }, (_, idx) => slots[idx] || '');
            const rawNumber = Number(data.segmentCount);
            const requiresPatch = !Number.isFinite(rawNumber)
                || rawNumber < MIN_SEGMENT_COUNT
                || rawNumber > MAX_SEGMENT_COUNT
                || !Number.isInteger(rawNumber);

            if (requiresPatch && teamDocRef) {
                setDoc(teamDocRef, {
                    segmentCount: sanitizedCount,
                    slots: normalizedSlots
                }, { merge: true }).catch(error => console.error('팀 칸 수 보정 실패:', error));
            }

            applyTeamSlotsToRestaurants(normalizedSlots, sanitizedCount);

            if (data.spin && data.spin.triggerId) {
                if (!teamSnapshotInitialized) {
                    lastTeamSpinTrigger = data.spin.triggerId;
                    triggerTeamSpinFromSnapshot(data.spin, { immediate: true });
                } else if (data.spin.triggerId !== lastTeamSpinTrigger) {
                    lastTeamSpinTrigger = data.spin.triggerId;
                    triggerTeamSpinFromSnapshot(data.spin);
                }
            }
            teamSnapshotInitialized = true;
        }

        function triggerTeamSpinFromSnapshot(spinState = {}, options = {}) {
            const rotation = Number(spinState.totalRotation) || 0;
            const targetIndex = typeof spinState.winnerIndex === 'number'
                ? spinState.winnerIndex
                : calculateWinnerIndex(rotation);
            animateSpin(rotation, targetIndex, { triggeredByTeam: true, ...options });
        }

        function leaveTeamMode(options = {}) {
            const { silent = false } = options;
            if (teamUnsubscribe) {
                teamUnsubscribe();
                teamUnsubscribe = null;
            }
            teamMode = false;
            teamCode = '';
            teamDocRef = null;
            segmentCount = currentMode === Mode.CUSTOM ? customSegmentCount : DEFAULT_SEGMENT_COUNT;
            teamSlots = Array.from({ length: segmentCount }, () => '');
            lastTeamSpinTrigger = '';
            teamSnapshotInitialized = false;
            winnerIndex = -1;
            canvas.classList.remove('blinking');
            syncTeamSlotCountInput(segmentCount);
            updateTeamUIState();
            resetState(true);
            if (!silent) {
                statusMessage.textContent = '팀에서 나왔어요. 새로운 엑세스 코드를 입력해 보세요.';
            }
            updateStartButtonState();
        }

        // --- 이벤트 리스너 ---
        modeButtons.forEach(button => {
            button.addEventListener('click', () => setMode(button.dataset.modeTarget));
        });
        locationGameSelect?.addEventListener('change', () => setLocationGameType(locationGameSelect.value));
        homeButtons.forEach(button => button.addEventListener('click', returnToLanding));
        resetBtn.addEventListener('click', () => handleReset());
        startBtn.addEventListener('click', handleStart);
        saveBtn.addEventListener('click', handleSave);
        searchSharedInput.addEventListener('input', renderSharedRoulettes);
        applyCustomBtn.addEventListener('click', handleApplyCustomChart);
        raceHorseCountInput?.addEventListener('input', () => setRaceParticipantCount(raceHorseCountInput.value));
        raceHorseCountRange?.addEventListener('input', () => setRaceParticipantCount(raceHorseCountRange.value));
        raceAgainBtn?.addEventListener('click', () => resetRaceMode({ keepSelection: true }));
        teamJoinBtn.addEventListener('click', joinTeamRoom);
        teamLeaveBtn.addEventListener('click', () => leaveTeamMode());
        teamSlotCountInput?.addEventListener('change', handleTeamSlotCountChange);
        teamAccessInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter') {
                joinTeamRoom();
            }
        });
        customSlotCountInput?.addEventListener('input', handleCustomSlotCountChange);
        applyManualLocationBtn.addEventListener('click', () => {
            if (teamMode) {
                statusMessage.textContent = '팀플레이 모드에서는 주변 식당 불러오기를 사용할 수 없어요.';
                return;
            }
            if (currentMode !== Mode.LOCATION) {
                statusMessage.textContent = '위치기반 모드에서만 사용할 수 있는 기능이에요.';
                return;
            }
            const value = manualLocationSelect.value;
            if (!value) {
                statusMessage.textContent = '동네를 선택해 주세요.';
                return;
            }
            const [lat, lng] = value.split(',').map(Number);
            locationFallback.classList.add('hidden');
            fetchRestaurants(lat, lng, 'manual');
        });
        winnerRerollBtn.addEventListener('click', () => {
            if (!startBtn.disabled) {
                handleStart();
            }
        });

        document.querySelectorAll('.sample-template-btn').forEach(btn => {
            btn.addEventListener('click', () => applyTemplate(btn.dataset.template));
        });
        
        // --- 렌더링 함수 ---
        function drawWheel() {
            const radius = canvas.width / 2;
            const segmentAngle = (2 * Math.PI) / segmentCount;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(radius, radius);

            for (let i = 0; i < segmentCount; i++) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const startAngle = segmentAngle * i - segmentAngle / 2;
                const endAngle = segmentAngle * (i + 1) - segmentAngle / 2;
                ctx.arc(0, 0, radius - 5, startAngle, endAngle);
                ctx.closePath();
                
                if (winnerIndex === i && canvas.classList.contains('blinking')) {
                     ctx.fillStyle = i % 2 === 0 ? '#fca5a5' : '#f87171';
                } else {
                    ctx.fillStyle = colors[i % colors.length];
                }
                ctx.fill();
                
                ctx.save();
                ctx.rotate(startAngle + segmentAngle / 2);
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#1f2937';
                ctx.font = `bold ${radius * 0.08}px 'Noto Sans KR'`;
                
                const text = restaurants[i] ? restaurants[i].place_name : (restaurants.length > 0 ? '?' : '준비 중');
                const textRadius = radius * 0.9;
                
                let displayText = text;
                if (ctx.measureText(text).width > radius * 0.7) {
                    displayText = text.substring(0, 7) + '...';
                }

                ctx.fillText(displayText, textRadius, 0);
                ctx.restore();
            }
            ctx.restore();
        }

        // --- 상태 관리 함수 ---
        function handleReset(options = {}) {
            if (currentMode === Mode.RACE) {
                resetRaceMode();
                return;
            }
            if (isSpinning || isLocationGameBusy()) return;
            if (teamMode) {
                resetBtn.disabled = true;
                clearTeamSlots().finally(() => updateStartButtonState());
                return;
            }
            if (currentMode !== Mode.LOCATION) {
                statusMessage.textContent = '위치기반 모드에서만 다시 불러올 수 있어요.';
                return;
            }
            const { silent = false } = options;
            resetState(silent);
            if (!silent) {
                statusMessage.textContent = '주변 식당을 다시 찾고 있어요...';
            }
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(onGeoSuccess, onGeoError, { enableHighAccuracy: false, timeout: 8000 });
            } else {
                statusMessage.textContent = '위치 정보를 사용할 수 없습니다. 동네를 직접 선택해 주세요.';
                resetBtn.disabled = false;
                locationFallback.classList.remove('hidden');
            }
        }

        function resetState(keepStatus = false) {
            isSpinning = false;
            startBtn.disabled = true;
            resetBtn.disabled = true;
            saveContainer.classList.add('hidden');
            candidateListsWrapper.innerHTML = '';
            restaurants = [];
            winnerIndex = -1;
            canvas.style.transition = 'none';
            canvas.style.transform = `rotate(0deg)`;
            canvas.classList.remove('blinking');
            if (blinkAnimationId) cancelAnimationFrame(blinkAnimationId);
            resetLocationGameVisuals();
            drawWheel();
            winnerCard.classList.add('hidden');
            if (!keepStatus) {
                statusMessage.textContent = '주변 맛집을 모으는 중이에요...';
            }
            updateStartButtonState();
        }

        function calculateWinnerIndex(totalRotation) {
            const normalized = ((totalRotation % 360) + 360) % 360;
            const segmentAngle = 360 / segmentCount;
            const winningAngle = (270 - normalized + 360) % 360;
            return Math.round(winningAngle / segmentAngle) % segmentCount;
        }

        function animateSpin(totalRotation, forcedIndex = null, options = {}) {
            const { immediate = false } = options;

            saveContainer.classList.add('hidden');
            canvas.classList.remove('blinking');
            if (blinkAnimationId) cancelAnimationFrame(blinkAnimationId);
            winnerCard.classList.add('hidden');
            updateStartButtonState();

            if (immediate) {
                isSpinning = false;
                canvas.style.transition = 'none';
                canvas.style.transform = `rotate(${totalRotation}deg)`;
                finalizeSpin(totalRotation, forcedIndex);
                return;
            }

            isSpinning = true;
            canvas.style.transition = 'transform 5s cubic-bezier(0.1, 0.7, 0.3, 1)';
            canvas.style.transform = `rotate(${totalRotation}deg)`;

            setTimeout(() => {
                isSpinning = false;
                finalizeSpin(totalRotation, forcedIndex);
            }, 5000);
        }

        function finalizeSpin(totalRotation, forcedIndex = null) {
            const targetIndex = typeof forcedIndex === 'number' ? forcedIndex : calculateWinnerIndex(totalRotation);
            winnerIndex = targetIndex;
            const winner = restaurants[winnerIndex];
            updateStartButtonState();

            if (!winner || (winner.isTeamEntry && (winner.rawText || '').trim() === '')) {
                statusMessage.textContent = '아직 비어 있는 칸에 멈췄어요. 내용을 채워볼까요?';
                winnerCard.classList.add('hidden');
                startBlinking();
                return;
            }

            if (!teamMode && winner.id === 'reroll') {
                statusMessage.innerHTML = `아쉽네요! <span class="font-bold text-red-600">다시 한 번!</span>`;
                winnerCard.classList.add('hidden');  
                startBlinking();
                return;
            }

            if (teamMode && winner.isTeamEntry) {
                const displayName = safeText((winner.rawText || winner.place_name));
                statusMessage.innerHTML = `팀 룰렛 결과는 <span class="font-bold text-emerald-600">${displayName}</span>!`;
            } else {
                statusMessage.innerHTML = `오늘의 식사는 <a href="${winner.place_url || '#'}" target="_blank" class="font-bold text-blue-600 underline">${safeText(winner.place_name)}</a>!`;
            }

            populateWinnerCard(winner);
            winnerCard.classList.remove('hidden');
            startBlinking();
        }

        async function handleStart() {
            if (currentMode === Mode.RACE) {
                handleRaceStart();
                return;
            }
            if (isSpinning) return;

            if (teamMode) {
                if (!teamDocRef) {
                    statusMessage.textContent = '팀 정보가 아직 준비되지 않았습니다. 잠시 후 다시 시도해 주세요.';
                    return;
                }
                const allFilled = teamSlots.every(slot => slot.trim() !== '');
                if (!allFilled) {
                    statusMessage.textContent = '모든 칸을 채워야 룰렛을 돌릴 수 있어요!';
                    return;
                }
                if (blinkAnimationId) cancelAnimationFrame(blinkAnimationId);
                canvas.classList.remove('blinking');
                winnerCard.classList.add('hidden');
                isSpinning = true;
                updateStartButtonState();
                const randomSpins = Math.floor(Math.random() * 5) + 5;
                const randomStopAngle = Math.random() * 360;
                const totalRotation = randomSpins * 360 + randomStopAngle;
                const winnerIdx = calculateWinnerIndex(totalRotation);
                const spinPayload = {
                    triggerId: `${userId || 'guest'}-${Date.now()}`,
                    totalRotation,
                    winnerIndex: winnerIdx,
                    initiatedAt: Date.now(),
                    initiator: userId || null
                };
                const previousTrigger = lastTeamSpinTrigger;
                lastTeamSpinTrigger = spinPayload.triggerId;
                try {
                    await updateDoc(teamDocRef, { spin: spinPayload });
                    animateSpin(totalRotation, winnerIdx);
                } catch (error) {
                    console.error('팀 룰렛 회전 정보 업데이트 실패:', error);
                    statusMessage.textContent = '룰렛을 돌리지 못했어요. 다시 시도해 주세요.';
                    isSpinning = false;
                    lastTeamSpinTrigger = previousTrigger;
                    updateStartButtonState();
                }
                return;
            }

            if (currentMode === Mode.LOCATION) {
                if (locationGameType === 'ladder') {
                    if (isLadderRunning) return;
                    playLadderGame();
                    return;
                }
                if (locationGameType === 'ball') {
                    if (isBallDrawing) return;
                    playBallDrawGame();
                    return;
                }
            }

            if (restaurants.length < segmentCount) return;

            const randomSpins = Math.floor(Math.random() * 5) + 5;
            const randomStopAngle = Math.random() * 360;
            const totalRotation = randomSpins * 360 + randomStopAngle;
            const winnerIdx = calculateWinnerIndex(totalRotation);
            animateSpin(totalRotation, winnerIdx);
        }   
        
        function startBlinking() {
            let lastTime = 0;
            let show = true;
            function blink(currentTime) {
                if (isSpinning) return;
                if (currentTime - lastTime > 500) {
                    lastTime = currentTime;
                    show = !show;
                    canvas.classList.toggle('blinking', show);
                    drawWheel();
                }
                blinkAnimationId = requestAnimationFrame(blink);
            }
            blinkAnimationId = requestAnimationFrame(blink);
        }

        // --- 데이터 처리 함수 ---
        function onGeoSuccess(position) {
            lastKnownCoords = { lat: position.coords.latitude, lng: position.coords.longitude };
            statusMessage.textContent = '주변 식당 정보를 가져오는 중...';
            locationFallback.classList.add('hidden');
            fetchRestaurants(lastKnownCoords.lat, lastKnownCoords.lng, 'geo');
        }

        function onGeoError(error) {
            console.error(error);
            statusMessage.textContent = '위치 정보를 확인할 수 없어요. 아래에서 동네를 직접 선택해 주세요.';
            resetBtn.disabled = false;
            locationFallback.classList.remove('hidden');
        }

        function fetchRestaurants(lat, lng, source = 'geo') {
            const places = new kakao.maps.services.Places();
            places.categorySearch('FD6', (result, status) => {
                if (status === kakao.maps.services.Status.OK) {
                    processRestaurantData(result, '', source);
                } else if (status === kakao.maps.services.Status.ZERO_RESULT) {
                    processRestaurantData([]);
                }
                else {
                    statusMessage.textContent = '주변 식당 정보를 가져오는데 실패했습니다.';
                    resetBtn.disabled = false;
                }
            }, { location: new kakao.maps.LatLng(lat, lng), radius: 1000, size: 15 });
        }

        function processRestaurantData(data, titlePrefix = '', source = 'geo') {
            if (teamMode) return;
            const mode = modeSelect.value;
            let placesForRoulette = [];
            let listHtml = '';
            
            const createListItem = (place) => {
                if (place.id === 'reroll') {
                    return `<li class="text-gray-500">- 다시 한 번</li>`;
                }
                const distanceMeters = Number(place.distance || 0);
                const distanceText = distanceMeters > 0 ? `${Math.round(distanceMeters / 10) * 10}m` : '거리 정보 없음';
                const category = place.category_name ? place.category_name.split('>').pop().trim() : '';
                const linkContent = place.place_url && place.place_url !== '#'
                    ? `<a href="${place.place_url}" target="_blank" class="hover:underline hover:text-blue-600">${safeText(place.place_name)}</a>`
                    : safeText(place.place_name);

                return `<li class="bg-slate-50 rounded-md px-3 py-2 shadow-sm" title="${safeText(place.place_name)}">
                            <div class="flex items-center justify-between text-sm font-semibold text-gray-700">
                                <span class="truncate">${linkContent}</span>
                                <span class="text-xs text-gray-500">${safeText(category)}</span>
                            </div>
                            <div class="mt-1 text-xs text-gray-500">${distanceText} · ${safeText(place.road_address_name || place.address_name || '')}</div>
                        </li>`;
            };

            if (titlePrefix) {
                placesForRoulette = data;
                listHtml = `<div>
                                <h3 class="text-lg font-semibold text-indigo-700 mb-2 border-b-2 border-indigo-200 pb-1">${safeText(titlePrefix)}</h3>
                                <ul class="space-y-2 text-gray-700">${placesForRoulette.map(p => createListItem(p)).join('')}</ul>
                            </div>`;
            } else {
                switch (mode) {
                    case 'distance': {
                        const distanceSorted = [...data].sort((a, b) => Number(a.distance || Infinity) - Number(b.distance || Infinity));
                        placesForRoulette = distanceSorted;
                        listHtml = `<div>
                                        <h3 class="text-lg font-semibold text-blue-700 mb-2 border-b-2 border-blue-200 pb-1">🚶‍♂️ 가까운 순 추천</h3>
                                        <ul class="space-y-2 text-gray-700">${placesForRoulette.map(p => createListItem(p)).join('')}</ul>
                                    </div>`;
                        break;
                    }
                    case 'random': {
                        const randomPlaces = [...data].sort(() => 0.5 - Math.random());
                        placesForRoulette = randomPlaces;
                        listHtml = `<div>
                                        <h3 class="text-lg font-semibold text-orange-700 mb-2 border-b-2 border-orange-200 pb-1">🎲 랜덤 추천</h3>
                                        <ul class="space-y-2 text-gray-700">${placesForRoulette.map(p => createListItem(p)).join('')}</ul>
                                    </div>`;
                        break;
                    }
                    default: {
                        const distanceSorted = [...data].sort((a, b) => Number(a.distance || Infinity) - Number(b.distance || Infinity));
                        const close = distanceSorted.slice(0, 3);
                        const remainingAfterClose = data.filter(place => !close.find(c => c.id === place.id));
                        const varietyMap = new Map();
                        const variety = [];
                        for (const place of remainingAfterClose) {
                            const category = (place.category_name || '').split('>').pop()?.trim() || '기타';
                            if (!varietyMap.has(category)) {
                                variety.push(place);
                                varietyMap.set(category, true);
                            }
                            if (variety.length >= 3) break;
                        }
                        const leftovers = data.filter(place => !close.includes(place) && !variety.includes(place));
                        const randomPick = [];
                        while (randomPick.length < 3 && leftovers.length > 0) {
                            const randomIndex = Math.floor(Math.random() * leftovers.length);
                            randomPick.push(leftovers.splice(randomIndex, 1)[0]);
                        }
                        placesForRoulette = [...close, ...variety, ...randomPick];
                        listHtml = `<div class="space-y-4">
                                        <div>
                                            <h3 class="text-lg font-semibold text-emerald-700 mb-2 border-b-2 border-emerald-200 pb-1">🍱 가까우면서 인기 있는 조합</h3>
                                            <ul class="space-y-2 text-gray-700">${close.map(p => createListItem(p)).join('')}</ul>
                                        </div>
                                        <div>
                                            <h3 class="text-lg font-semibold text-teal-700 mb-2 border-b-2 border-teal-200 pb-1">🍲 다양한 메뉴</h3>
                                            <ul class="space-y-2 text-gray-700">${variety.map(p => createListItem(p)).join('')}</ul>
                                        </div>
                                        <div>
                                            <h3 class="text-lg font-semibold text-orange-700 mb-2 border-b-2 border-orange-200 pb-1">🎲 깜짝 선택</h3>
                                            <ul class="space-y-2 text-gray-700">${randomPick.map(p => createListItem(p)).join('')}</ul>
                                        </div>
                                    </div>`;
                    }
                }
            }
            
            const rerollOption = { place_name: '다시 한 번', id: 'reroll', place_url: '#' };
            while (placesForRoulette.length < segmentCount) {
                placesForRoulette.push(rerollOption);
            }

            restaurants = placesForRoulette.slice(0, segmentCount);
            if (currentMode === Mode.LOCATION && !teamMode) {
                const gameMeta = getLocationGameMeta();
                const readyMessage = source === 'manual' ? gameMeta.manualReadyMessage : gameMeta.readyMessage;
                statusMessage.textContent = readyMessage;
                if (locationGameHint) {
                    locationGameHint.textContent = `${gameMeta.label} 모드: ${gameMeta.hint}`;
                }
            } else {
                statusMessage.textContent = source === 'manual'
                    ? '선택한 동네의 후보가 준비되었어요! START를 눌러주세요.'
                    : '룰렛이 준비되었습니다! START 버튼을 누르세요.';
            }
            updateLocationGameDisplays();
            updateStartButtonState();
            saveContainer.classList.remove('hidden');
            rouletteNameInput.value = '';
            drawWheel();
            candidateListsWrapper.innerHTML = listHtml;
            locationFallback.classList.add('hidden');
        }

        function handleCustomSlotCountChange() {
            if (!customSlotCountInput) return;
            const desiredCount = clampSegmentCount(customSlotCountInput.value);
            customSegmentCount = desiredCount;
            customSlotCountInput.value = desiredCount;
            syncCustomSlotCountDisplay(desiredCount);
            const existingValues = Array.from(document.querySelectorAll('.custom-input')).map(input => input.value);
            renderCustomInputs(existingValues);
            if (teamMode) return;
            segmentCount = desiredCount;
            restaurants = [];
            winnerIndex = -1;
            canvas.classList.remove('blinking');
            drawWheel();
            updateStartButtonState();
            winnerCard.classList.add('hidden');
            if (currentMode === Mode.CUSTOM) {
                statusMessage.textContent = '칸 수가 변경되었습니다. 새로운 구성을 적용해 보세요.';
            }
        }

        function handleApplyCustomChart() {
            if (teamMode) {
                statusMessage.textContent = '팀플레이 모드에서는 직접 만든 룰렛을 적용할 수 없어요. 먼저 팀에서 나가주세요.';
                return;
            }
            const inputs = document.querySelectorAll('.custom-input');
            const customNames = Array.from(inputs).map(input => input.value.trim()).filter(name => name !== '');

            if (customNames.length === 0) {
                statusMessage.textContent = "식당 이름을 하나 이상 입력해주세요.";
                return;
            }

            const customRestaurants = customNames.map((name, index) => ({
                place_name: safeText(name),
                id: `custom_${Date.now()}_${index}`,
                place_url: '#'
            }));
            
            resetState();
            processRestaurantData(customRestaurants, '직접 만든 룰렛');
            statusMessage.textContent = '직접 만든 룰렛을 적용했습니다!';
            updateStartButtonState();
        }

        function applyTemplate(type) {
            const templates = {
                korean: ['된장찌개', '김치찌개', '불고기 백반', '냉면', '제육볶음', '칼국수', '돈까스', '곰탕', '비빔밥'],
                noodle: ['짜장면', '짬뽕', '우동', '파스타', '라멘', '막국수', '쌀국수', '칼국수', '소바'],
                office: ['샐러드', '샌드위치', '포케', '김밥', '덮밥', '컵밥', '라이스버거', '파스타', '타코'],
                snack: ['떡볶이', '순대', '튀김 모둠', '김밥', '어묵', '라볶이', '찐만두', '핫도그', '튀김우동']
            };
            const selected = templates[type] || [];
            const inputs = document.querySelectorAll('.custom-input');
            inputs.forEach((input, index) => {
                input.value = selected[index] || '';
            });
        }

        // --- Firebase Firestore 함수 ---
        async function handleSave() {
            if (saveBtn.dataset.loading === 'true') return;
            saveBtn.dataset.loading = 'true';
            saveBtn.disabled = true;
            saveBtn.classList.add('opacity-60', 'cursor-not-allowed');
            const finishSave = () => {
                saveBtn.disabled = false;
                saveBtn.classList.remove('opacity-60', 'cursor-not-allowed');
                delete saveBtn.dataset.loading;
            };
            if (teamMode) {
                statusMessage.textContent = '팀플레이 룰렛은 저장할 수 없습니다.';
                finishSave();
                return;
            }
            const name = rouletteNameInput.value.trim();
            if (!name) {
                statusMessage.textContent = "룰렛 이름을 입력해주세요.";
                finishSave();
                return;
            }
            if (restaurants.some(r => r.id === 'reroll')) {
                statusMessage.textContent = "'다시 한 번'이 포함된 룰렛은 저장할 수 없습니다.";
                finishSave();
                return;
            }

            // 직접 만든 룰렛 저장 시에는 지역명 자동 추가 기능 비활성화
            if (restaurants.every(r => r.id.startsWith('custom'))) {
                try {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    await addDoc(collection(db, "artifacts", appId, "users", userId, "roulettes"), {
                        name: name, // 사용자가 입력한 이름 그대로 저장
                        restaurants: restaurants,
                        createdAt: serverTimestamp()
                    });
                    statusMessage.textContent = `'${name}' 룰렛이 저장되었습니다.`;
                    rouletteNameInput.value = '';
                    saveContainer.classList.add('hidden');
                } catch (error) {
                    console.error("룰렛 저장 실패:", error);
                    statusMessage.textContent = "룰렛 저장에 실패했습니다.";
                }
                finishSave();
                return;
            }

            // 위치 기반 룰렛 저장 (기존 로직)
            if (!userId || !lastKnownCoords) {
                statusMessage.textContent = "위치 정보가 필요합니다.";
                finishSave();
                return;
            }
            const geocoder = new kakao.maps.services.Geocoder();
            geocoder.coord2RegionCode(lastKnownCoords.lng, lastKnownCoords.lat, async (result, status) => {
                let regionName = "알수없음";
                if (status === kakao.maps.services.Status.OK) {
                    const region = result.find(r => r.region_type === 'H');
                    if(region) regionName = region.address_name.split(' ').pop();
                }
                
                const finalName = `[${regionName}] ${name}`;
                
                try {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    await addDoc(collection(db, "artifacts", appId, "users", userId, "roulettes"), {
                        name: finalName,
                        restaurants: restaurants,
                        createdAt: serverTimestamp()
                    });
                    statusMessage.textContent = `'${finalName}' 룰렛이 저장되었습니다.`;
                    rouletteNameInput.value = '';
                    saveContainer.classList.add('hidden');
                } catch (error) {
                    console.error("룰렛 저장 실패:", error);
                    statusMessage.textContent = "룰렛 저장에 실패했습니다.";
                }
                finishSave();
            });
        }

        function loadSavedRoulettes() {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const q = query(collection(db, "artifacts", appId, "users", userId, "roulettes"), orderBy("createdAt", "desc"));

            onSnapshot(q, (snapshot) => {
                savedRoulettesList.innerHTML = snapshot.empty ? '<p class="text-center text-gray-500">저장된 룰렛이 없습니다.</p>' : '';
                snapshot.forEach((doc) => {
                    const roulette = doc.data();
                    const div = document.createElement('div');
                    div.className = 'flex justify-between items-center p-2 border-b';
                    div.innerHTML = `
                        <span class="font-semibold truncate" title="${safeText(roulette.name)}">${safeText(roulette.name)}</span>
                        <div class="flex-shrink-0 space-x-1">
                            <button data-id="${doc.id}" class="load-btn bg-green-100 text-green-800 text-xs font-semibold px-2 py-1 rounded">불러오기</button>
                            <button data-id="${doc.id}" class="share-btn bg-yellow-100 text-yellow-800 text-xs font-semibold px-2 py-1 rounded">자랑하기</button>
                            <button data-id="${doc.id}" class="delete-btn bg-red-100 text-red-800 text-xs font-semibold px-2 py-1 rounded">삭제</button>
                        </div>
                    `;
                    savedRoulettesList.appendChild(div);
                });

                document.querySelectorAll('.load-btn').forEach(btn => btn.addEventListener('click', (e) => loadSpecificRoulette(e.target.dataset.id, 'private')));
                document.querySelectorAll('.share-btn').forEach(btn => btn.addEventListener('click', (e) => handleShare(e.target.dataset.id)));
                document.querySelectorAll('.delete-btn').forEach(btn => btn.addEventListener('click', (e) => deleteSpecificRoulette(e.target.dataset.id)));
            });
        }

        async function loadSpecificRoulette(docId, type) {
            if (!userId) return;
            if (teamMode) {
                statusMessage.textContent = '팀플레이 모드에서는 개인이나 공개 룰렛을 불러올 수 없어요. 먼저 팀에서 나가주세요.';
                return;
            }
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const collectionPath = type === 'private'
                    ? ["artifacts", appId, "users", userId, "roulettes"] 
                    : ["artifacts", appId, "public", "data", "shared-roulettes"];
                
                const docRef = doc(db, ...collectionPath, docId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const rouletteData = docSnap.data();
                    resetState();
                    const loadedRestaurants = Array.isArray(rouletteData.restaurants) ? rouletteData.restaurants : [];
                    const loadedCount = clampSegmentCount(loadedRestaurants.length || customSegmentCount);
                    customSegmentCount = loadedCount;
                    segmentCount = loadedCount;
                    if (customSlotCountInput) {
                        customSlotCountInput.value = loadedCount;
                    }
                    syncCustomSlotCountDisplay(loadedCount);
                    renderCustomInputs(loadedRestaurants.map(item => item.place_name || ''));
                    statusMessage.textContent = `'${rouletteData.name}' 룰렛을 적용했습니다.`;
                    processRestaurantData(loadedRestaurants, rouletteData.name);
                    drawWheel();
                    updateStartButtonState();
                }
            } catch (error) {
                console.error("룰렛 불러오기 실패:", error);
            }
        }
        
        async function deleteSpecificRoulette(docId) {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            await deleteDoc(doc(db, "artifacts", appId, "users", userId, "roulettes", docId));
        }

        async function handleShare(docId) {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const docRef = doc(db, "artifacts", appId, "users", userId, "roulettes", docId);
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                const rouletteToShare = docSnap.data();
                await addDoc(collection(db, "artifacts", appId, "public", "data", "shared-roulettes"), {
                    ...rouletteToShare,
                    sharedBy: userId,
                    sharedAt: serverTimestamp(),
                    likes: 0,
                    dislikes: 0,
                    voters: []
                });
                statusMessage.textContent = `'${rouletteToShare.name}' 룰렛을 자랑했습니다!`;
            }
        }

        function loadSharedRoulettes() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const q = query(collection(db, "artifacts", appId, "public", "data", "shared-roulettes"));
            
            onSnapshot(q, (snapshot) => {
                let roulettes = [];
                snapshot.forEach(doc => {
                    const shared = doc.data();
                    roulettes.push({ id: doc.id, ...shared });
                });

                roulettes.sort((a, b) => {
                    const likesDiff = (b.likes || 0) - (a.likes || 0);
                    if (likesDiff !== 0) return likesDiff;
                    const dateB = b.sharedAt?.toDate() || 0;
                    const dateA = a.sharedAt?.toDate() || 0;
                    return dateB - dateA;
                });

                allSharedRoulettes = roulettes;
                renderSharedRoulettes();
            });
        }

        function renderSharedRoulettes() {
            const searchTerm = searchSharedInput.value.toLowerCase();
            const filteredList = allSharedRoulettes.filter(shared => shared.name?.toLowerCase().includes(searchTerm));

            sharedRoulettesList.innerHTML = filteredList.length === 0 ? '<p class="text-center text-gray-500">일치하는 룰렛이 없어요.</p>' : '';
            
            filteredList.forEach(shared => {
                const div = document.createElement('div');
                div.className = 'p-3 mb-3 border border-slate-200 rounded-lg shadow-sm bg-white';
                const restaurants = Array.isArray(shared.restaurants) ? shared.restaurants : [];
                div.innerHTML = `
                    <p class="font-bold truncate" title="${safeText(shared.name)}">${safeText(shared.name)}</p>
                    <ul class="text-sm text-gray-600 mt-2 grid grid-cols-3 gap-2">
                        ${restaurants.slice(0,3).map(r => `<li class="truncate bg-slate-100 px-2 py-1 rounded text-xs">${safeText(r.place_name)}</li>`).join('')}
                        ${restaurants.length > 3 ? '<li class="text-gray-400 col-span-3 text-xs">... 등 다양한 식당이 있어요</li>' : ''}
                    </ul>
                    <div class="flex items-center justify-between mt-3">
                        <div class="flex items-center space-x-2">
                            <button data-id="${shared.id}" data-vote="like" class="vote-btn flex items-center bg-blue-50 px-3 py-1 rounded-full text-xs hover:bg-blue-100">👍 <span class="ml-1 font-semibold">${shared.likes || 0}</span></button>
                            <button data-id="${shared.id}" data-vote="dislike" class="vote-btn flex items-center bg-rose-50 px-3 py-1 rounded-full text-xs hover:bg-rose-100">👎 <span class="ml-1 font-semibold">${shared.dislikes || 0}</span></button>
                        </div>
                        <button data-id="${shared.id}" class="apply-btn bg-indigo-500 hover:bg-indigo-600 text-white text-sm font-bold py-1 px-3 rounded">적용하기</button>
                    </div>
                `;
                sharedRoulettesList.appendChild(div);
            });

            document.querySelectorAll('.apply-btn').forEach(btn => btn.addEventListener('click', (e) => loadSpecificRoulette(e.target.dataset.id, 'public')));
            document.querySelectorAll('.vote-btn').forEach(btn => btn.addEventListener('click', (e) => handleVote(e.currentTarget.dataset.id, e.currentTarget.dataset.vote)));
        }

        async function handleVote(docId, voteType) {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const docRef = doc(db, "artifacts", appId, "public", "data", "shared-roulettes", docId);
            
            const docSnap = await getDoc(docRef);
            if (!docSnap.exists()) return;

            const localVotesRaw = localStorage.getItem('lunch-votes') || '{}';
            const localVotes = JSON.parse(localVotesRaw);
            if (localVotes[docId]) {
                statusMessage.textContent = '이미 투표하셨습니다.';
                return;
            }

            const voters = docSnap.data().voters || [];
            if (voters.includes(userId)) {
                statusMessage.textContent = '이미 투표하셨습니다.';
                localVotes[docId] = true;
                localStorage.setItem('lunch-votes', JSON.stringify(localVotes));
                return;
            }

            const updateData = {
                voters: arrayUnion(userId)
            };
            if (voteType === 'like') {
                updateData.likes = increment(1);
            } else {
                updateData.dislikes = increment(1);
            }
            await updateDoc(docRef, updateData);
            localVotes[docId] = true;
            localStorage.setItem('lunch-votes', JSON.stringify(localVotes));
            statusMessage.textContent = voteType === 'like' ? '좋아요 감사합니다!' : '의견을 남겨주셔서 감사해요.';
        }

        function populateWinnerCard(winner) {
            const displayName = winner.isTeamEntry ? (winner.rawText || winner.place_name) : winner.place_name;
            winnerName.textContent = displayName;
            winnerCallBtn.classList.remove('hidden');
            winnerMapBtn.classList.remove('opacity-60', 'pointer-events-none');

            if (winner.isTeamEntry) {
                winnerAddress.innerHTML = `<span class="font-semibold text-gray-700">✍️</span> 팀에서 직접 적은 메뉴예요.`;
                winnerPhone.innerHTML = `<span class="font-semibold text-gray-700">📞</span> 연락처 정보가 없어요.`;
                winnerCallBtn.href = '#';
                winnerCallBtn.classList.add('hidden');
                winnerMapBtn.href = '#';
                winnerMapBtn.classList.add('opacity-60', 'pointer-events-none');
                winnerTip.innerHTML = `<span class="font-semibold text-gray-700">💡</span> 팀원들과 맛집 정보를 공유해보세요!`;
                winnerTag.textContent = '팀 추천';
                return;
            }

            winnerAddress.innerHTML = `<span class="font-semibold text-gray-700">📍</span> ${safeText(winner.road_address_name || winner.address_name || '주소 정보 없음')}`;
            const phone = winner.phone || '';
            if (phone) {
                winnerPhone.innerHTML = `<span class="font-semibold text-gray-700">📞</span> ${safeText(phone)}`;
                winnerCallBtn.href = `tel:${phone.replace(/[^0-9+]/g, '')}`;
            } else {
                winnerPhone.innerHTML = `<span class="font-semibold text-gray-700">📞</span> 전화 정보가 없어요.`;
                winnerCallBtn.href = '#';
                winnerCallBtn.classList.add('hidden');
            }
            if (winner.place_url) {
                winnerMapBtn.href = winner.place_url;
            } else {
                winnerMapBtn.href = '#';
                winnerMapBtn.classList.add('opacity-60', 'pointer-events-none');
            }
            winnerTip.innerHTML = `<span class="font-semibold text-gray-700">⏰</span> 영업시간 정보는 카카오 페이지에서 확인해주세요.`;
            winnerTag.textContent = modeSelect.value === 'random' ? '완전 랜덤!' : (modeSelect.value === 'distance' ? '가까운 행운' : '추천 픽');
        }
    </script>
</body>
</html>
